"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.domainsToChainNames = exports.getConfig = exports.getEnvConfig = exports.NxtpValidationSdkConfigSchema = exports.TValidationChainConfig = exports.SdkConfigSchema = exports.TChainConfig = exports.TChainDeployments = exports.TAssetDescription = void 0;
///NXTP Config Generator based on vector/modules/router/src/config.ts
const typebox_1 = require("@sinclair/typebox");
const nxtp_utils_1 = require("@connext/nxtp-utils");
const helpers_1 = require("./lib/helpers");
exports.TAssetDescription = typebox_1.Type.Object({
    name: typebox_1.Type.String(),
    address: nxtp_utils_1.TAddress,
    symbol: typebox_1.Type.String(),
    mainnetEquivalent: typebox_1.Type.Optional(nxtp_utils_1.TAddress),
});
exports.TChainDeployments = typebox_1.Type.Object({
    connext: nxtp_utils_1.TAddress,
    multisend: typebox_1.Type.Optional(nxtp_utils_1.TAddress),
    unwrapper: typebox_1.Type.Optional(nxtp_utils_1.TAddress),
    stableSwap: typebox_1.Type.Optional(nxtp_utils_1.TAddress),
});
exports.TChainConfig = typebox_1.Type.Object({
    providers: typebox_1.Type.Array(typebox_1.Type.String()),
    gasStations: typebox_1.Type.Optional(typebox_1.Type.Array(typebox_1.Type.String())),
    confirmations: typebox_1.Type.Optional(typebox_1.Type.Integer({ minimum: 1 })),
    chainId: typebox_1.Type.Optional(typebox_1.Type.Number()),
    deployments: typebox_1.Type.Optional(exports.TChainDeployments),
    assets: typebox_1.Type.Optional(typebox_1.Type.Array(exports.TAssetDescription)), /// Not Being Used
});
exports.SdkConfigSchema = typebox_1.Type.Object({
    chains: typebox_1.Type.Record(typebox_1.Type.String(), exports.TChainConfig),
    signerAddress: typebox_1.Type.Optional(nxtp_utils_1.TAddress),
    logLevel: typebox_1.Type.Optional(nxtp_utils_1.TLogLevel),
    cartographerUrl: typebox_1.Type.Optional(typebox_1.Type.String()),
    network: typebox_1.Type.Optional(typebox_1.Type.Union([typebox_1.Type.Literal("testnet"), typebox_1.Type.Literal("mainnet"), typebox_1.Type.Literal("local")])),
    environment: typebox_1.Type.Optional(typebox_1.Type.Union([typebox_1.Type.Literal("staging"), typebox_1.Type.Literal("production")])),
});
exports.TValidationChainConfig = typebox_1.Type.Object({
    providers: typebox_1.Type.Array(typebox_1.Type.String()),
    gasStations: typebox_1.Type.Array(typebox_1.Type.String()),
    confirmations: typebox_1.Type.Integer({ minimum: 1 }),
    deployments: typebox_1.Type.Object({
        connext: nxtp_utils_1.TAddress,
        multisend: typebox_1.Type.Optional(nxtp_utils_1.TAddress),
        stableSwap: typebox_1.Type.Optional(nxtp_utils_1.TAddress),
    }),
    assets: typebox_1.Type.Optional(typebox_1.Type.Array(exports.TAssetDescription)), /// Not Being Used
});
exports.NxtpValidationSdkConfigSchema = typebox_1.Type.Object({
    chains: typebox_1.Type.Record(typebox_1.Type.String(), exports.TValidationChainConfig),
    signerAddress: typebox_1.Type.Optional(nxtp_utils_1.TAddress),
    logLevel: nxtp_utils_1.TLogLevel,
    cartographerUrl: typebox_1.Type.String(),
    network: typebox_1.Type.Union([typebox_1.Type.Literal("testnet"), typebox_1.Type.Literal("mainnet"), typebox_1.Type.Literal("local")]),
    environment: typebox_1.Type.Union([typebox_1.Type.Literal("staging"), typebox_1.Type.Literal("production")]),
});
/**
 * Gets and validates the router config from the environment.
 *
 * @returns The router config with sensible defaults
 */
const getEnvConfig = (_nxtpConfig, chainData, deployments) => {
    const nxtpConfig = {
        ..._nxtpConfig,
        logLevel: _nxtpConfig.logLevel || "info",
        network: _nxtpConfig.network || "mainnet",
        environment: _nxtpConfig.environment || "production",
        cartographerUrl: _nxtpConfig.cartographerUrl
            ? _nxtpConfig.cartographerUrl
            : _nxtpConfig.network === "testnet"
                ? _nxtpConfig.environment === "staging"
                    ? "https://postgrest.testnet.staging.connext.ninja"
                    : "https://postgrest.testnet.connext.ninja"
                : "https://postgrest.mainnet.connext.ninja",
    };
    const defaultConfirmations = chainData && (chainData.get("1")?.confirmations ?? 1 + 3);
    const contractPostfix = nxtpConfig.environment === "production"
        ? ""
        : `${nxtpConfig.environment[0].toUpperCase()}${nxtpConfig.environment.slice(1)}`;
    // add contract deployments if they exist
    Object.entries(nxtpConfig.chains).forEach(([domainId, chainConfig]) => {
        const chainDataForChain = chainData.get(domainId);
        const chainRecommendedConfirmations = chainDataForChain?.confirmations ?? defaultConfirmations;
        const chainRecommendedGasStations = chainDataForChain?.gasStations ?? [];
        // Make sure deployments is filled out correctly.
        // allow passed in address to override
        // format: { [domainId]: { { "deployments": { "connext": <address>, ... } }
        nxtpConfig.chains[domainId].deployments = {
            connext: chainConfig.deployments?.connext ??
                (() => {
                    if (chainDataForChain) {
                        const res = deployments.connext(chainDataForChain.chainId, contractPostfix);
                        if (res) {
                            return res.address;
                        }
                    }
                    throw new Error(`No Connext contract address for domain ${domainId}`);
                })(),
            multisend: chainConfig.deployments?.multisend ??
                (() => {
                    if (chainDataForChain) {
                        const res = deployments.multisend(chainDataForChain.chainId);
                        return res?.address;
                    }
                    return undefined;
                })(),
            unwrapper: chainConfig.deployments?.unwrapper ??
                (() => {
                    if (chainDataForChain) {
                        const res = deployments.unwrapper(chainDataForChain.chainId);
                        return res?.address;
                    }
                    return undefined;
                })(),
        };
        nxtpConfig.chains[domainId].confirmations = chainConfig.confirmations ?? chainRecommendedConfirmations;
        nxtpConfig.chains[domainId].gasStations = (nxtpConfig.chains[domainId].gasStations ?? []).concat(chainRecommendedGasStations);
    });
    const validate = nxtp_utils_1.ajv.compile(exports.NxtpValidationSdkConfigSchema);
    const valid = validate(nxtpConfig);
    if (!valid) {
        throw new Error(validate.errors?.map((err) => JSON.stringify(err, null, 2)).join(","));
    }
    return nxtpConfig;
};
exports.getEnvConfig = getEnvConfig;
let nxtpConfig;
/**
 * Caches and returns the environment config
 *
 * @returns The config
 */
const getConfig = async (_nxtpConfig, deployments, _chainData) => {
    let chainData = _chainData;
    if (!chainData) {
        chainData = await (0, helpers_1.getChainData)();
    }
    nxtpConfig = (0, exports.getEnvConfig)(_nxtpConfig, chainData, deployments);
    return nxtpConfig;
};
exports.getConfig = getConfig;
exports.domainsToChainNames = {
    "6648936": "ethereum",
    "1869640809": "optimism",
    "1886350457": "polygon",
    "1634886255": "arbitrum",
    "6450786": "bsc",
    "6778479": "xdai",
};
//# sourceMappingURL=config.js.map