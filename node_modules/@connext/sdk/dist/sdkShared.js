"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdkShared = void 0;
const ethers_1 = require("ethers");
const nxtp_utils_1 = require("@connext/nxtp-utils");
const nxtp_txservice_1 = require("@connext/nxtp-txservice");
const smart_contracts_1 = require("@connext/smart-contracts");
const memoizee_1 = __importDefault(require("memoizee"));
const helpers_1 = require("./lib/helpers");
const errors_1 = require("./lib/errors");
const config_1 = require("./config");
/**
 * @classdesc SDK class encapsulating shared logic to be inherited.
 *
 */
class SdkShared {
    constructor(config, logger, chainData) {
        /**
         * Returns the provider specified in the SDK configuration for a specific domain.
         *
         * @param domainId - The domain ID.
         * @returns providers.StaticJsonRpcProvider object.
         */
        this.getProvider = (0, memoizee_1.default)((domainId) => {
            return new ethers_1.providers.StaticJsonRpcProvider(this.config.chains[domainId].providers[0]);
        });
        this.getDeploymentAddress = (0, memoizee_1.default)(async (domainId, deploymentName) => {
            const address = this.config.chains[domainId]?.deployments?.[deploymentName];
            if (!address) {
                throw new errors_1.ContractAddressMissing(domainId, deploymentName);
            }
            return address;
        }, { promise: true });
        /**
         * Returns the Connext diamond contract for the specified domain.
         *
         * @param domainId - The domain ID.
         * @returns Connext Contract object.
         */
        this.getConnext = (0, memoizee_1.default)(async (domainId) => {
            const connextAddress = await this.getDeploymentAddress(domainId, "connext");
            const provider = this.getProvider(domainId);
            return smart_contracts_1.Connext__factory.connect(connextAddress, provider);
        }, { promise: true });
        /**
         * Returns the ERC20 contract for the specified domain.
         *
         * @param domainId - The domain ID.
         * @returns ERC20 Contract object.
         */
        this.getERC20 = (0, memoizee_1.default)(async (domainId, tokenAddress) => {
            const provider = this.getProvider(domainId);
            return smart_contracts_1.IERC20__factory.connect(tokenAddress, provider);
        }, { promise: true });
        /**
         * Returns the chain ID for a specified domain.
         *
         * @param domainId - The domain ID.
         * @returns The chain ID.
         */
        this.getChainId = (0, memoizee_1.default)(async (domainId) => {
            let chainId = this.config.chains[domainId]?.chainId;
            if (!chainId) {
                chainId = await (0, helpers_1.getChainIdFromDomain)(domainId, this.chainData);
            }
            return chainId;
        }, { promise: true });
        /**
         * Fetches the list of registered assets.
         *
         * @returns Array of objects containing assets registered to the network, in the form of:
         * ```ts
         * {
         *   "local": "0x2983bf5c334743aa6657ad70a55041d720d225db",
         *   "adopted": "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
         *   "canonical_id": "0x000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
         *   "canonical_domain": "6648936",
         *   "domain": "1634886255",
         *   "key": "0x12acadfa38ab02479ae587196a9043ee4d8bf52fcb96b7f8d2ba240f03bcd08a",
         *   "id": "0x2983bf5c334743aa6657ad70a55041d720d225db"
         * },
         * ```
         */
        this.getAssetsData = (0, memoizee_1.default)(async () => {
            const uri = (0, nxtp_utils_1.formatUrl)(this.config.cartographerUrl, "assets");
            // Validate uri
            (0, helpers_1.validateUri)(uri);
            return await (0, helpers_1.axiosGetRequest)(uri);
        }, { promise: true, maxAge: 5 * 60 * 1000 });
        this.config = config;
        this.logger = logger;
        this.chainData = chainData;
        this.contracts = (0, nxtp_txservice_1.getContractInterfaces)();
        this.chainreader = new nxtp_txservice_1.ChainReader(logger.child({ module: "ChainReader" }, this.config.logLevel), config.chains);
    }
    /**
     * Returns the chain name for a specified domain.
     *
     * @param domainId - The domain ID.
     * @returns The chain name.
     */
    static domainToChainName(domainId) {
        return config_1.domainsToChainNames[domainId];
    }
    /**
     * Uses an external API to fetch the block number from a unix timestamp.
     *
     * @param domainId - The domain ID.
     * @param unixTimestamp - The unix timestamp.
     * @returns The closest block number.
     */
    static async getBlockNumberFromUnixTimestamp(domainId, unixTimestamp) {
        const baseUrl = "https://coins.llama.fi";
        const uri = (0, nxtp_utils_1.formatUrl)(baseUrl, "block");
        const chainName = this.domainToChainName(domainId);
        const res = await (0, helpers_1.axiosGetRequest)(uri + `/${chainName}` + `/${unixTimestamp}`);
        return res.height;
    }
    /**
     * Returns the transaction request for an allowance approval.
     *
     * @param domainId - The domain ID.
     * @param assetId - The address of the token.
     * @param amount - The amount of the token.
     * @param infiniteApprove - (optional) Whether to approve an infinite amount.
     * @returns providers.TransactionRequest object.
     */
    async approveIfNeeded(domainId, assetId, amount, infiniteApprove = true) {
        const { requestContext, methodContext } = (0, nxtp_utils_1.createLoggingContext)(this.approveIfNeeded.name);
        const signerAddress = this.config.signerAddress;
        this.logger.info("Method start", requestContext, methodContext, {
            domainId,
            assetId,
            amount,
            signerAddress,
        });
        if (!signerAddress) {
            throw new errors_1.SignerAddressMissing();
        }
        const connextContract = await this.getConnext(domainId);
        const erc20Contract = await this.getERC20(domainId, assetId);
        if (assetId !== ethers_1.constants.AddressZero) {
            const approved = await erc20Contract.allowance(signerAddress, connextContract.address);
            if (ethers_1.BigNumber.from(approved).lt(amount)) {
                const approveData = erc20Contract.populateTransaction.approve(connextContract.address, infiniteApprove ? ethers_1.constants.MaxUint256 : amount);
                return approveData;
            }
            else {
                this.logger.info("Allowance sufficient", requestContext, methodContext, {
                    approved: approved.toString(),
                    amount,
                });
                return undefined;
            }
        }
        return undefined;
    }
    /**
     * Fetches the list of supported networks and assets.
     *
     * @returns Array of objects containing networks and assets supported by the protocol, in the form of:
     * ```ts
     * {
     *   "name": "arbitrum",
     *   "chainId": 42161,
     *   "domainId": "1634886255",
     *   "assets": [
     *     "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
     *     "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8"
     *   ]
     * },
     * ```
     */
    async getSupported() {
        const data = await this.getAssetsData();
        const supported = new Map();
        for (const asset of data) {
            const support = supported.get(asset.domain);
            if (support) {
                support.assets.push(asset.adopted);
            }
            else {
                const entry = {
                    name: config_1.domainsToChainNames[asset.domain],
                    chainId: await (0, helpers_1.getChainIdFromDomain)(asset.domain),
                    domainId: asset.domain,
                    assets: [asset.adopted],
                };
                supported.set(asset.domain, entry);
            }
        }
        const res = Array.from(supported.values());
        return res;
    }
    /**
     * Retrieve the asset data for a specific domain and address.
     *
     * @param domainId - The domain ID.
     * @param tokenAddress - The local or adopted address.
     * @returns The object containing asset data.
     */
    async getAssetsDataByDomainAndAddress(domainId, tokenAddress) {
        const assetsData = await this.getAssetsData();
        const _tokenAddress = ethers_1.utils.getAddress(tokenAddress);
        const asset = assetsData.find((assetData) => {
            return (domainId === assetData.domain &&
                (ethers_1.utils.getAddress(assetData.local) == _tokenAddress || ethers_1.utils.getAddress(assetData.adopted) == _tokenAddress));
        });
        if (asset) {
            return asset;
        }
        return;
    }
    /**
     * Retrieve the asset data for a specific domain and key.
     *
     * @param domainId - The domain ID.
     * @param key - The canonical hash of the canonical token.
     * @returns The object containing asset data.
     */
    async getAssetsDataByDomainAndKey(domainId, key) {
        const assetsData = await this.getAssetsData();
        const asset = assetsData.find((assetData) => {
            return assetData.domain == domainId && assetData.key == key;
        });
        if (asset) {
            return asset;
        }
        return;
    }
    /**
     * Returns whether the specified token is a Connext-issued (local) token.
     *
     * @param tokenAddress - The address of the token.
     * @returns Boolean or undefined if the specified token is not registered.
     */
    async isNextAsset(tokenAddress) {
        const assetsData = await this.getAssetsData();
        const asset = assetsData.find((assetData) => {
            return ethers_1.utils.getAddress(assetData.local) == tokenAddress || ethers_1.utils.getAddress(assetData.adopted) == tokenAddress;
        });
        if (asset) {
            return ethers_1.utils.getAddress(asset.local) == tokenAddress ? true : false;
        }
        return;
    }
    /**
     * Switches the signer address in the SDK config.
     *
     * @param signerAddress - The new signer address.
     */
    async changeSignerAddress(signerAddress) {
        this.config.signerAddress = signerAddress;
    }
    /**
     * Parses a providers.TransactionReceipt for the logs.
     *
     * @param transactionReceipt - providers.TransactionReceipt object.
     * @returns Array of providers.Log objects.
     */
    parseConnextTransactionReceipt(transactionReceipt) {
        const parsedlogs = [];
        transactionReceipt.logs.forEach((log) => {
            parsedlogs.push((0, helpers_1.parseConnextLog)(log));
        });
        return parsedlogs;
    }
    /**
     * Returns the hash of the canonical ID + canonical domain.
     *
     * @remarks
     * This key is used as the unique identifier for a canonical token, across all domains.
     *
     * @param domainId The canonical domain ID of the token.
     * @param canonicalId The canonical ID of the token.
     */
    calculateCanonicalKey(domainId, canonicalId) {
        return (0, nxtp_utils_1.getCanonicalHash)(domainId, canonicalId);
    }
    /**
     * Returns the canonical ID and canonical domain of a token.
     *
     * @param domainId The canonical domain ID of the token.
     * @param tokenAddress The address of the token.
     */
    async getCanonicalTokenId(domainId, tokenAddress) {
        const asset = await this.getAssetsDataByDomainAndAddress(domainId, tokenAddress);
        if (asset) {
            return [asset.canonical_domain, asset.canonical_id];
        }
        return ["0", ethers_1.constants.HashZero];
    }
}
exports.SdkShared = SdkShared;
//# sourceMappingURL=sdkShared.js.map