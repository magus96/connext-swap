"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("hardhat/config");
const ethers_1 = require("ethers");
const nxtp_utils_1 = require("@connext/nxtp-utils");
const hardhat_config_1 = __importDefault(require("../hardhat.config"));
const utils_1 = require("../src/utils");
const shared_1 = require("../deployConfig/shared");
const src_1 = require("../src");
exports.default = (0, config_1.task)("submit-exit-proof", "Submit Exit proof to L2 chain")
    .addParam("txHash", "Burn Tx Hash on L2 chain")
    .addOptionalParam("env", "Environment of contracts")
    .addOptionalParam("networkType", "Type of network of contracts")
    .setAction(async ({ txHash, env: _env, networkType: _network }, hre) => {
    const chain = await hre.getChainId();
    let { deployer } = await hre.ethers.getNamedSigners();
    if (!deployer) {
        [deployer] = await hre.ethers.getUnnamedSigners();
    }
    const env = (0, utils_1.mustGetEnv)(_env);
    console.log("env:", env);
    console.log("deployer: ", deployer.address);
    // get messaging config
    const network = _network ?? utils_1.ProtocolNetwork.TESTNET;
    const protocol = shared_1.MESSAGING_PROTOCOL_CONFIGS[network];
    if (!protocol || !protocol.configs[protocol.hub]) {
        throw new Error(`Network ${network} is not supported! (no messaging config)`);
    }
    console.log("protocol.hub: ", protocol.hub);
    console.log("+chain: ", +chain);
    if (protocol.hub !== +chain) {
        throw new Error(`Current network is not hub`);
    }
    const deployments = (0, utils_1.getConnectorDeployments)(env, network);
    const L1ConnectorDeployment = deployments.find(({ name }) => name === (0, utils_1.getDeploymentName)(`Polygon${shared_1.HUB_PREFIX}Connector`));
    const L2ConnectorDeployment = deployments.find(({ name }) => name === (0, utils_1.getDeploymentName)(`Polygon${shared_1.SPOKE_PREFIX}Connector`));
    if (!L1ConnectorDeployment || !L2ConnectorDeployment) {
        throw new Error(`Deployment records not found for ${chain}`);
    }
    const providers = new Map();
    for (const network of Object.values(hardhat_config_1.default.networks)) {
        if (network && network.chainId && network.url) {
            try {
                const domain = (0, src_1.chainIdToDomain)(network.chainId);
                providers.set(String(domain), [network.url]);
            }
            catch { }
        }
    }
    const SEND_MESSAGE_EVENT_SIG = "0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036"; // keccak256(MessageSent(bytes))
    const payload = await (0, nxtp_utils_1.generateExitPayload)(String((0, src_1.chainIdToDomain)(L2ConnectorDeployment.chain)), String((0, src_1.chainIdToDomain)(L1ConnectorDeployment.chain)), txHash, SEND_MESSAGE_EVENT_SIG, providers);
    if (payload) {
        const L1ConnectorContract = new ethers_1.Contract(L1ConnectorDeployment.address, L1ConnectorDeployment.abi, deployer);
        const tx = await L1ConnectorContract.receiveMessage(payload);
        console.log(`receive message tx`, tx.hash);
        const receipt = await tx.wait();
        console.log("receipt", receipt);
    }
});
//# sourceMappingURL=submitExitProof.js.map