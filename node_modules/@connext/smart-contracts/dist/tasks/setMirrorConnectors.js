"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("hardhat/config");
const ethers_1 = require("ethers");
const hardhat_config_1 = __importDefault(require("../hardhat.config"));
const utils_1 = require("../src/utils");
exports.default = (0, config_1.task)("set-mirror-connectors", "Add a remote router")
    .addOptionalParam("env", "Environment of contracts")
    .addOptionalParam("networkType", "Type of network of contracts")
    .setAction(async ({ env: _env, networkType }, hre) => {
    const chain = await hre.getChainId();
    const networkConfig = Object.values(hardhat_config_1.default.networks).find((n) => n?.chainId === +chain);
    const deployer = ethers_1.Wallet.fromMnemonic(networkConfig.accounts.mnemonic);
    const env = (0, utils_1.mustGetEnv)(_env);
    console.log("env:", env);
    console.log("deployer: ", deployer.address);
    await (0, utils_1.executeOnAllConnectors)(env, networkType ?? utils_1.ProtocolNetwork.TESTNET, async (deployment, provider) => {
        const { name, address, abi, mirrorConnector } = deployment;
        // Create the connector contract
        const connector = new ethers_1.Contract(address, abi, deployer.connect(provider));
        // Check if mirror is set
        const set = await connector.mirrorConnector();
        if (!mirrorConnector || set.toLowerCase() === mirrorConnector.toLowerCase()) {
            return;
        }
        else {
            console.log(`setting mirror connector to ${mirrorConnector} on ${name}...`);
            const tx = await connector.setMirrorConnector(mirrorConnector);
            console.log(`set mirror tx sent:`, tx.hash);
            const receipt = await tx.wait();
            console.log(`tx mined:`, receipt.transactionHash);
        }
        if (name.includes("PolygonHubConnector")) {
            console.log(`setting fxChildTunnel to ${mirrorConnector} on ${name}...`);
            const tx = await connector.setFxChildTunnel(mirrorConnector);
            console.log(`set fxChildTunnel tx sent:`, tx.hash);
            const receipt = await tx.wait();
            console.log(`tx mined:`, receipt.transactionHash);
        }
        if (name.includes("PolygonSpokeConnector")) {
            console.log(`setting fxRootTunnel to ${mirrorConnector} on ${name}...`);
            const tx = await connector.setFxRootTunnel(mirrorConnector);
            console.log(`set fxRootTunnel tx sent:`, tx.hash);
            const receipt = await tx.wait();
            console.log(`tx mined:`, receipt.transactionHash);
        }
    });
});
//# sourceMappingURL=setMirrorConnectors.js.map