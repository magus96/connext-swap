"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("ethers/lib/utils");
const config_1 = require("hardhat/config");
const ethers_1 = require("ethers");
const src_1 = require("../src");
const utils_2 = require("../src/utils");
const deployments_json_1 = __importDefault(require("../deployments.json"));
exports.default = (0, config_1.task)("enroll-handlers", "Add a remote router")
    .addParam("type", "Which handler to enroll (all, connext, promise, relayer")
    .addParam("chains", "List of all chain ids to deploy to (comma-separated)")
    .addOptionalParam("env", "Environment of contracts")
    .setAction(async ({ type, chains: _chains, env: _env }, hre) => {
    let { deployer } = await hre.ethers.getNamedSigners();
    if (!deployer) {
        [deployer] = await hre.ethers.getUnnamedSigners();
    }
    const current = await hre.ethers.provider.getNetwork();
    const chains = _chains
        .split(",")
        .map((c) => +c)
        .filter((c) => c != current.chainId);
    const env = (0, utils_2.mustGetEnv)(_env);
    console.log("env:", env);
    console.log("type:", type);
    console.log("chains:", chains);
    console.log("deployer: ", deployer.address);
    const names = ["BridgeRouterUpgradeBeaconProxy", "RelayerFeeRouterUpgradeBeaconProxy"]
        .filter((name) => {
        if (type === "all") {
            return true;
        }
        return name.toLowerCase().startsWith(type);
    })
        .map((name) => (0, utils_2.getDeploymentName)(name, env));
    // get deployments for the other chains
    const handlers = chains.map((chain) => {
        const [record] = deployments_json_1.default[chain];
        if (!record) {
            throw new Error(`Deployment records not found for ${chain}`);
        }
        const remotes = names.map((name) => {
            const { address, abi } = record.contracts[name] ?? {};
            if (!address || !abi) {
                throw new Error(`Deployment values not found for ${name} on ${chain}`);
            }
            return { address, abi, name };
        });
        return { chain, remotes };
    });
    for (const { chain, remotes } of handlers) {
        console.log(`enrolling ${remotes.length} remote handlers for ${chain}`);
        const domain = (0, src_1.chainIdToDomain)(chain);
        for (const { address, name } of remotes) {
            const localRouterDeployment = await hre.deployments.get(name);
            const { abi: localRouterAbi } = await hre.deployments.get(
            // handle upgrade naming case
            name.includes("UpgradeBeaconProxy") ? (0, utils_2.getDeploymentName)(name.split("UpgradeBeaconProxy")[0], env) : name);
            const local = localRouterDeployment.address;
            console.log("name:", name); // ${name} as remote ${name} on local ${local}`);
            console.log("remote:", address);
            console.log("local:", local);
            const localRouter = new ethers_1.Contract(local, localRouterAbi, deployer);
            const enrollTx = await localRouter.enrollRemoteRouter(domain, (0, utils_1.hexlify)((0, src_1.canonizeId)(address)));
            console.log("enroll tx:", enrollTx);
            const receipt = await enrollTx.wait();
            console.log("enroll tx mined:", receipt);
        }
    }
});
//# sourceMappingURL=enrollHandlers.js.map