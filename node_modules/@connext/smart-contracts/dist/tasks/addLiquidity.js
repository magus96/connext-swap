"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const config_1 = require("hardhat/config");
const utils_2 = require("../src/utils");
exports.default = (0, config_1.task)("add-liquidity", "Add liquidity for a router")
    .addParam("router", "Router address")
    .addParam("asset", "Local token address")
    .addParam("amount", "Amount (real units)")
    .addOptionalParam("connextAddress", "Override connext address")
    .addOptionalParam("env", "Environment of contracts")
    .setAction(async ({ asset, router, connextAddress: _connextAddress, amount: _amount, env: _env }, { deployments, ethers }) => {
    let { deployer } = await ethers.getNamedSigners();
    if (!deployer) {
        [deployer] = await ethers.getUnnamedSigners();
    }
    const env = (0, utils_2.mustGetEnv)(_env);
    console.log("env:", env);
    console.log("router: ", router);
    console.log("asset: ", asset);
    console.log("deployer: ", deployer.address);
    const connextName = (0, utils_2.getDeploymentName)("Connext", env);
    const connextDeployment = await deployments.get(connextName);
    const connextAddress = _connextAddress ?? connextDeployment.address;
    console.log("connextAddress: ", connextAddress);
    const connext = new ethers_1.Contract(connextAddress, connextDeployment.abi, deployer);
    let liquidity = await connext.routerBalances(router, asset);
    console.log("current liquidity: ", liquidity.toString());
    let amount;
    if (asset !== ethers.constants.AddressZero) {
        const erc20 = await ethers.getContractAt("TestERC20", asset);
        const balance = await erc20.balanceOf(deployer.address);
        amount = ethers_1.utils.parseUnits(_amount, (await erc20.decimals()));
        console.log("balance: ", balance.toString());
        console.log("amount: ", amount.toString());
        if (balance.lt(amount)) {
            throw new Error("Not enough balance");
        }
        const allowance = await erc20.allowance(deployer.address, connext.address);
        if (allowance.lt(amount)) {
            const approveTx = await erc20.approve(connext.address, ethers.constants.MaxUint256);
            console.log("approveTx: ", approveTx.hash);
            await approveTx.wait();
            console.log("approveTx mined");
        }
        else {
            console.log(`Sufficient allowance: ${allowance.toString()}`);
        }
    }
    else {
        amount = ethers_1.utils.parseEther(_amount);
    }
    const approvedRouter = await connext.getRouterApproval(router);
    console.log("approvedRouter: ", approvedRouter);
    if (!approvedRouter) {
        throw new Error("Router not approved");
    }
    const [domain, canonical] = await connext.getTokenId(asset);
    console.log("domain: ", domain);
    console.log("canonical: ", canonical);
    const key = (0, utils_1.solidityKeccak256)(["bytes"], [utils_1.defaultAbiCoder.encode(["bytes32", "uint32"], [canonical, domain])]);
    const [approvedAsset] = connext.interface.decodeFunctionResult("approvedAssets(bytes32)", await deployer.call({
        to: connext.address,
        value: ethers_1.constants.Zero,
        data: connext.interface.encodeFunctionData("approvedAssets(bytes32)", [key]),
    }));
    console.log("approvedAsset: ", approvedAsset);
    if (!approvedAsset) {
        throw new Error("Asset not approved");
    }
    console.log("args:", amount.toString(), asset, router);
    const tx = await connext.addRouterLiquidityFor(amount, asset, router, {
        value: asset === ethers.constants.AddressZero ? amount : 0,
    });
    console.log("addLiquidityFor tx: ", tx);
    const receipt = await tx.wait();
    console.log("addLiquidityFor tx mined: ", receipt.transactionHash);
    liquidity = await connext.routerBalances(router, asset);
    console.log("liquidity: ", liquidity.toString());
});
//# sourceMappingURL=addLiquidity.js.map