"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("hardhat/config");
const ethers_1 = require("ethers");
const nxtp_utils_1 = require("@connext/nxtp-utils");
const hardhat_config_1 = __importDefault(require("../hardhat.config"));
const utils_1 = require("../src/utils");
const shared_1 = require("../deployConfig/shared");
exports.default = (0, config_1.task)("add-connectors", "Add all connectors to the root manager")
    .addOptionalParam("env", "Environment of contracts")
    .addOptionalParam("networkType", "Type of network of contracts")
    .addFlag("remove", "Whether or not to remove connectors that exist")
    .setAction(async ({ env: _env, remove: _remove, networkType: _networkType }, hre) => {
    const chain = await hre.getChainId();
    const networkConfig = Object.values(hardhat_config_1.default.networks).find((n) => n?.chainId === +chain);
    const deployer = ethers_1.Wallet.fromMnemonic(networkConfig.accounts.mnemonic);
    const env = (0, utils_1.mustGetEnv)(_env);
    const remove = _remove;
    const networkType = _networkType ?? utils_1.ProtocolNetwork.TESTNET;
    console.log("networkType: ", networkType);
    console.log("env:", env);
    console.log("remove:", remove);
    console.log("deployer: ", deployer.address);
    const network = await hre.ethers.provider.getNetwork();
    const config = (0, utils_1.getMessagingProtocolConfig)(networkType);
    if (+network.chainId != config.hub) {
        throw new Error(`Should be on ${config.hub}, not ${network.chainId}`);
    }
    const rootManagerDeployment = await hre.deployments.getOrNull((0, utils_1.getDeploymentName)("RootManager", env));
    if (!rootManagerDeployment) {
        throw new Error(`Could not find RootManager on ${network.chainId}`);
    }
    const rootManager = new ethers_1.Contract(rootManagerDeployment.address, rootManagerDeployment.abi, deployer.connect(hre.ethers.provider));
    await (0, utils_1.executeOnAllConnectors)(env, networkType, async (deployment, _provider) => {
        const { name, address, chain, mirrorChain } = deployment;
        if (!name.includes(shared_1.HUB_PREFIX) && !name.includes("Mainnet")) {
            // this is not the relevant connector
            return;
        }
        // connector now has "L1" in the title
        // NOTE: on mainnet connector there will be no mirror chain, so just register the mainnet
        // domain
        const domain = await (0, nxtp_utils_1.getDomainFromChainId)(mirrorChain ?? chain);
        console.log(`trying to enroll connector for ${domain} (${mirrorChain ?? chain})`);
        let stored = await rootManager.connectors(domain);
        if (stored.toLowerCase() === address.toLowerCase()) {
            console.log(`${name} already registered for ${domain}: ${address}`);
            return;
        }
        // Must either remove before enlisting
        if (stored !== ethers_1.constants.AddressZero || remove) {
            console.log(`Removing ${name} registered for ${domain}: ${stored}`);
            const tx = await rootManager.removeConnector(domain);
            console.log("remove connector tx submitted:", tx.hash);
            const receipt = await tx.wait();
            console.log("remove connector tx mined:", receipt.transactionHash);
        }
        stored = await rootManager.connectors(domain);
        if (stored === ethers_1.constants.AddressZero) {
            console.log(`Adding ${name} for ${domain}: ${address}`);
            const tx = await rootManager.addConnector(domain, address);
            console.log("add connector tx submitted:", tx.hash);
            const receipt = await tx.wait();
            console.log("add connector tx mined:", receipt.transactionHash);
        }
    });
});
//# sourceMappingURL=addConnectors.js.map