"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const config_1 = require("hardhat/config");
exports.default = (0, config_1.task)("dust", "Dust other accounts on a wallet")
    .addParam("amount", "Amount to dust (real units)")
    .addOptionalParam("minimumOnly", "Whether to skip accounts that already have enough")
    .setAction(async ({ amount, minimumOnly: _minimumOnly }, hre) => {
    const minimumOnly = _minimumOnly === "true" ? true : false;
    const [sender, ...accounts] = await hre.ethers.getSigners();
    const amountBase = ethers_1.utils.parseUnits(amount, 18);
    console.log(`Sender: ${sender.address}`);
    const balances = await hre.run("read-balances");
    // Check sender has enough to send to all accounts
    let senderBalanceNeeded = ethers_1.BigNumber.from(0);
    const toSend = new Map();
    if (minimumOnly) {
        for (const account of accounts) {
            const balance = balances.get(account.address);
            if (balance.lt(amountBase)) {
                const diff = amountBase.sub(balance);
                toSend.set(account.address, diff);
                senderBalanceNeeded = senderBalanceNeeded.add(diff);
                console.log(`Account ${account.address} needs ${ethers_1.utils.formatEther(diff)} more`);
            }
        }
        console.log(`Total amount to distribute: ${ethers_1.utils.formatEther(senderBalanceNeeded)}`);
    }
    else {
        senderBalanceNeeded = amountBase.mul(accounts.length);
        console.log(`Amount to distribute each: ${amount} (total: ${ethers_1.utils.formatEther(senderBalanceNeeded)})`);
    }
    const balance = await hre.ethers.provider.getBalance(sender.address);
    if (balance.lt(senderBalanceNeeded)) {
        throw new Error(`Sender balance (${ethers_1.utils.formatEther(balance)}) is less than total needed (>${ethers_1.utils.formatEther(senderBalanceNeeded)})`);
    }
    // Send amount to each recipient
    const sendTxn = async (recipient, amt) => {
        const tx = await sender.sendTransaction({
            to: recipient,
            value: amt,
            gasLimit: 1000000,
        });
        const receipt = await tx.wait();
        console.log(`Sent ${ethers_1.utils.formatEther(amt)} to ${recipient}`);
        console.log(`  Tx: ${receipt.transactionHash}`);
        const balance = ethers_1.utils.formatEther(await hre.ethers.provider.getBalance(recipient));
        console.log("  New balance: ", balance);
        return receipt.transactionHash;
    };
    for (let i = 0; i < accounts.length; i++) {
        if (minimumOnly) {
            if (toSend.has(accounts[i].address)) {
                await sendTxn(accounts[i].address, toSend.get(accounts[i].address));
            }
        }
        else {
            await sendTxn(accounts[i].address, amountBase);
        }
    }
});
//# sourceMappingURL=dustSelfAccounts.js.map