"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sdk_1 = require("@arbitrum/sdk");
const ethers_1 = require("ethers");
const config_1 = require("hardhat/config");
const utils_1 = require("../../src/utils");
const redeemFromArbitrum = async (hash, signer, force, hubProvider, spokeProvider) => {
    // Get the message receipt from arbitrum sdk
    const receipt = new sdk_1.L1TransactionReceipt(await hubProvider.getTransactionReceipt(hash));
    console.log("got l1 -> l2 message receipt on l1", receipt.transactionHash);
    // get the mesesage (assume only one arb message in receipt)
    const [message] = await receipt.getL1ToL2Messages(signer.connect(spokeProvider));
    const { status } = await message.waitForStatus();
    console.log("got l1 -> l2 message", message);
    // check to see if it needs redemption
    if (status != sdk_1.L1ToL2MessageStatus.FUNDS_DEPOSITED_ON_L2) {
        throw new Error(`Not ready to redeem, or was auto-redeemed. Status: ${status}`);
    }
    // check to see if an auto-redeem was attempted
    const autoRedeem = await message.getAutoRedeemAttempt();
    console.log("auto-redeem attempt", autoRedeem);
    // redeep message
    console.log("redeeming message...");
    const response = await message.redeem(!force ? {} : { gasLimit: 1000000 });
    console.log("redeem tx", response.hash);
    const redeemReceipt = await response.waitForRedeem();
    console.log("redeem tx mined", redeemReceipt);
};
exports.default = (0, config_1.task)("redeem", "Process a transaction on a spoke for L1 -> L2 messages")
    .addParam("tx", "The hash of the L1 tx that sent the L1 -> L2 message")
    .addParam("spoke", "The chainId for the spoke")
    .addOptionalParam("force", "Whether the redeem tx should be forced (bypass estimate gas)")
    .addOptionalParam("env", "Environment of contracts")
    .addOptionalParam("networkType", "Type of network of contracts")
    .setAction(async ({ tx, force: _force, spoke: _spoke, networkType: _networkType, env: _env }) => {
    const deployer = ethers_1.Wallet.fromMnemonic(process.env.MNEMONIC);
    const env = (0, utils_1.mustGetEnv)(_env);
    const spoke = +_spoke;
    const networkType = _networkType ?? utils_1.ProtocolNetwork.TESTNET;
    const force = _force === "true";
    console.log("networkType: ", networkType);
    console.log("env:", env);
    console.log("tx", tx);
    console.log("force", force);
    console.log("spoke", spoke);
    console.log("deployer", deployer.address);
    // get config
    const protocolConfig = (0, utils_1.getMessagingProtocolConfig)(networkType);
    // Right now this only works on arbitrum, error if that is not the correct network
    if (spoke !== 421613) {
        throw new Error(`Only arbitrum-goerli supported, requesting redeem for spoke ${spoke}`);
    }
    // get the l2 provider
    const l2Provider = (0, utils_1.getProviderFromHardhatConfig)(spoke);
    // get the l1 provider
    const l1Provider = (0, utils_1.getProviderFromHardhatConfig)(protocolConfig.hub);
    await redeemFromArbitrum(tx, deployer, force, l1Provider, l2Provider);
});
//# sourceMappingURL=redeem.js.map