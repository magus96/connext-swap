"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("hardhat/config");
const sdk_1 = require("@arbitrum/sdk");
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const networks_1 = require("@arbitrum/sdk/dist/lib/dataEntities/networks");
const sdk_2 = require("@eth-optimism/sdk");
const NodeInterface__factory_1 = require("@arbitrum/sdk/dist/lib/abi/factories/NodeInterface__factory");
const constants_1 = require("@arbitrum/sdk/dist/lib/dataEntities/constants");
const utils_2 = require("../../src/utils");
const RollupUserLogic__factory_1 = require("../../src/abis/RollupUserLogic__factory");
const src_1 = require("../../src");
const processFromArbitrumRoot = async (spoke, sendHash, spokeProvider, hubProvider, deployer) => {
    // // // Things that are needed:
    // // uint64 _nodeNum, x
    // // bytes32 _sendRoot, x
    // // bytes32 _blockHash, x
    // // bytes32[] calldata _proof, x
    // // uint256 _index, x
    // // L2Message calldata _message x
    // // get the tx
    const l2TxnReceipt = new sdk_1.L2TransactionReceipt(await spokeProvider.getTransactionReceipt(sendHash));
    // @ts-ignore
    const dataIsOnL1 = await l2TxnReceipt.isDataAvailable(spokeProvider);
    if (!dataIsOnL1) {
        throw new Error(`tx data not yet posted to l1`);
    }
    // get the proof
    const [msg] = await l2TxnReceipt.getL2ToL1Messages(hubProvider);
    const index = msg.event.position;
    console.log("index", index.toNumber());
    // construct the l2 message information
    const l2Message = {
        l2Sender: msg.event.caller,
        to: msg.event.destination,
        l2Block: msg.event.arbBlockNum,
        l1Block: msg.event.ethBlockNum,
        l2Timestamp: msg.event.timestamp,
        value: msg.event.callvalue,
        callData: msg.event.data,
    };
    console.log("l2Message", l2Message);
    // get the node number by finding the node created event with matching send
    // root.
    // a node is the bit of data that includes the l2 state that will eventually
    // get posted into an outbox (where the messages are proven against once the
    // fraud period elapses). because the node is not directly user facing, there are
    // not many utility methods for accessing it. you can get the node num in two ways:
    // 1. Find the `NodeCreated` event where the currentInboxSize > the l2->l1 message
    //    sequence number. Sample of finding this event can be seen here:
    //    https://github.com/OffchainLabs/arbitrum-sdk/blob/0151a79ed37a65033991bb107d6e1072bfc052c0/src/lib/message/L2ToL1Message.ts#L397-L455
    //    NOTE: this was the original method tried, but failed to find the correct node
    //    created event (it was failing when verifying the sendRoot in the connector)
    // 2. Calculate the send root and the item hash using the `Outbox.sol` interface, then
    //    find the event emitted after the `ethBlockNum` of the message containing a matching
    //    sendRoot. Find the nodeNum from this event, and submit to chain. Not used.
    const arbNetwork = networks_1.l2Networks[spoke];
    const fetcher = new sdk_1.EventFetcher(hubProvider);
    console.log("searching for node created events at", arbNetwork.ethBridge.rollup);
    const logs = await fetcher.getEvents(arbNetwork.ethBridge.rollup, RollupUserLogic__factory_1.RollupUserLogic__factory, (t) => t.filters.NodeCreated(), {
        fromBlock: msg.event.ethBlockNum.toNumber(),
        toBlock: "latest",
    });
    // use binary search to find the first node with sendCount > this.event.position
    // default to the last node since we already checked above
    let foundLog = logs[logs.length - 1];
    let left = 0;
    let right = logs.length - 1;
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        const log = logs[mid];
        const block = await msg.getBlockFromNodeLog(spokeProvider, log);
        const sendCount = ethers_1.BigNumber.from(block.sendCount);
        if (sendCount.gt(msg.event.position)) {
            foundLog = log;
            right = mid - 1;
        }
        else {
            left = mid + 1;
        }
    }
    const earliestNodeWithExit = foundLog.event.nodeNum;
    const rollup = RollupUserLogic__factory_1.RollupUserLogic__factory.getContract(arbNetwork.ethBridge.rollup, RollupUserLogic__factory_1.RollupUserLogic__factory.abi, deployer.connect(hubProvider));
    const foundBlock = await msg.getBlockFromNodeNum(rollup, earliestNodeWithExit, spokeProvider);
    console.log("node:", earliestNodeWithExit.toString());
    console.log("msg.position", msg.event.position.toString());
    console.log("foundLog:", foundLog);
    console.log("foundBlock:", foundBlock);
    const node = await rollup.getNode(earliestNodeWithExit);
    if (node.confirmData.toLowerCase() !==
        (0, utils_1.keccak256)(utils_1.defaultAbiCoder.encode(["bytes32", "bytes32"], [foundBlock.hash, foundBlock.sendRoot])).toLowerCase()) {
        throw new Error(`something went wrong -- confirm data does not match`);
    }
    // get the proof
    const params = await NodeInterface__factory_1.NodeInterface__factory.connect(constants_1.NODE_INTERFACE_ADDRESS, spokeProvider).constructOutboxProof(foundBlock.sendCount.toNumber(), msg.event.position.toNumber());
    // generate the args to submit
    const args = [earliestNodeWithExit, foundBlock.sendRoot, foundBlock.hash, params.proof, index, l2Message];
    console.log("args", args);
    return args;
};
const processFromOptimismRoot = async (spoke, sendHash, protocolConfig, spokeProvider, hubProvider) => {
    // When processing from root on optimism, you need the following information:
    //   address _target, -> connector
    //   address _sender, -> mirror connector
    //   bytes memory _message, -> calldata
    //   uint256 _messageNonce, -> ?
    //   L2MessageInclusionProof memory _proof -> taken from sdk
    // create the messenger
    const messenger = new sdk_2.CrossChainMessenger({
        l2ChainId: spoke,
        l2SignerOrProvider: spokeProvider,
        l1ChainId: protocolConfig.hub,
        l1SignerOrProvider: hubProvider,
    });
    // check to make sure you can prove
    let root;
    while (!root) {
        root = await messenger.getMessageStateRoot(sendHash);
        if (!root) {
            console.log("no root yet, waiting so patiently");
            await (0, src_1.delay)(2000);
        }
    }
    // const root = await messenger.getMessageStateRoot(sendHash);
    // if (!root) {
    //   throw new Error("Data not yet available on hub network");
    // }
    // get the message to get the message nonce
    const [message] = await messenger.getMessagesByTransaction(sendHash);
    console.log("message", message);
    // get the inclusion proof
    const proof = await messenger.getMessageProof(sendHash);
    console.log("L2 message proof:", proof);
    return [message.target, message.sender, message.message, message.messageNonce, proof];
};
exports.default = (0, config_1.task)("process-from-root", "Call `Connector.processFromRoot()` to process message")
    .addParam("tx", "The transaction hash that sent the L2 -> L1 message that should be processed")
    .addParam("spoke", "The chainId for the spoke")
    .addOptionalParam("env", "Environment of contracts")
    .addOptionalParam("networkType", "Type of network of contracts")
    .setAction(async ({ env: _env, tx: sendHash, spoke: _spoke, networkType: _networkType }, { deployments }) => {
    const deployer = ethers_1.Wallet.fromMnemonic(process.env.MNEMONIC);
    const env = (0, utils_2.mustGetEnv)(_env);
    const spoke = +_spoke;
    const networkType = _networkType ?? utils_2.ProtocolNetwork.TESTNET;
    console.log("networkType: ", networkType);
    console.log("env:", env);
    console.log("spoke", spoke);
    console.log("sendHash", sendHash);
    console.log("deployer", deployer.address);
    // get config
    const protocolConfig = (0, utils_2.getMessagingProtocolConfig)(networkType);
    // get the l2 provider
    const l2Provider = (0, utils_2.getProviderFromHardhatConfig)(spoke);
    // get the l1 provider
    const l1Provider = (0, utils_2.getProviderFromHardhatConfig)(protocolConfig.hub);
    // see what prefix this spoke is
    const prefix = protocolConfig.configs[spoke].prefix;
    let args;
    switch (prefix) {
        case "Optimism":
            args = await processFromOptimismRoot(spoke, sendHash, protocolConfig, l2Provider, l1Provider);
            break;
        case "Arbitrum":
            args = await processFromArbitrumRoot(spoke, sendHash, l2Provider, l1Provider, deployer);
            break;
        default:
            throw new Error(`${prefix} is not supported`);
    }
    // try to call process from root on hub connector
    const deploymentName = (0, utils_2.getDeploymentName)((0, utils_2.getConnectorName)(protocolConfig, spoke, protocolConfig.hub), env);
    const deployment = await deployments.get(deploymentName);
    const address = deployment.address;
    console.log(deploymentName, "connector:", address);
    const connector = new ethers_1.Contract(address, deployment.abi, deployer.connect(l1Provider));
    console.log("created connector");
    const tx = await connector.processMessageFromRoot(...args);
    console.log("tx", tx.hash);
    await tx.wait();
    console.log("tx mined");
});
//# sourceMappingURL=processFromRoot.js.map