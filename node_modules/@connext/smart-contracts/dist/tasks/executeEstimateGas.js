"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const nxtp_utils_1 = require("@connext/nxtp-utils");
const ethers_1 = require("ethers");
const config_1 = require("hardhat/config");
const src_1 = require("../src");
const utils_1 = require("../src/utils");
exports.default = (0, config_1.task)("execute-eg", "Prepare a cross-chain tx")
    .addParam("relayerAddress", "Override connext address")
    .addOptionalParam("connextAddress", "Override connext address")
    .addOptionalParam("env", "Environment of contracts")
    .setAction(async ({ connextAddress: _connextAddress, env: _env, relayerAddress }, { deployments, ethers }) => {
    console.log("relayerAddress: ", relayerAddress);
    const env = (0, utils_1.mustGetEnv)(_env);
    console.log("env:", env);
    const connextName = (0, utils_1.getDeploymentName)("Connext", env);
    let connextAddress = _connextAddress ?? process.env.EG_CONNEXT_ADDRESS;
    if (!connextAddress) {
        const connextDeployment = await deployments.get(connextName);
        connextAddress = connextDeployment.address;
    }
    console.log("connextAddress: ", connextAddress);
    const connext = await ethers.getContractAt(connextName, connextAddress);
    const originDomain = process.env.TRANSFER_ORIGIN_DOMAIN;
    const destinationDomain = process.env.TRANSFER_DESTINATION_DOMAIN;
    if (!originDomain || !destinationDomain) {
        throw new Error("Origin and destination domains must be specified as params or from env (TRANSFER_ORIGIN_DOMAIN, TRANSFER_DESTINATION_DOMAIN)");
    }
    const encodedData = process.env.EG_EXECUTE_ENCODED_DATA;
    if (!encodedData) {
        console.log("Encoded data was not provided. Encoding data manually...");
        const callParams = {
            to: "TRANSFER_TO",
            callData: "TRANSFER_CALL_DATA",
        };
        for (const [key, envKey] of Object.entries(callParams)) {
            const value = process.env[envKey];
            if (value === undefined) {
                throw new Error(`${key} must be specified from env as ${envKey}`);
            }
            callParams[key] = value;
        }
        callParams.originDomain = originDomain;
        callParams.destinationDomain = destinationDomain;
        // Get the transacting asset ID.
        let assetId = process.env.TRANSFER_ASSET;
        if (!assetId) {
            // Alternatively, try defaulting to using the canonical token from the .env (if present) as the transacting asset ID,
            // deriving the local asset using the token registry if applicable.
            const canonicalDomain = process.env.CANONICAL_DOMAIN;
            const canonicalAsset = process.env.CANONICAL_TOKEN;
            if (!canonicalAsset || !canonicalDomain) {
                throw new Error("No canonical domain or token in env");
            }
            const canonicalTokenId = ethers_1.utils.hexlify((0, src_1.canonizeId)(canonicalAsset));
            // Retrieve the local asset from the token registry, if applicable.
            if (canonicalDomain === originDomain) {
                // Use the canonical asset as the local asset since we're on the canonical network.
                assetId = canonicalAsset;
            }
            else {
                // Current network's domain is not canonical domain, so we need to get the local asset representation.
                assetId = await connext.canonicalToRepresentation(canonicalDomain, canonicalTokenId);
                if (assetId === ethers_1.constants.AddressZero) {
                    throw new Error("Empty assetId on registry");
                }
            }
        }
        if (!assetId) {
            // If the above attempt fails, then we default to telling the user to just specify the transacting asset ID.
            throw new Error("Transfer asset ID must be specified as param or from env (TRANSFER_ASSET)");
        }
        const executeArgs = {
            routers: "EXECUTE_ROUTER",
            amount: "TRANSFER_AMOUNT",
            nonce: "EXECUTE_NONCE",
            originSender: "EXECUTE_ORIGIN_SENDER",
        };
        for (const [key, envKey] of Object.entries(executeArgs)) {
            const value = process.env[envKey];
            if (value === undefined) {
                throw new Error(`${key} must be specified from env as ${envKey}`);
            }
            executeArgs[key] = value;
        }
        executeArgs.params = callParams;
        const feePercentage = "1";
        executeArgs.feePercentage = feePercentage;
        executeArgs.local = assetId;
        executeArgs.routers = [executeArgs.routers];
        let transferId = process.env.EXECUTE_TRANSFER_ID;
        if (!transferId) {
            console.log("Getting transfer ID...", executeArgs.nonce, executeArgs.originSender, callParams);
            transferId = await connext.functions.getTransferId(executeArgs.nonce, executeArgs.originSender, callParams);
        }
        console.log("transferId: ", transferId);
        console.log("Getting relayer signature...");
        const router_mnemonic = process.env.EXECUTE_ROUTER_MNEMONIC;
        if (!router_mnemonic) {
            throw new Error("Router mnemonic must be specified in env (EXECUTE_ROUTER_MNEMONIC)");
        }
        const wallet = ethers_1.Wallet.fromMnemonic(router_mnemonic);
        const relayerSignature = await (0, nxtp_utils_1.signRouterPathPayload)(transferId, "1", wallet);
        executeArgs.relayerSignature = relayerSignature;
        console.log("Execute args: ", executeArgs);
        connext.interface.encodeFunctionData("execute", [executeArgs]);
    }
    const chainData = await (0, nxtp_utils_1.getChainData)();
    if (!chainData) {
        throw new Error("Chain data not found!");
    }
    const destinationChainId = chainData.get(destinationDomain).chainId;
    const rpcUrl = chainData.get(destinationDomain)?.rpc ?? process.env.EXECUTE_RPC_URL ?? destinationDomain === "2000"
        ? process.env.RINKEBY_ETH_PROVIDER_URL
        : destinationDomain === "3000"
            ? process.env.KOVAN_ETH_PROVIDER_URL
            : undefined;
    if (!rpcUrl) {
        throw new Error("RPC URL must be specified in env (EXECUTE_RPC_URL)");
    }
    const provider = new ethers_1.providers.JsonRpcProvider(rpcUrl);
    const args = provider.prepareRequest("estimateGas", {
        transaction: {
            chainId: destinationChainId,
            to: connextAddress,
            data: encodedData,
            from: relayerAddress,
        },
    });
    const result = (await provider.send(args[0], args[1]));
    const gasLimit = ethers_1.BigNumber.from(result);
    console.log("Estimation successful! Gas limit: ", gasLimit);
});
//# sourceMappingURL=executeEstimateGas.js.map