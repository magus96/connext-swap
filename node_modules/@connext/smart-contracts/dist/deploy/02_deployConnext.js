"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const types_1 = require("hardhat-deploy/dist/types");
const utils_2 = require("hardhat-deploy/dist/src/utils");
const constants_1 = require("../src/constants");
const utils_3 = require("../src/utils");
const src_1 = require("../src");
const shared_1 = require("../deployConfig/shared");
function sigsFromABI(abi) {
    return abi
        .filter((fragment) => fragment.type === "function")
        .map((fragment) => utils_1.Interface.getSighash(utils_1.FunctionFragment.from(fragment)));
}
const proposeDiamondUpgrade = async (facets, hre, deployer) => {
    // Get existing facets + selectors
    const existingDeployment = (await hre.deployments.getOrNull((0, utils_3.getDeploymentName)("Connext")));
    const contract = new ethers_1.Contract(existingDeployment.address, existingDeployment?.abi, deployer);
    const oldFacets = await contract.facets();
    const oldSelectors = [];
    const oldSelectorsFacetAddress = {};
    for (const oldFacet of oldFacets) {
        for (const selector of oldFacet.functionSelectors) {
            oldSelectors.push(selector);
            oldSelectorsFacetAddress[selector] = oldFacet.facetAddress;
        }
    }
    const diamondArtifact = await hre.deployments.getExtendedArtifact("ConnextDiamond");
    let abi = diamondArtifact.abi.concat([]);
    // Add DiamondLoupeFacet
    facets.push({
        name: "_DefaultDiamondLoupeFacet",
        contract: "DiamondLoupeFacet",
        args: [],
        deterministic: true,
    });
    let changesDetected = false;
    // Deploy new facets + retrieve selectors
    const newSelectors = [];
    const facetSnapshot = [];
    for (const facet of facets) {
        // NOTE: copied from: https://github.com/wighawag/hardhat-deploy/blob/3d08a33a6ae9404bf56187c4f49ec359427672eb/src/helpers.ts#L1792-L2443
        // NOTE: update if linkedData / libraries / facetArgs are included in deploy script
        // Deploy new facet if needed
        const implementation = await hre.deployments.deploy(facet.name, {
            contract: facet.contract,
            args: facet.args,
            from: deployer.address,
            log: true,
            deterministicDeployment: true,
        });
        // Update selectors and snapshot
        const functionSelectors = sigsFromABI(implementation.abi);
        facetSnapshot.push({
            facetAddress: implementation.address,
            functionSelectors,
        });
        newSelectors.push(...functionSelectors);
        abi = (0, utils_2.mergeABIs)([abi, implementation.abi], {
            check: true,
            skipSupportsInterface: false,
        });
    }
    // Find selectors to add and selectors to replace
    const facetCuts = [];
    for (const newFacet of facetSnapshot) {
        const selectorsToAdd = [];
        const selectorsToReplace = [];
        for (const selector of newFacet.functionSelectors) {
            if (oldSelectors.indexOf(selector) >= 0) {
                if (oldSelectorsFacetAddress[selector].toLowerCase() !== newFacet.facetAddress.toLowerCase()) {
                    selectorsToReplace.push(selector);
                }
            }
            else {
                selectorsToAdd.push(selector);
            }
        }
        if (selectorsToReplace.length > 0) {
            changesDetected = true;
            facetCuts.push({
                facetAddress: newFacet.facetAddress,
                functionSelectors: selectorsToReplace,
                action: types_1.FacetCutAction.Replace,
            });
        }
        if (selectorsToAdd.length > 0) {
            changesDetected = true;
            facetCuts.push({
                facetAddress: newFacet.facetAddress,
                functionSelectors: selectorsToAdd,
                action: types_1.FacetCutAction.Add,
            });
        }
        console.log("trying to add:", selectorsToAdd);
        console.log("trying to replace:", selectorsToReplace);
    }
    // Get facet selectors to delete
    const selectorsToDelete = [];
    for (const selector of oldSelectors) {
        if (newSelectors.indexOf(selector) === -1) {
            selectorsToDelete.push(selector);
        }
    }
    console.log("trying to remove:", selectorsToDelete);
    if (selectorsToDelete.length > 0) {
        changesDetected = true;
        facetCuts.unshift({
            facetAddress: "0x0000000000000000000000000000000000000000",
            functionSelectors: selectorsToDelete,
            action: types_1.FacetCutAction.Remove,
        });
    }
    // If no changes detected, do nothing
    if (!changesDetected || facetCuts.length === 0) {
        console.log(`no diamond upgrade proposal needed`);
        return { cuts: facetCuts, tx: undefined, abi: undefined };
    }
    // Make sure this isnt a duplicate proposal (i.e. you aren't just resetting times)
    const acceptanceTime = await contract.getAcceptanceTime(facetCuts, ethers_1.constants.AddressZero, "0x");
    if (!acceptanceTime.isZero()) {
        console.log(`cut has already been proposed:`, facetCuts);
        return { cuts: facetCuts, tx: undefined, abi: undefined };
    }
    console.log("calling propose with", facetCuts);
    // Propose facet cut
    return { cuts: facetCuts, tx: await contract.proposeDiamondCut(facetCuts, ethers_1.constants.AddressZero, "0x"), abi: abi };
};
/**
 * Hardhat task defining the contract deployments for Connext
 *
 * @param hre Hardhat environment to deploy to
 */
const func = async (hre) => {
    const chainId = await hre.getChainId();
    const acceptanceDelay = constants_1.SKIP_SETUP.includes(parseInt(chainId)) ? 604800 : 0; // 604800 = 7 days
    let _deployer;
    ({ deployer: _deployer } = await hre.ethers.getNamedSigners());
    if (!_deployer) {
        [_deployer] = await hre.ethers.getUnnamedSigners();
    }
    const deployer = _deployer;
    console.log("\n============================= Deploying Connext Contracts ===============================");
    console.log("deployer: ", deployer.address);
    console.log("acceptance delay: ", acceptanceDelay);
    const network = await hre.ethers.provider.getNetwork();
    console.log("network: ", network);
    const domain = (0, src_1.chainIdToDomain)(network.chainId);
    console.log("domain: ", domain);
    const price = await hre.ethers.provider.getGasPrice();
    console.log("price: ", price.toString());
    const balance = await hre.ethers.provider.getBalance(deployer.address);
    console.log("balance: ", balance.toString());
    // Get connector manager
    const messagingNetwork = (0, utils_3.getProtocolNetwork)(chainId);
    const protocol = shared_1.MESSAGING_PROTOCOL_CONFIGS[messagingNetwork];
    if (!protocol.configs[protocol.hub]) {
        throw new Error(`Network ${messagingNetwork} is not supported! (no messaging config)`);
    }
    const connectorName = (0, utils_3.getConnectorName)(protocol, +chainId);
    const connectorManagerDeployment = await hre.deployments.getOrNull((0, utils_3.getDeploymentName)(connectorName, undefined, protocol.configs[Number(chainId)].networkName));
    if (!connectorManagerDeployment) {
        throw new Error(`${connectorName} not deployed`);
    }
    const lpTokenDeployment = await hre.deployments.deploy("LPToken", {
        from: deployer.address,
        log: true,
        skipIfAlreadyDeployed: true,
    });
    if (lpTokenDeployment.newlyDeployed) {
        await hre.deployments.execute("LPToken", { from: deployer.address, log: true }, "initialize", "Connext Stable LP Token", "ConnextStableLPToken");
    }
    // Deploy connext diamond contract
    console.log("Deploying connext diamond...");
    const isDiamondUpgrade = !!(await hre.deployments.getOrNull((0, utils_3.getDeploymentName)("Connext")));
    const facets = [
        { name: (0, utils_3.getDeploymentName)("TokenFacet"), contract: "TokenFacet", args: [] },
        { name: (0, utils_3.getDeploymentName)("BridgeFacet"), contract: "BridgeFacet", args: [] },
        { name: (0, utils_3.getDeploymentName)("InboxFacet"), contract: "InboxFacet", args: [] },
        { name: (0, utils_3.getDeploymentName)("ProposedOwnableFacet"), contract: "ProposedOwnableFacet", args: [] },
        { name: (0, utils_3.getDeploymentName)("PortalFacet"), contract: "PortalFacet", args: [] },
        { name: (0, utils_3.getDeploymentName)("RelayerFacet"), contract: "RelayerFacet", args: [] },
        { name: (0, utils_3.getDeploymentName)("RoutersFacet"), contract: "RoutersFacet", args: [] },
        { name: (0, utils_3.getDeploymentName)("StableSwapFacet"), contract: "StableSwapFacet", args: [] },
        { name: (0, utils_3.getDeploymentName)("SwapAdminFacet"), contract: "SwapAdminFacet", args: [] },
        { name: (0, utils_3.getDeploymentName)("DiamondCutFacet"), contract: "DiamondCutFacet", args: [] },
        { name: (0, utils_3.getDeploymentName)("DiamondInit"), contract: "DiamondInit", args: [] },
    ];
    let connext;
    if (isDiamondUpgrade) {
        console.log("proposing upgrade...");
        connext = (await hre.deployments.getOrNull((0, utils_3.getDeploymentName)("Connext")));
        const { cuts, tx: proposalTx, abi } = await proposeDiamondUpgrade(facets, hre, deployer);
        if (!proposalTx || !cuts.length) {
            console.log(`No upgrade needed, using previous deployment`);
        }
        else {
            console.log(`Proposal tx:`, proposalTx.hash);
            const receipt = await proposalTx.wait();
            console.log(`Upgrade to diamond proposed`, receipt.transactionHash);
        }
        // Fallthrough after proposal, will either work or fail depending on delay
        try {
            if (cuts.length) {
                const contract = new ethers_1.Contract(connext.address, connext.abi, deployer);
                const acceptanceTime = (await contract.getAcceptanceTime(cuts, ethers_1.constants.AddressZero, "0x")).toNumber();
                const currentTimeStamp = Math.floor(Date.now() / 1000);
                if (acceptanceTime > currentTimeStamp) {
                    console.log(`delay not elapsed. still wait for ${acceptanceTime - currentTimeStamp} sec`);
                }
                else {
                    const upgradeTx = await contract.diamondCut(cuts, ethers_1.constants.AddressZero, "0x");
                    console.log("upgrade transaction", upgradeTx.hash);
                    const receipt = await upgradeTx.wait();
                    console.log("upgrade receipt", receipt);
                    // Save updated abi to Connext Deployment
                    const diamondDeployment = {
                        ...connext,
                        abi: abi ?? connext.abi,
                    };
                    await hre.deployments.save((0, utils_3.getDeploymentName)("Connext"), diamondDeployment);
                    console.log("upgraded abi");
                }
            }
        }
        catch (e) {
            console.log(`upgrade failed`, e);
        }
    }
    else {
        connext = await hre.deployments.diamond.deploy((0, utils_3.getDeploymentName)("Connext"), {
            from: deployer.address,
            owner: deployer.address,
            log: true,
            facets,
            diamondContract: "ConnextDiamond",
            defaultOwnershipFacet: false,
            defaultCutFacet: false,
            execute: isDiamondUpgrade
                ? undefined
                : {
                    contract: "DiamondInit",
                    methodName: "init",
                    args: [domain, connectorManagerDeployment.address, acceptanceDelay, lpTokenDeployment.address],
                },
        });
    }
    const connextAddress = connext.address;
    console.log("connextAddress: ", connextAddress);
    console.log("Deploying Relayer Proxy...");
    const { feeCollector, gelatoRelayer } = (0, utils_3.getRelayerProxyConfig)(chainId);
    const spokeConnector = await hre.ethers.getContract((0, utils_3.getDeploymentName)((0, utils_3.getConnectorName)(protocol, +chainId), undefined, protocol.configs[Number(chainId)].networkName));
    if (protocol.hub === network.chainId) {
        const rootManager = await hre.ethers.getContract((0, utils_3.getDeploymentName)("RootManager"));
        const relayerProxyHub = await hre.deployments.deploy((0, utils_3.getDeploymentName)("RelayerProxyHub"), {
            from: deployer.address,
            log: true,
            contract: "RelayerProxyHub",
            args: [connextAddress, spokeConnector.address, gelatoRelayer, feeCollector, rootManager.address],
        });
        console.log("relayerProxyHub: ", relayerProxyHub.address);
    }
    else {
        const relayerProxy = await hre.deployments.deploy((0, utils_3.getDeploymentName)("RelayerProxy"), {
            from: deployer.address,
            log: true,
            contract: "RelayerProxy",
            args: [connextAddress, spokeConnector.address, gelatoRelayer, feeCollector],
        });
        console.log("relayerProxy: ", relayerProxy.address);
    }
    if (!constants_1.SKIP_SETUP.includes(parseInt(chainId))) {
        console.log("Deploying test token on non-mainnet chain...");
        // Note: NOT using special token for staging envs
        let deployment = await hre.deployments.deploy("TestERC20", {
            from: deployer.address,
            log: true,
            skipIfAlreadyDeployed: true,
            args: ["Test Token", "TEST"],
        });
        console.log("TestERC20: ", deployment.address);
        deployment = await hre.deployments.deploy("TestAdopted", {
            contract: "TestERC20",
            from: deployer.address,
            log: true,
            skipIfAlreadyDeployed: true,
            args: ["Test Adopted", "TEST2"],
        });
        deployment = await hre.deployments.deploy("TestWETH", {
            contract: "TestERC20",
            from: deployer.address,
            log: true,
            skipIfAlreadyDeployed: true,
            args: ["Test Wrapped Ether", "TWETH"],
        });
        console.log("TestERC20: ", deployment.address);
    }
    else {
        console.log("Skipping test setup on chainId: ", chainId);
    }
};
exports.default = func;
func.tags = ["Connext", "prod", "local", "mainnet"];
func.dependencies = ["Messaging"];
//# sourceMappingURL=02_deployConnext.js.map