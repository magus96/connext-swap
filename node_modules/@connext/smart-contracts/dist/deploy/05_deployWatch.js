"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const constants_1 = require("../src/constants");
const src_1 = require("../src");
/**
 * Hardhat task defining the contract deployments for Connext
 *
 * @param hre Hardhat environment to deploy to
 */
const func = async (hre) => {
    console.log("\n============================= Deploying Watcher Token ===============================");
    const chainId = +(await hre.getChainId());
    let _deployer;
    ({ deployer: _deployer } = await hre.ethers.getNamedSigners());
    if (!_deployer) {
        [_deployer] = await hre.ethers.getUnnamedSigners();
    }
    const deployer = _deployer;
    console.log("deployer: ", deployer.address);
    if (constants_1.SKIP_SETUP.includes(chainId)) {
        throw new Error(`Should be skipped on mainnet chain`);
    }
    console.log("Deploying watch token on non-mainnet chain...");
    const DEPLOYMENT_NAME = "BigBroERC20";
    const deployment = await hre.deployments.deploy(DEPLOYMENT_NAME, {
        contract: "TestERC20",
        from: deployer.address,
        log: true,
        skipIfAlreadyDeployed: true,
        args: ["Watcher Token", "BigBro"],
    });
    console.log("BIGBRO: ", deployment.address);
    // Only perform cleanup on fresh deploy
    if (!deployment.newlyDeployed) {
        return;
    }
    // Burn tokens minted to deployer on constructor
    const contract = new ethers_1.Contract(deployment.address, deployment.abi, deployer);
    const balance = await contract.balanceOf(deployer.address);
    if (balance.gt(0)) {
        console.log("burning tokens minted to deployer");
        const tx = await contract.burn(deployer.address, balance);
        console.log("awaiting burn tx...", tx.hash);
        const receipt = await tx.wait();
        console.log("owner funds burnt:", receipt.transactionHash);
    }
    // Try to whitelist immediately after deployment
    const canonical = chainId === 5
        ? deployment.address
        : (await hre.companionNetworks["hub"].deployments.getOrNull(DEPLOYMENT_NAME))?.address;
    if (!canonical) {
        throw new Error(`Failed to find canonical address for token`);
    }
    const taskArgs = {
        canonical,
        domain: (0, src_1.chainIdToDomain)(5).toString(),
        decimals: "18",
        representationName: "nextBigBroERC20",
        representationSymbol: "nextBigBro",
        withDeployedRepresentation: chainId === 5 ? "false" : "true",
        local: chainId === 5 ? undefined : deployment.address,
        cap: ethers_1.utils.parseEther("1000").toString(),
    };
    console.log("setting up asset with", taskArgs);
    await hre.run("setup-asset", taskArgs);
};
exports.default = func;
func.tags = ["WatcherTest", "prod"];
func.skip = async (hre) => {
    const chainId = +(await hre.getChainId());
    return constants_1.SKIP_SETUP.includes(chainId);
};
//# sourceMappingURL=05_deployWatch.js.map