"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = require("../src/cli/helpers");
const constants_1 = require("../src/constants");
// Helper for deploying a utility contract below and handling proper logs, etc.
const deployContract = async (params) => {
    const { hre, deployer, contractName, args } = params;
    const deployment = await hre.deployments.getOrNull(contractName);
    if (!deployment) {
        console.log(`Deploying ${contractName} contract...`);
        const deployResult = await hre.deployments.deploy(contractName, {
            from: deployer.address,
            log: true,
            skipIfAlreadyDeployed: true,
            contract: contractName,
            args: args,
        });
        console.log(`Deployed ${contractName} contract to: ${deployResult.address}`);
        return deployResult;
    }
    else {
        console.log(`${contractName} contract already deployed at: ${deployment.address}`);
        return;
    }
};
/**
 * Hardhat task defining the contract deployments for Connext
 *
 * @param hre Hardhat environment to deploy to
 */
const func = async (hre) => {
    console.log("\n============================= Deploying Utility Contracts ===============================");
    const chainId = +(await hre.getChainId());
    let _deployer;
    ({ deployer: _deployer } = await hre.ethers.getNamedSigners());
    if (!_deployer) {
        [_deployer] = await hre.ethers.getUnnamedSigners();
    }
    const deployer = _deployer;
    console.log("deployer: ", deployer.address);
    if (constants_1.SKIP_SETUP.includes(chainId)) {
        throw new Error(`Should have skipped setup for this chain (${chainId})`);
    }
    const network = await hre.ethers.provider.getNetwork();
    console.log("network: ", network);
    const chain = network.chainId;
    /// MARK - MultiSend
    // NOTE: MultiSend will be shared between staging and production environments; we do not
    // deploy 1 for each.
    // Multisend utility contract is used by the SDK to conveniently wrap ETH => WETH before
    // making xcalls transferring WETH tokens.
    await deployContract({ hre, deployer, contractName: "MultiSend", args: [] });
    /// MARK - Unwrapper
    // NOTE: Unwrapper can be shared between staging and production environments; we do not
    // deploy 1 for each.
    // Unwrapper utility contract is used by the SDK to conveniently unwrap WETH => ETH on the
    // transfer's destination chain after an xcall transferring WETH tokens.
    const connext = (0, helpers_1.getContract)("Connext_DiamondProxy", chain.toString(), false);
    const wrappedETH = constants_1.WRAPPED_ETH_MAP.get(chain);
    if (!wrappedETH) {
        throw new Error(`Wrapped ETH contract not defined in WRAPPED_ETH_MAP for this domain!`);
    }
    await deployContract({
        hre,
        deployer,
        contractName: "Unwrapper",
        args: [connext.address, wrappedETH],
    });
};
exports.default = func;
func.tags = ["Utils", "prod"];
func.skip = async (hre) => {
    const chainId = +(await hre.getChainId());
    return constants_1.SKIP_SETUP.includes(chainId);
};
//# sourceMappingURL=04_deployUtils.js.map