import type { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, PayableOverrides, PopulatedTransaction, Signer, utils } from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from "../../../../../../common";
export type L2LogStruct = {
    l2ShardId: PromiseOrValue<BigNumberish>;
    isService: PromiseOrValue<boolean>;
    txNumberInBlock: PromiseOrValue<BigNumberish>;
    sender: PromiseOrValue<string>;
    key: PromiseOrValue<BytesLike>;
    value: PromiseOrValue<BytesLike>;
};
export type L2LogStructOutput = [
    number,
    boolean,
    number,
    string,
    string,
    string
] & {
    l2ShardId: number;
    isService: boolean;
    txNumberInBlock: number;
    sender: string;
    key: string;
    value: string;
};
export type L2MessageStruct = {
    txNumberInBlock: PromiseOrValue<BigNumberish>;
    sender: PromiseOrValue<string>;
    data: PromiseOrValue<BytesLike>;
};
export type L2MessageStructOutput = [number, string, string] & {
    txNumberInBlock: number;
    sender: string;
    data: string;
};
export declare namespace IMailbox {
    type L2CanonicalTransactionStruct = {
        txType: PromiseOrValue<BigNumberish>;
        from: PromiseOrValue<BigNumberish>;
        to: PromiseOrValue<BigNumberish>;
        ergsLimit: PromiseOrValue<BigNumberish>;
        ergsPerPubdataByteLimit: PromiseOrValue<BigNumberish>;
        maxFeePerErg: PromiseOrValue<BigNumberish>;
        maxPriorityFeePerErg: PromiseOrValue<BigNumberish>;
        paymaster: PromiseOrValue<BigNumberish>;
        reserved: PromiseOrValue<BigNumberish>[];
        data: PromiseOrValue<BytesLike>;
        signature: PromiseOrValue<BytesLike>;
        factoryDeps: PromiseOrValue<BigNumberish>[];
        paymasterInput: PromiseOrValue<BytesLike>;
        reservedDynamic: PromiseOrValue<BytesLike>;
    };
    type L2CanonicalTransactionStructOutput = [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber[],
        string,
        string,
        BigNumber[],
        string,
        string
    ] & {
        txType: BigNumber;
        from: BigNumber;
        to: BigNumber;
        ergsLimit: BigNumber;
        ergsPerPubdataByteLimit: BigNumber;
        maxFeePerErg: BigNumber;
        maxPriorityFeePerErg: BigNumber;
        paymaster: BigNumber;
        reserved: BigNumber[];
        data: string;
        signature: string;
        factoryDeps: BigNumber[];
        paymasterInput: string;
        reservedDynamic: string;
    };
}
export interface IMailboxInterface extends utils.Interface {
    functions: {
        "l2TransactionBaseCost(uint256,uint256,uint32)": FunctionFragment;
        "proveL2LogInclusion(uint256,uint256,(uint8,bool,uint16,address,bytes32,bytes32),bytes32[])": FunctionFragment;
        "proveL2MessageInclusion(uint256,uint256,(uint16,address,bytes),bytes32[])": FunctionFragment;
        "requestL2Transaction(address,uint256,bytes,uint256,bytes[])": FunctionFragment;
        "serializeL2Transaction(uint256,uint256,address,address,bytes,uint256,bytes[])": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "l2TransactionBaseCost" | "proveL2LogInclusion" | "proveL2MessageInclusion" | "requestL2Transaction" | "serializeL2Transaction"): FunctionFragment;
    encodeFunctionData(functionFragment: "l2TransactionBaseCost", values: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "proveL2LogInclusion", values: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        L2LogStruct,
        PromiseOrValue<BytesLike>[]
    ]): string;
    encodeFunctionData(functionFragment: "proveL2MessageInclusion", values: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        L2MessageStruct,
        PromiseOrValue<BytesLike>[]
    ]): string;
    encodeFunctionData(functionFragment: "requestL2Transaction", values: [
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BytesLike>[]
    ]): string;
    encodeFunctionData(functionFragment: "serializeL2Transaction", values: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BytesLike>[]
    ]): string;
    decodeFunctionResult(functionFragment: "l2TransactionBaseCost", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "proveL2LogInclusion", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "proveL2MessageInclusion", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "requestL2Transaction", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "serializeL2Transaction", data: BytesLike): Result;
    events: {
        "NewPriorityRequest(uint256,bytes32,uint64,tuple,bytes[])": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "NewPriorityRequest"): EventFragment;
}
export interface NewPriorityRequestEventObject {
    txId: BigNumber;
    txHash: string;
    expirationBlock: BigNumber;
    transaction: IMailbox.L2CanonicalTransactionStructOutput;
    factoryDeps: string[];
}
export type NewPriorityRequestEvent = TypedEvent<[
    BigNumber,
    string,
    BigNumber,
    IMailbox.L2CanonicalTransactionStructOutput,
    string[]
], NewPriorityRequestEventObject>;
export type NewPriorityRequestEventFilter = TypedEventFilter<NewPriorityRequestEvent>;
export interface IMailbox extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: IMailboxInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        l2TransactionBaseCost(_gasPrice: PromiseOrValue<BigNumberish>, _ergsLimit: PromiseOrValue<BigNumberish>, _calldataLength: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;
        proveL2LogInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _log: L2LogStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<[boolean]>;
        proveL2MessageInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _message: L2MessageStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<[boolean]>;
        requestL2Transaction(_contractAddressL2: PromiseOrValue<string>, _l2Value: PromiseOrValue<BigNumberish>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        serializeL2Transaction(_txId: PromiseOrValue<BigNumberish>, _l2Value: PromiseOrValue<BigNumberish>, _sender: PromiseOrValue<string>, _contractAddressL2: PromiseOrValue<string>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<[IMailbox.L2CanonicalTransactionStructOutput]>;
    };
    l2TransactionBaseCost(_gasPrice: PromiseOrValue<BigNumberish>, _ergsLimit: PromiseOrValue<BigNumberish>, _calldataLength: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
    proveL2LogInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _log: L2LogStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<boolean>;
    proveL2MessageInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _message: L2MessageStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<boolean>;
    requestL2Transaction(_contractAddressL2: PromiseOrValue<string>, _l2Value: PromiseOrValue<BigNumberish>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    serializeL2Transaction(_txId: PromiseOrValue<BigNumberish>, _l2Value: PromiseOrValue<BigNumberish>, _sender: PromiseOrValue<string>, _contractAddressL2: PromiseOrValue<string>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<IMailbox.L2CanonicalTransactionStructOutput>;
    callStatic: {
        l2TransactionBaseCost(_gasPrice: PromiseOrValue<BigNumberish>, _ergsLimit: PromiseOrValue<BigNumberish>, _calldataLength: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        proveL2LogInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _log: L2LogStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<boolean>;
        proveL2MessageInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _message: L2MessageStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<boolean>;
        requestL2Transaction(_contractAddressL2: PromiseOrValue<string>, _l2Value: PromiseOrValue<BigNumberish>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<string>;
        serializeL2Transaction(_txId: PromiseOrValue<BigNumberish>, _l2Value: PromiseOrValue<BigNumberish>, _sender: PromiseOrValue<string>, _contractAddressL2: PromiseOrValue<string>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<IMailbox.L2CanonicalTransactionStructOutput>;
    };
    filters: {
        "NewPriorityRequest(uint256,bytes32,uint64,tuple,bytes[])"(txId?: null, txHash?: null, expirationBlock?: null, transaction?: null, factoryDeps?: null): NewPriorityRequestEventFilter;
        NewPriorityRequest(txId?: null, txHash?: null, expirationBlock?: null, transaction?: null, factoryDeps?: null): NewPriorityRequestEventFilter;
    };
    estimateGas: {
        l2TransactionBaseCost(_gasPrice: PromiseOrValue<BigNumberish>, _ergsLimit: PromiseOrValue<BigNumberish>, _calldataLength: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        proveL2LogInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _log: L2LogStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<BigNumber>;
        proveL2MessageInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _message: L2MessageStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<BigNumber>;
        requestL2Transaction(_contractAddressL2: PromiseOrValue<string>, _l2Value: PromiseOrValue<BigNumberish>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        serializeL2Transaction(_txId: PromiseOrValue<BigNumberish>, _l2Value: PromiseOrValue<BigNumberish>, _sender: PromiseOrValue<string>, _contractAddressL2: PromiseOrValue<string>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<BigNumber>;
    };
    populateTransaction: {
        l2TransactionBaseCost(_gasPrice: PromiseOrValue<BigNumberish>, _ergsLimit: PromiseOrValue<BigNumberish>, _calldataLength: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        proveL2LogInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _log: L2LogStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        proveL2MessageInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _message: L2MessageStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        requestL2Transaction(_contractAddressL2: PromiseOrValue<string>, _l2Value: PromiseOrValue<BigNumberish>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        serializeL2Transaction(_txId: PromiseOrValue<BigNumberish>, _l2Value: PromiseOrValue<BigNumberish>, _sender: PromiseOrValue<string>, _contractAddressL2: PromiseOrValue<string>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}
//# sourceMappingURL=IMailbox.d.ts.map