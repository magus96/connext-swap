import type { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PayableOverrides, PopulatedTransaction, Signer, utils } from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from "../../../../../../common";
export type L2LogStruct = {
    l2ShardId: PromiseOrValue<BigNumberish>;
    isService: PromiseOrValue<boolean>;
    txNumberInBlock: PromiseOrValue<BigNumberish>;
    sender: PromiseOrValue<string>;
    key: PromiseOrValue<BytesLike>;
    value: PromiseOrValue<BytesLike>;
};
export type L2LogStructOutput = [
    number,
    boolean,
    number,
    string,
    string,
    string
] & {
    l2ShardId: number;
    isService: boolean;
    txNumberInBlock: number;
    sender: string;
    key: string;
    value: string;
};
export type L2MessageStruct = {
    txNumberInBlock: PromiseOrValue<BigNumberish>;
    sender: PromiseOrValue<string>;
    data: PromiseOrValue<BytesLike>;
};
export type L2MessageStructOutput = [number, string, string] & {
    txNumberInBlock: number;
    sender: string;
    data: string;
};
export declare namespace Diamond {
    type FacetCutStruct = {
        facet: PromiseOrValue<string>;
        action: PromiseOrValue<BigNumberish>;
        isFreezable: PromiseOrValue<boolean>;
        selectors: PromiseOrValue<BytesLike>[];
    };
    type FacetCutStructOutput = [string, number, boolean, string[]] & {
        facet: string;
        action: number;
        isFreezable: boolean;
        selectors: string[];
    };
    type DiamondCutDataStruct = {
        facetCuts: Diamond.FacetCutStruct[];
        initAddress: PromiseOrValue<string>;
        initCalldata: PromiseOrValue<BytesLike>;
    };
    type DiamondCutDataStructOutput = [
        Diamond.FacetCutStructOutput[],
        string,
        string
    ] & {
        facetCuts: Diamond.FacetCutStructOutput[];
        initAddress: string;
        initCalldata: string;
    };
}
export declare namespace IMailbox {
    type L2CanonicalTransactionStruct = {
        txType: PromiseOrValue<BigNumberish>;
        from: PromiseOrValue<BigNumberish>;
        to: PromiseOrValue<BigNumberish>;
        ergsLimit: PromiseOrValue<BigNumberish>;
        ergsPerPubdataByteLimit: PromiseOrValue<BigNumberish>;
        maxFeePerErg: PromiseOrValue<BigNumberish>;
        maxPriorityFeePerErg: PromiseOrValue<BigNumberish>;
        paymaster: PromiseOrValue<BigNumberish>;
        reserved: PromiseOrValue<BigNumberish>[];
        data: PromiseOrValue<BytesLike>;
        signature: PromiseOrValue<BytesLike>;
        factoryDeps: PromiseOrValue<BigNumberish>[];
        paymasterInput: PromiseOrValue<BytesLike>;
        reservedDynamic: PromiseOrValue<BytesLike>;
    };
    type L2CanonicalTransactionStructOutput = [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber[],
        string,
        string,
        BigNumber[],
        string,
        string
    ] & {
        txType: BigNumber;
        from: BigNumber;
        to: BigNumber;
        ergsLimit: BigNumber;
        ergsPerPubdataByteLimit: BigNumber;
        maxFeePerErg: BigNumber;
        maxPriorityFeePerErg: BigNumber;
        paymaster: BigNumber;
        reserved: BigNumber[];
        data: string;
        signature: string;
        factoryDeps: BigNumber[];
        paymasterInput: string;
        reservedDynamic: string;
    };
}
export declare namespace IExecutor {
    type StoredBlockInfoStruct = {
        blockNumber: PromiseOrValue<BigNumberish>;
        blockHash: PromiseOrValue<BytesLike>;
        indexRepeatedStorageChanges: PromiseOrValue<BigNumberish>;
        numberOfLayer1Txs: PromiseOrValue<BigNumberish>;
        priorityOperationsHash: PromiseOrValue<BytesLike>;
        l2LogsTreeRoot: PromiseOrValue<BytesLike>;
        timestamp: PromiseOrValue<BigNumberish>;
        commitment: PromiseOrValue<BytesLike>;
    };
    type StoredBlockInfoStructOutput = [
        BigNumber,
        string,
        BigNumber,
        BigNumber,
        string,
        string,
        BigNumber,
        string
    ] & {
        blockNumber: BigNumber;
        blockHash: string;
        indexRepeatedStorageChanges: BigNumber;
        numberOfLayer1Txs: BigNumber;
        priorityOperationsHash: string;
        l2LogsTreeRoot: string;
        timestamp: BigNumber;
        commitment: string;
    };
    type CommitBlockInfoStruct = {
        blockNumber: PromiseOrValue<BigNumberish>;
        timestamp: PromiseOrValue<BigNumberish>;
        indexRepeatedStorageChanges: PromiseOrValue<BigNumberish>;
        newStateRoot: PromiseOrValue<BytesLike>;
        ergsPerCodeDecommittmentWord: PromiseOrValue<BigNumberish>;
        numberOfLayer1Txs: PromiseOrValue<BigNumberish>;
        l2LogsTreeRoot: PromiseOrValue<BytesLike>;
        priorityOperationsHash: PromiseOrValue<BytesLike>;
        initialStorageChanges: PromiseOrValue<BytesLike>;
        repeatedStorageChanges: PromiseOrValue<BytesLike>;
        l2Logs: PromiseOrValue<BytesLike>;
        l2ArbitraryLengthMessages: PromiseOrValue<BytesLike>[];
        factoryDeps: PromiseOrValue<BytesLike>[];
    };
    type CommitBlockInfoStructOutput = [
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        number,
        BigNumber,
        string,
        string,
        string,
        string,
        string,
        string[],
        string[]
    ] & {
        blockNumber: BigNumber;
        timestamp: BigNumber;
        indexRepeatedStorageChanges: BigNumber;
        newStateRoot: string;
        ergsPerCodeDecommittmentWord: number;
        numberOfLayer1Txs: BigNumber;
        l2LogsTreeRoot: string;
        priorityOperationsHash: string;
        initialStorageChanges: string;
        repeatedStorageChanges: string;
        l2Logs: string;
        l2ArbitraryLengthMessages: string[];
        factoryDeps: string[];
    };
    type ProofInputStruct = {
        recurisiveAggregationInput: PromiseOrValue<BigNumberish>[];
        serializedProof: PromiseOrValue<BigNumberish>[];
    };
    type ProofInputStructOutput = [BigNumber[], BigNumber[]] & {
        recurisiveAggregationInput: BigNumber[];
        serializedProof: BigNumber[];
    };
}
export declare namespace IGetters {
    type FacetStruct = {
        addr: PromiseOrValue<string>;
        selectors: PromiseOrValue<BytesLike>[];
    };
    type FacetStructOutput = [string, string[]] & {
        addr: string;
        selectors: string[];
    };
}
export interface IZkSyncInterface extends utils.Interface {
    functions: {
        "acceptGovernor()": FunctionFragment;
        "approveEmergencyDiamondCutAsSecurityCouncilMember(bytes32)": FunctionFragment;
        "cancelDiamondCutProposal()": FunctionFragment;
        "commitBlocks((uint64,bytes32,uint64,uint256,bytes32,bytes32,uint256,bytes32),(uint64,uint64,uint64,bytes32,uint16,uint256,bytes32,bytes32,bytes,bytes,bytes,bytes[],bytes[])[])": FunctionFragment;
        "emergencyFreezeDiamond()": FunctionFragment;
        "executeBlocks((uint64,bytes32,uint64,uint256,bytes32,bytes32,uint256,bytes32)[])": FunctionFragment;
        "executeDiamondCutProposal(((address,uint8,bool,bytes4[])[],address,bytes))": FunctionFragment;
        "facetAddress(bytes4)": FunctionFragment;
        "facetAddresses()": FunctionFragment;
        "facetFunctionSelectors(address)": FunctionFragment;
        "facets()": FunctionFragment;
        "getFirstUnprocessedPriorityTx()": FunctionFragment;
        "getGovernor()": FunctionFragment;
        "getTotalBlocksCommitted()": FunctionFragment;
        "getTotalBlocksExecuted()": FunctionFragment;
        "getTotalBlocksVerified()": FunctionFragment;
        "getTotalPriorityTxs()": FunctionFragment;
        "getVerifier()": FunctionFragment;
        "isFacetFreezable(address)": FunctionFragment;
        "isFunctionFreezable(bytes4)": FunctionFragment;
        "isValidator(address)": FunctionFragment;
        "l2LogsRootHash(uint32)": FunctionFragment;
        "l2TransactionBaseCost(uint256,uint256,uint32)": FunctionFragment;
        "proposeDiamondCut((address,uint8,bool,bytes4[])[],address)": FunctionFragment;
        "proveBlocks((uint64,bytes32,uint64,uint256,bytes32,bytes32,uint256,bytes32),(uint64,bytes32,uint64,uint256,bytes32,bytes32,uint256,bytes32)[],(uint256[],uint256[]))": FunctionFragment;
        "proveL2LogInclusion(uint256,uint256,(uint8,bool,uint16,address,bytes32,bytes32),bytes32[])": FunctionFragment;
        "proveL2MessageInclusion(uint256,uint256,(uint16,address,bytes),bytes32[])": FunctionFragment;
        "requestL2Transaction(address,uint256,bytes,uint256,bytes[])": FunctionFragment;
        "revertBlocks(uint256)": FunctionFragment;
        "serializeL2Transaction(uint256,uint256,address,address,bytes,uint256,bytes[])": FunctionFragment;
        "setL2BootloaderBytecodeHash(bytes32)": FunctionFragment;
        "setL2DefaultAccountBytecodeHash(bytes32)": FunctionFragment;
        "setPendingGovernor(address)": FunctionFragment;
        "setPorterAvailability(bool)": FunctionFragment;
        "setValidator(address,bool)": FunctionFragment;
        "unfreezeDiamond()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "acceptGovernor" | "approveEmergencyDiamondCutAsSecurityCouncilMember" | "cancelDiamondCutProposal" | "commitBlocks" | "emergencyFreezeDiamond" | "executeBlocks" | "executeDiamondCutProposal" | "facetAddress" | "facetAddresses" | "facetFunctionSelectors" | "facets" | "getFirstUnprocessedPriorityTx" | "getGovernor" | "getTotalBlocksCommitted" | "getTotalBlocksExecuted" | "getTotalBlocksVerified" | "getTotalPriorityTxs" | "getVerifier" | "isFacetFreezable" | "isFunctionFreezable" | "isValidator" | "l2LogsRootHash" | "l2TransactionBaseCost" | "proposeDiamondCut" | "proveBlocks" | "proveL2LogInclusion" | "proveL2MessageInclusion" | "requestL2Transaction" | "revertBlocks" | "serializeL2Transaction" | "setL2BootloaderBytecodeHash" | "setL2DefaultAccountBytecodeHash" | "setPendingGovernor" | "setPorterAvailability" | "setValidator" | "unfreezeDiamond"): FunctionFragment;
    encodeFunctionData(functionFragment: "acceptGovernor", values?: undefined): string;
    encodeFunctionData(functionFragment: "approveEmergencyDiamondCutAsSecurityCouncilMember", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "cancelDiamondCutProposal", values?: undefined): string;
    encodeFunctionData(functionFragment: "commitBlocks", values: [IExecutor.StoredBlockInfoStruct, IExecutor.CommitBlockInfoStruct[]]): string;
    encodeFunctionData(functionFragment: "emergencyFreezeDiamond", values?: undefined): string;
    encodeFunctionData(functionFragment: "executeBlocks", values: [IExecutor.StoredBlockInfoStruct[]]): string;
    encodeFunctionData(functionFragment: "executeDiamondCutProposal", values: [Diamond.DiamondCutDataStruct]): string;
    encodeFunctionData(functionFragment: "facetAddress", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "facetAddresses", values?: undefined): string;
    encodeFunctionData(functionFragment: "facetFunctionSelectors", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "facets", values?: undefined): string;
    encodeFunctionData(functionFragment: "getFirstUnprocessedPriorityTx", values?: undefined): string;
    encodeFunctionData(functionFragment: "getGovernor", values?: undefined): string;
    encodeFunctionData(functionFragment: "getTotalBlocksCommitted", values?: undefined): string;
    encodeFunctionData(functionFragment: "getTotalBlocksExecuted", values?: undefined): string;
    encodeFunctionData(functionFragment: "getTotalBlocksVerified", values?: undefined): string;
    encodeFunctionData(functionFragment: "getTotalPriorityTxs", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVerifier", values?: undefined): string;
    encodeFunctionData(functionFragment: "isFacetFreezable", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "isFunctionFreezable", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "isValidator", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "l2LogsRootHash", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "l2TransactionBaseCost", values: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "proposeDiamondCut", values: [Diamond.FacetCutStruct[], PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "proveBlocks", values: [
        IExecutor.StoredBlockInfoStruct,
        IExecutor.StoredBlockInfoStruct[],
        IExecutor.ProofInputStruct
    ]): string;
    encodeFunctionData(functionFragment: "proveL2LogInclusion", values: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        L2LogStruct,
        PromiseOrValue<BytesLike>[]
    ]): string;
    encodeFunctionData(functionFragment: "proveL2MessageInclusion", values: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        L2MessageStruct,
        PromiseOrValue<BytesLike>[]
    ]): string;
    encodeFunctionData(functionFragment: "requestL2Transaction", values: [
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BytesLike>[]
    ]): string;
    encodeFunctionData(functionFragment: "revertBlocks", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "serializeL2Transaction", values: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BytesLike>[]
    ]): string;
    encodeFunctionData(functionFragment: "setL2BootloaderBytecodeHash", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "setL2DefaultAccountBytecodeHash", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "setPendingGovernor", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "setPorterAvailability", values: [PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "setValidator", values: [PromiseOrValue<string>, PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "unfreezeDiamond", values?: undefined): string;
    decodeFunctionResult(functionFragment: "acceptGovernor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approveEmergencyDiamondCutAsSecurityCouncilMember", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "cancelDiamondCutProposal", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "commitBlocks", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "emergencyFreezeDiamond", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "executeBlocks", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "executeDiamondCutProposal", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "facetAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "facetAddresses", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "facetFunctionSelectors", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "facets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getFirstUnprocessedPriorityTx", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getGovernor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTotalBlocksCommitted", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTotalBlocksExecuted", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTotalBlocksVerified", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTotalPriorityTxs", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVerifier", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isFacetFreezable", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isFunctionFreezable", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isValidator", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "l2LogsRootHash", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "l2TransactionBaseCost", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "proposeDiamondCut", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "proveBlocks", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "proveL2LogInclusion", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "proveL2MessageInclusion", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "requestL2Transaction", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "revertBlocks", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "serializeL2Transaction", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setL2BootloaderBytecodeHash", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setL2DefaultAccountBytecodeHash", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setPendingGovernor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setPorterAvailability", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setValidator", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unfreezeDiamond", data: BytesLike): Result;
    events: {
        "BlockCommit(uint256)": EventFragment;
        "BlockExecution(uint256)": EventFragment;
        "BlocksRevert(uint256,uint256,uint256)": EventFragment;
        "DiamondCutProposal(tuple[],address)": EventFragment;
        "DiamondCutProposalCancelation()": EventFragment;
        "DiamondCutProposalExecution(tuple)": EventFragment;
        "EmergencyDiamondCutApproved(address)": EventFragment;
        "EmergencyFreeze()": EventFragment;
        "IsPorterAvailableStatusUpdate(bool)": EventFragment;
        "NewGovernor(address)": EventFragment;
        "NewL2BootloaderBytecodeHash(bytes32,bytes32)": EventFragment;
        "NewL2DefaultAccountBytecodeHash(bytes32,bytes32)": EventFragment;
        "NewPendingGovernor(address,address)": EventFragment;
        "NewPriorityRequest(uint256,bytes32,uint64,tuple,bytes[])": EventFragment;
        "Unfreeze()": EventFragment;
        "ValidatorStatusUpdate(address,bool)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "BlockCommit"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "BlockExecution"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "BlocksRevert"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "DiamondCutProposal"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "DiamondCutProposalCancelation"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "DiamondCutProposalExecution"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "EmergencyDiamondCutApproved"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "EmergencyFreeze"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "IsPorterAvailableStatusUpdate"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "NewGovernor"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "NewL2BootloaderBytecodeHash"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "NewL2DefaultAccountBytecodeHash"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "NewPendingGovernor"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "NewPriorityRequest"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Unfreeze"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ValidatorStatusUpdate"): EventFragment;
}
export interface BlockCommitEventObject {
    blockNumber: BigNumber;
}
export type BlockCommitEvent = TypedEvent<[BigNumber], BlockCommitEventObject>;
export type BlockCommitEventFilter = TypedEventFilter<BlockCommitEvent>;
export interface BlockExecutionEventObject {
    blockNumber: BigNumber;
}
export type BlockExecutionEvent = TypedEvent<[
    BigNumber
], BlockExecutionEventObject>;
export type BlockExecutionEventFilter = TypedEventFilter<BlockExecutionEvent>;
export interface BlocksRevertEventObject {
    totalBlocksCommitted: BigNumber;
    totalBlocksVerified: BigNumber;
    totalBlocksExecuted: BigNumber;
}
export type BlocksRevertEvent = TypedEvent<[
    BigNumber,
    BigNumber,
    BigNumber
], BlocksRevertEventObject>;
export type BlocksRevertEventFilter = TypedEventFilter<BlocksRevertEvent>;
export interface DiamondCutProposalEventObject {
    _facetCuts: Diamond.FacetCutStructOutput[];
    _initAddress: string;
}
export type DiamondCutProposalEvent = TypedEvent<[
    Diamond.FacetCutStructOutput[],
    string
], DiamondCutProposalEventObject>;
export type DiamondCutProposalEventFilter = TypedEventFilter<DiamondCutProposalEvent>;
export interface DiamondCutProposalCancelationEventObject {
}
export type DiamondCutProposalCancelationEvent = TypedEvent<[
], DiamondCutProposalCancelationEventObject>;
export type DiamondCutProposalCancelationEventFilter = TypedEventFilter<DiamondCutProposalCancelationEvent>;
export interface DiamondCutProposalExecutionEventObject {
    _diamondCut: Diamond.DiamondCutDataStructOutput;
}
export type DiamondCutProposalExecutionEvent = TypedEvent<[
    Diamond.DiamondCutDataStructOutput
], DiamondCutProposalExecutionEventObject>;
export type DiamondCutProposalExecutionEventFilter = TypedEventFilter<DiamondCutProposalExecutionEvent>;
export interface EmergencyDiamondCutApprovedEventObject {
    _address: string;
}
export type EmergencyDiamondCutApprovedEvent = TypedEvent<[
    string
], EmergencyDiamondCutApprovedEventObject>;
export type EmergencyDiamondCutApprovedEventFilter = TypedEventFilter<EmergencyDiamondCutApprovedEvent>;
export interface EmergencyFreezeEventObject {
}
export type EmergencyFreezeEvent = TypedEvent<[], EmergencyFreezeEventObject>;
export type EmergencyFreezeEventFilter = TypedEventFilter<EmergencyFreezeEvent>;
export interface IsPorterAvailableStatusUpdateEventObject {
    isPorterAvailable: boolean;
}
export type IsPorterAvailableStatusUpdateEvent = TypedEvent<[
    boolean
], IsPorterAvailableStatusUpdateEventObject>;
export type IsPorterAvailableStatusUpdateEventFilter = TypedEventFilter<IsPorterAvailableStatusUpdateEvent>;
export interface NewGovernorEventObject {
    newGovernor: string;
}
export type NewGovernorEvent = TypedEvent<[string], NewGovernorEventObject>;
export type NewGovernorEventFilter = TypedEventFilter<NewGovernorEvent>;
export interface NewL2BootloaderBytecodeHashEventObject {
    previousBytecodeHash: string;
    newBytecodeHash: string;
}
export type NewL2BootloaderBytecodeHashEvent = TypedEvent<[
    string,
    string
], NewL2BootloaderBytecodeHashEventObject>;
export type NewL2BootloaderBytecodeHashEventFilter = TypedEventFilter<NewL2BootloaderBytecodeHashEvent>;
export interface NewL2DefaultAccountBytecodeHashEventObject {
    previousBytecodeHash: string;
    newBytecodeHash: string;
}
export type NewL2DefaultAccountBytecodeHashEvent = TypedEvent<[
    string,
    string
], NewL2DefaultAccountBytecodeHashEventObject>;
export type NewL2DefaultAccountBytecodeHashEventFilter = TypedEventFilter<NewL2DefaultAccountBytecodeHashEvent>;
export interface NewPendingGovernorEventObject {
    oldPendingGovernor: string;
    newPendingGovernor: string;
}
export type NewPendingGovernorEvent = TypedEvent<[
    string,
    string
], NewPendingGovernorEventObject>;
export type NewPendingGovernorEventFilter = TypedEventFilter<NewPendingGovernorEvent>;
export interface NewPriorityRequestEventObject {
    txId: BigNumber;
    txHash: string;
    expirationBlock: BigNumber;
    transaction: IMailbox.L2CanonicalTransactionStructOutput;
    factoryDeps: string[];
}
export type NewPriorityRequestEvent = TypedEvent<[
    BigNumber,
    string,
    BigNumber,
    IMailbox.L2CanonicalTransactionStructOutput,
    string[]
], NewPriorityRequestEventObject>;
export type NewPriorityRequestEventFilter = TypedEventFilter<NewPriorityRequestEvent>;
export interface UnfreezeEventObject {
}
export type UnfreezeEvent = TypedEvent<[], UnfreezeEventObject>;
export type UnfreezeEventFilter = TypedEventFilter<UnfreezeEvent>;
export interface ValidatorStatusUpdateEventObject {
    validatorAddress: string;
    isActive: boolean;
}
export type ValidatorStatusUpdateEvent = TypedEvent<[
    string,
    boolean
], ValidatorStatusUpdateEventObject>;
export type ValidatorStatusUpdateEventFilter = TypedEventFilter<ValidatorStatusUpdateEvent>;
export interface IZkSync extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: IZkSyncInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        acceptGovernor(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        approveEmergencyDiamondCutAsSecurityCouncilMember(_diamondCutHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        cancelDiamondCutProposal(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        commitBlocks(_lastCommittedBlockData: IExecutor.StoredBlockInfoStruct, _newBlocksData: IExecutor.CommitBlockInfoStruct[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        emergencyFreezeDiamond(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        executeBlocks(_blocksData: IExecutor.StoredBlockInfoStruct[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        executeDiamondCutProposal(_diamondCut: Diamond.DiamondCutDataStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        facetAddress(_selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string] & {
            facet: string;
        }>;
        facetAddresses(overrides?: CallOverrides): Promise<[string[]] & {
            facets: string[];
        }>;
        facetFunctionSelectors(_facet: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string[]]>;
        facets(overrides?: CallOverrides): Promise<[IGetters.FacetStructOutput[]]>;
        getFirstUnprocessedPriorityTx(overrides?: CallOverrides): Promise<[BigNumber]>;
        getGovernor(overrides?: CallOverrides): Promise<[string]>;
        getTotalBlocksCommitted(overrides?: CallOverrides): Promise<[BigNumber]>;
        getTotalBlocksExecuted(overrides?: CallOverrides): Promise<[BigNumber]>;
        getTotalBlocksVerified(overrides?: CallOverrides): Promise<[BigNumber]>;
        getTotalPriorityTxs(overrides?: CallOverrides): Promise<[BigNumber]>;
        getVerifier(overrides?: CallOverrides): Promise<[string]>;
        isFacetFreezable(_facet: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        isFunctionFreezable(_selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[boolean]>;
        isValidator(_address: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        l2LogsRootHash(blockNumber: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string] & {
            hash: string;
        }>;
        l2TransactionBaseCost(_gasPrice: PromiseOrValue<BigNumberish>, _ergsLimit: PromiseOrValue<BigNumberish>, _calldataLength: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;
        proposeDiamondCut(_facetCuts: Diamond.FacetCutStruct[], _initAddress: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        proveBlocks(_prevBlock: IExecutor.StoredBlockInfoStruct, _committedBlocks: IExecutor.StoredBlockInfoStruct[], _proof: IExecutor.ProofInputStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        proveL2LogInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _log: L2LogStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<[boolean]>;
        proveL2MessageInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _message: L2MessageStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<[boolean]>;
        requestL2Transaction(_contractAddressL2: PromiseOrValue<string>, _l2Value: PromiseOrValue<BigNumberish>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        revertBlocks(_blocksToRevert: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        serializeL2Transaction(_txId: PromiseOrValue<BigNumberish>, _l2Value: PromiseOrValue<BigNumberish>, _sender: PromiseOrValue<string>, _contractAddressL2: PromiseOrValue<string>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<[IMailbox.L2CanonicalTransactionStructOutput]>;
        setL2BootloaderBytecodeHash(_l2BootloaderBytecodeHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setL2DefaultAccountBytecodeHash(_l2DefaultAccountBytecodeHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setPendingGovernor(_newPendingGovernor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setPorterAvailability(_isPorterAvailable: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setValidator(_validator: PromiseOrValue<string>, _active: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unfreezeDiamond(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    acceptGovernor(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    approveEmergencyDiamondCutAsSecurityCouncilMember(_diamondCutHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    cancelDiamondCutProposal(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    commitBlocks(_lastCommittedBlockData: IExecutor.StoredBlockInfoStruct, _newBlocksData: IExecutor.CommitBlockInfoStruct[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    emergencyFreezeDiamond(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    executeBlocks(_blocksData: IExecutor.StoredBlockInfoStruct[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    executeDiamondCutProposal(_diamondCut: Diamond.DiamondCutDataStruct, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    facetAddress(_selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    facetAddresses(overrides?: CallOverrides): Promise<string[]>;
    facetFunctionSelectors(_facet: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;
    facets(overrides?: CallOverrides): Promise<IGetters.FacetStructOutput[]>;
    getFirstUnprocessedPriorityTx(overrides?: CallOverrides): Promise<BigNumber>;
    getGovernor(overrides?: CallOverrides): Promise<string>;
    getTotalBlocksCommitted(overrides?: CallOverrides): Promise<BigNumber>;
    getTotalBlocksExecuted(overrides?: CallOverrides): Promise<BigNumber>;
    getTotalBlocksVerified(overrides?: CallOverrides): Promise<BigNumber>;
    getTotalPriorityTxs(overrides?: CallOverrides): Promise<BigNumber>;
    getVerifier(overrides?: CallOverrides): Promise<string>;
    isFacetFreezable(_facet: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    isFunctionFreezable(_selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;
    isValidator(_address: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    l2LogsRootHash(blockNumber: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;
    l2TransactionBaseCost(_gasPrice: PromiseOrValue<BigNumberish>, _ergsLimit: PromiseOrValue<BigNumberish>, _calldataLength: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
    proposeDiamondCut(_facetCuts: Diamond.FacetCutStruct[], _initAddress: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    proveBlocks(_prevBlock: IExecutor.StoredBlockInfoStruct, _committedBlocks: IExecutor.StoredBlockInfoStruct[], _proof: IExecutor.ProofInputStruct, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    proveL2LogInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _log: L2LogStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<boolean>;
    proveL2MessageInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _message: L2MessageStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<boolean>;
    requestL2Transaction(_contractAddressL2: PromiseOrValue<string>, _l2Value: PromiseOrValue<BigNumberish>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    revertBlocks(_blocksToRevert: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    serializeL2Transaction(_txId: PromiseOrValue<BigNumberish>, _l2Value: PromiseOrValue<BigNumberish>, _sender: PromiseOrValue<string>, _contractAddressL2: PromiseOrValue<string>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<IMailbox.L2CanonicalTransactionStructOutput>;
    setL2BootloaderBytecodeHash(_l2BootloaderBytecodeHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setL2DefaultAccountBytecodeHash(_l2DefaultAccountBytecodeHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setPendingGovernor(_newPendingGovernor: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setPorterAvailability(_isPorterAvailable: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setValidator(_validator: PromiseOrValue<string>, _active: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unfreezeDiamond(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        acceptGovernor(overrides?: CallOverrides): Promise<void>;
        approveEmergencyDiamondCutAsSecurityCouncilMember(_diamondCutHash: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        cancelDiamondCutProposal(overrides?: CallOverrides): Promise<void>;
        commitBlocks(_lastCommittedBlockData: IExecutor.StoredBlockInfoStruct, _newBlocksData: IExecutor.CommitBlockInfoStruct[], overrides?: CallOverrides): Promise<void>;
        emergencyFreezeDiamond(overrides?: CallOverrides): Promise<void>;
        executeBlocks(_blocksData: IExecutor.StoredBlockInfoStruct[], overrides?: CallOverrides): Promise<void>;
        executeDiamondCutProposal(_diamondCut: Diamond.DiamondCutDataStruct, overrides?: CallOverrides): Promise<void>;
        facetAddress(_selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        facetAddresses(overrides?: CallOverrides): Promise<string[]>;
        facetFunctionSelectors(_facet: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;
        facets(overrides?: CallOverrides): Promise<IGetters.FacetStructOutput[]>;
        getFirstUnprocessedPriorityTx(overrides?: CallOverrides): Promise<BigNumber>;
        getGovernor(overrides?: CallOverrides): Promise<string>;
        getTotalBlocksCommitted(overrides?: CallOverrides): Promise<BigNumber>;
        getTotalBlocksExecuted(overrides?: CallOverrides): Promise<BigNumber>;
        getTotalBlocksVerified(overrides?: CallOverrides): Promise<BigNumber>;
        getTotalPriorityTxs(overrides?: CallOverrides): Promise<BigNumber>;
        getVerifier(overrides?: CallOverrides): Promise<string>;
        isFacetFreezable(_facet: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        isFunctionFreezable(_selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;
        isValidator(_address: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        l2LogsRootHash(blockNumber: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;
        l2TransactionBaseCost(_gasPrice: PromiseOrValue<BigNumberish>, _ergsLimit: PromiseOrValue<BigNumberish>, _calldataLength: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        proposeDiamondCut(_facetCuts: Diamond.FacetCutStruct[], _initAddress: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        proveBlocks(_prevBlock: IExecutor.StoredBlockInfoStruct, _committedBlocks: IExecutor.StoredBlockInfoStruct[], _proof: IExecutor.ProofInputStruct, overrides?: CallOverrides): Promise<void>;
        proveL2LogInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _log: L2LogStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<boolean>;
        proveL2MessageInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _message: L2MessageStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<boolean>;
        requestL2Transaction(_contractAddressL2: PromiseOrValue<string>, _l2Value: PromiseOrValue<BigNumberish>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<string>;
        revertBlocks(_blocksToRevert: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        serializeL2Transaction(_txId: PromiseOrValue<BigNumberish>, _l2Value: PromiseOrValue<BigNumberish>, _sender: PromiseOrValue<string>, _contractAddressL2: PromiseOrValue<string>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<IMailbox.L2CanonicalTransactionStructOutput>;
        setL2BootloaderBytecodeHash(_l2BootloaderBytecodeHash: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        setL2DefaultAccountBytecodeHash(_l2DefaultAccountBytecodeHash: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        setPendingGovernor(_newPendingGovernor: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        setPorterAvailability(_isPorterAvailable: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        setValidator(_validator: PromiseOrValue<string>, _active: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        unfreezeDiamond(overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "BlockCommit(uint256)"(blockNumber?: PromiseOrValue<BigNumberish> | null): BlockCommitEventFilter;
        BlockCommit(blockNumber?: PromiseOrValue<BigNumberish> | null): BlockCommitEventFilter;
        "BlockExecution(uint256)"(blockNumber?: PromiseOrValue<BigNumberish> | null): BlockExecutionEventFilter;
        BlockExecution(blockNumber?: PromiseOrValue<BigNumberish> | null): BlockExecutionEventFilter;
        "BlocksRevert(uint256,uint256,uint256)"(totalBlocksCommitted?: null, totalBlocksVerified?: null, totalBlocksExecuted?: null): BlocksRevertEventFilter;
        BlocksRevert(totalBlocksCommitted?: null, totalBlocksVerified?: null, totalBlocksExecuted?: null): BlocksRevertEventFilter;
        "DiamondCutProposal(tuple[],address)"(_facetCuts?: null, _initAddress?: null): DiamondCutProposalEventFilter;
        DiamondCutProposal(_facetCuts?: null, _initAddress?: null): DiamondCutProposalEventFilter;
        "DiamondCutProposalCancelation()"(): DiamondCutProposalCancelationEventFilter;
        DiamondCutProposalCancelation(): DiamondCutProposalCancelationEventFilter;
        "DiamondCutProposalExecution(tuple)"(_diamondCut?: null): DiamondCutProposalExecutionEventFilter;
        DiamondCutProposalExecution(_diamondCut?: null): DiamondCutProposalExecutionEventFilter;
        "EmergencyDiamondCutApproved(address)"(_address?: null): EmergencyDiamondCutApprovedEventFilter;
        EmergencyDiamondCutApproved(_address?: null): EmergencyDiamondCutApprovedEventFilter;
        "EmergencyFreeze()"(): EmergencyFreezeEventFilter;
        EmergencyFreeze(): EmergencyFreezeEventFilter;
        "IsPorterAvailableStatusUpdate(bool)"(isPorterAvailable?: null): IsPorterAvailableStatusUpdateEventFilter;
        IsPorterAvailableStatusUpdate(isPorterAvailable?: null): IsPorterAvailableStatusUpdateEventFilter;
        "NewGovernor(address)"(newGovernor?: PromiseOrValue<string> | null): NewGovernorEventFilter;
        NewGovernor(newGovernor?: PromiseOrValue<string> | null): NewGovernorEventFilter;
        "NewL2BootloaderBytecodeHash(bytes32,bytes32)"(previousBytecodeHash?: PromiseOrValue<BytesLike> | null, newBytecodeHash?: PromiseOrValue<BytesLike> | null): NewL2BootloaderBytecodeHashEventFilter;
        NewL2BootloaderBytecodeHash(previousBytecodeHash?: PromiseOrValue<BytesLike> | null, newBytecodeHash?: PromiseOrValue<BytesLike> | null): NewL2BootloaderBytecodeHashEventFilter;
        "NewL2DefaultAccountBytecodeHash(bytes32,bytes32)"(previousBytecodeHash?: PromiseOrValue<BytesLike> | null, newBytecodeHash?: PromiseOrValue<BytesLike> | null): NewL2DefaultAccountBytecodeHashEventFilter;
        NewL2DefaultAccountBytecodeHash(previousBytecodeHash?: PromiseOrValue<BytesLike> | null, newBytecodeHash?: PromiseOrValue<BytesLike> | null): NewL2DefaultAccountBytecodeHashEventFilter;
        "NewPendingGovernor(address,address)"(oldPendingGovernor?: PromiseOrValue<string> | null, newPendingGovernor?: PromiseOrValue<string> | null): NewPendingGovernorEventFilter;
        NewPendingGovernor(oldPendingGovernor?: PromiseOrValue<string> | null, newPendingGovernor?: PromiseOrValue<string> | null): NewPendingGovernorEventFilter;
        "NewPriorityRequest(uint256,bytes32,uint64,tuple,bytes[])"(txId?: null, txHash?: null, expirationBlock?: null, transaction?: null, factoryDeps?: null): NewPriorityRequestEventFilter;
        NewPriorityRequest(txId?: null, txHash?: null, expirationBlock?: null, transaction?: null, factoryDeps?: null): NewPriorityRequestEventFilter;
        "Unfreeze()"(): UnfreezeEventFilter;
        Unfreeze(): UnfreezeEventFilter;
        "ValidatorStatusUpdate(address,bool)"(validatorAddress?: PromiseOrValue<string> | null, isActive?: null): ValidatorStatusUpdateEventFilter;
        ValidatorStatusUpdate(validatorAddress?: PromiseOrValue<string> | null, isActive?: null): ValidatorStatusUpdateEventFilter;
    };
    estimateGas: {
        acceptGovernor(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        approveEmergencyDiamondCutAsSecurityCouncilMember(_diamondCutHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        cancelDiamondCutProposal(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        commitBlocks(_lastCommittedBlockData: IExecutor.StoredBlockInfoStruct, _newBlocksData: IExecutor.CommitBlockInfoStruct[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        emergencyFreezeDiamond(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        executeBlocks(_blocksData: IExecutor.StoredBlockInfoStruct[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        executeDiamondCutProposal(_diamondCut: Diamond.DiamondCutDataStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        facetAddress(_selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        facetAddresses(overrides?: CallOverrides): Promise<BigNumber>;
        facetFunctionSelectors(_facet: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        facets(overrides?: CallOverrides): Promise<BigNumber>;
        getFirstUnprocessedPriorityTx(overrides?: CallOverrides): Promise<BigNumber>;
        getGovernor(overrides?: CallOverrides): Promise<BigNumber>;
        getTotalBlocksCommitted(overrides?: CallOverrides): Promise<BigNumber>;
        getTotalBlocksExecuted(overrides?: CallOverrides): Promise<BigNumber>;
        getTotalBlocksVerified(overrides?: CallOverrides): Promise<BigNumber>;
        getTotalPriorityTxs(overrides?: CallOverrides): Promise<BigNumber>;
        getVerifier(overrides?: CallOverrides): Promise<BigNumber>;
        isFacetFreezable(_facet: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        isFunctionFreezable(_selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        isValidator(_address: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        l2LogsRootHash(blockNumber: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        l2TransactionBaseCost(_gasPrice: PromiseOrValue<BigNumberish>, _ergsLimit: PromiseOrValue<BigNumberish>, _calldataLength: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        proposeDiamondCut(_facetCuts: Diamond.FacetCutStruct[], _initAddress: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        proveBlocks(_prevBlock: IExecutor.StoredBlockInfoStruct, _committedBlocks: IExecutor.StoredBlockInfoStruct[], _proof: IExecutor.ProofInputStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        proveL2LogInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _log: L2LogStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<BigNumber>;
        proveL2MessageInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _message: L2MessageStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<BigNumber>;
        requestL2Transaction(_contractAddressL2: PromiseOrValue<string>, _l2Value: PromiseOrValue<BigNumberish>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        revertBlocks(_blocksToRevert: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        serializeL2Transaction(_txId: PromiseOrValue<BigNumberish>, _l2Value: PromiseOrValue<BigNumberish>, _sender: PromiseOrValue<string>, _contractAddressL2: PromiseOrValue<string>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<BigNumber>;
        setL2BootloaderBytecodeHash(_l2BootloaderBytecodeHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setL2DefaultAccountBytecodeHash(_l2DefaultAccountBytecodeHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setPendingGovernor(_newPendingGovernor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setPorterAvailability(_isPorterAvailable: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setValidator(_validator: PromiseOrValue<string>, _active: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        unfreezeDiamond(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        acceptGovernor(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        approveEmergencyDiamondCutAsSecurityCouncilMember(_diamondCutHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        cancelDiamondCutProposal(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        commitBlocks(_lastCommittedBlockData: IExecutor.StoredBlockInfoStruct, _newBlocksData: IExecutor.CommitBlockInfoStruct[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        emergencyFreezeDiamond(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        executeBlocks(_blocksData: IExecutor.StoredBlockInfoStruct[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        executeDiamondCutProposal(_diamondCut: Diamond.DiamondCutDataStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        facetAddress(_selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        facetAddresses(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        facetFunctionSelectors(_facet: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        facets(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getFirstUnprocessedPriorityTx(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getGovernor(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTotalBlocksCommitted(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTotalBlocksExecuted(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTotalBlocksVerified(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTotalPriorityTxs(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVerifier(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isFacetFreezable(_facet: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isFunctionFreezable(_selector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isValidator(_address: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        l2LogsRootHash(blockNumber: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        l2TransactionBaseCost(_gasPrice: PromiseOrValue<BigNumberish>, _ergsLimit: PromiseOrValue<BigNumberish>, _calldataLength: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        proposeDiamondCut(_facetCuts: Diamond.FacetCutStruct[], _initAddress: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        proveBlocks(_prevBlock: IExecutor.StoredBlockInfoStruct, _committedBlocks: IExecutor.StoredBlockInfoStruct[], _proof: IExecutor.ProofInputStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        proveL2LogInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _log: L2LogStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        proveL2MessageInclusion(_blockNumber: PromiseOrValue<BigNumberish>, _index: PromiseOrValue<BigNumberish>, _message: L2MessageStruct, _proof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        requestL2Transaction(_contractAddressL2: PromiseOrValue<string>, _l2Value: PromiseOrValue<BigNumberish>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        revertBlocks(_blocksToRevert: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        serializeL2Transaction(_txId: PromiseOrValue<BigNumberish>, _l2Value: PromiseOrValue<BigNumberish>, _sender: PromiseOrValue<string>, _contractAddressL2: PromiseOrValue<string>, _calldata: PromiseOrValue<BytesLike>, _ergsLimit: PromiseOrValue<BigNumberish>, _factoryDeps: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<PopulatedTransaction>;
        setL2BootloaderBytecodeHash(_l2BootloaderBytecodeHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setL2DefaultAccountBytecodeHash(_l2DefaultAccountBytecodeHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setPendingGovernor(_newPendingGovernor: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setPorterAvailability(_isPorterAvailable: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setValidator(_validator: PromiseOrValue<string>, _active: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unfreezeDiamond(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}
//# sourceMappingURL=IZkSync.d.ts.map