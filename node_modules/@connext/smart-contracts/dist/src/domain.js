"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.delay = exports.evmId = exports.canonizeId = exports.getDomainFromString = exports.getHexDomainFromString = exports.domainToChainId = exports.chainIdToDomain = void 0;
const ethers_1 = require("ethers");
const node_fetch_1 = __importStar(require("node-fetch"));
if (!globalThis.fetch) {
    globalThis.fetch = node_fetch_1.default;
    globalThis.Headers = node_fetch_1.Headers;
    globalThis.Request = node_fetch_1.Request;
    globalThis.Response = node_fetch_1.Response;
}
// Hex domains calculated using `getHexDomainFromString`
// alternative: ethers.BigNumber.from(ethers.utils.toUtf8Bytes("some string")).toNumber()
const chainIdToDomainMapping = new Map([
    // mainnets
    [1, 0x657468],
    [10, 0x6f707469],
    [56, 0x626e62],
    [100, 0x676e6f],
    [137, 0x706f6c79],
    [1284, 0x6265616d],
    [42161, 0x6172626f],
    // testnets
    [42, 0x6b6f7661],
    [5, 0x676f6572],
    [420, 0x676f7074],
    [69, 0x6b6f7074],
    [80001, 0x2707],
    [421613, 0x67617262],
    [10200, 0x63686961],
    [97, 0x63686170],
    [59140, 0x636f6e74],
    // local
    [1337, 133712],
    [1338, 133812],
    [13337, 13337],
    [13338, 13338],
]);
/**
 * Converts a chain id (listed at at chainlist.org) to a domain.
 *
 * @param chainId A chain id number
 * @returns A domain number in decimal
 */
function chainIdToDomain(chainId) {
    const domain = chainIdToDomainMapping.get(chainId);
    if (!domain)
        throw new Error(`Cannot find corresponding domain for chainId ${chainId}`);
    return domain;
}
exports.chainIdToDomain = chainIdToDomain;
/**
 * Converts a domain id  to a chain id. (listed at at chainlist.org)
 *
 * @param domainId A domain id number
 * @returns A chain id
 */
function domainToChainId(domainId) {
    const keys = chainIdToDomainMapping.keys();
    let chainId;
    for (const key of keys) {
        if (chainIdToDomainMapping.get(key) == domainId)
            chainId = key;
    }
    if (!chainId) {
        throw new Error(`Cannot find corresponding chainId for domain ${domainId}`);
    }
    return chainId;
}
exports.domainToChainId = domainToChainId;
/**
 * Converts a string (e.g. "eth" for Ethereum) to a domain displayed as
 * a hex string.
 * @dev Interprets string bytes as int.
 * @param name The chain string
 * @returns A 0x prefixed domain in hex (string)
 */
function getHexDomainFromString(name) {
    const domain = getDomainFromString(name);
    return "0x" + domain.toString(16);
}
exports.getHexDomainFromString = getHexDomainFromString;
/**
 * Converts a string (e.g. "eth" for Ethereum) to a decimal formatted domain.
 * @dev Interprets string bytes as int.
 * @param name The chain string
 * @returns A domain number in decimal
 */
function getDomainFromString(name) {
    const buf = Buffer.alloc(4);
    const offset = 4 - name.length;
    buf.write(name, offset > 0 ? offset : 0, "utf8");
    return buf.readUInt32BE(0);
}
exports.getDomainFromString = getDomainFromString;
/**
 * Converts a 20-byte (or other length) ID to a 32-byte ID.
 * Ensures that a bytes-like is 32 long. left-padding with 0s if not.
 *
 * @param data A string or array of bytes to canonize
 * @returns A Uint8Array of length 32
 * @throws if the input is undefined, or not exactly 20 or 32 bytes long
 */
function canonizeId(data) {
    if (!data)
        throw new Error("Bad input. Undefined");
    const buf = ethers_1.utils.arrayify(data);
    if (buf.length > 32)
        throw new Error("Too long");
    if (buf.length !== 20 && buf.length != 32) {
        throw new Error("bad input, expect address or bytes32");
    }
    return ethers_1.utils.zeroPad(buf, 32);
}
exports.canonizeId = canonizeId;
/**
 * Converts an ID of 20 or 32 bytes to the corresponding EVM Address.
 *
 * For 32-byte IDs this enforces the EVM convention of using the LAST 20 bytes.
 *
 * @param data The data to truncate
 * @returns A 20-byte, 0x-prepended hex string representing the EVM Address
 * @throws if the data is not 20 or 32 bytes
 */
function evmId(data) {
    const u8a = ethers_1.utils.arrayify(data);
    if (u8a.length === 32) {
        return ethers_1.utils.hexlify(u8a.slice(12, 32));
    }
    else if (u8a.length === 20) {
        return ethers_1.utils.hexlify(u8a);
    }
    else {
        throw new Error(`Invalid id length. expected 20 or 32. Got ${u8a.length}`);
    }
}
exports.evmId = evmId;
/**
 * Sleep async for some time.
 *
 * @param ms the number of milliseconds to sleep
 * @returns A delay promise
 */
function delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
exports.delay = delay;
//# sourceMappingURL=domain.js.map