"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSpokeConnector = exports.getHubConnectors = exports.getDeployedContracts = exports.getContract = void 0;
const ethers_1 = require("ethers");
const deployments_json_1 = __importDefault(require("../../deployments.json"));
const contracts_1 = require("../contracts");
const Deployments = deployments_json_1.default;
// Custom function to format lookup by env and double check that the contract retrieved is not null.
const getContract = (name, chain, useStaging, connection) => {
    const deployments = Deployments[chain];
    if (!deployments) {
        throw new Error(`No deployments found for chain ${chain}!`);
    }
    const contracts = deployments[0]["contracts"];
    if (!contracts) {
        throw new Error(`No contracts found under deployments for chain ${chain}!`);
    }
    const envSuffix = useStaging ? "Staging" : "";
    const isConnext = name.includes("Connext");
    const key = isConnext ? `Connext${envSuffix}_DiamondProxy` : name + envSuffix;
    const result = contracts[key];
    if (!result) {
        throw new Error(`Contract ${key} on ${chain} was not found in deployments.json!`);
    }
    else if (!result.address || !result.abi) {
        throw new Error(`Contract ${key} was missing address or ABI in deployments.json!`);
    }
    // Use the ABI of the implementation contract, if applicable.
    let abi = result.abi;
    const implementation = name.includes("UpgradeBeaconProxy") ? name.replace("UpgradeBeaconProxy", "") : undefined;
    if (implementation) {
        const implementation_with_env = useStaging ? implementation?.concat("Staging") : implementation;
        const found = contracts[implementation_with_env];
        if (found && found.abi) {
            abi = found.abi;
        }
    }
    return {
        proxy: key,
        name: isConnext ? "Connext" : implementation ?? name,
        address: result.address,
        abi,
        contract: new ethers_1.Contract(result.address, 
        // Special case if this is the Connext diamond.
        isConnext ? contracts_1.ConnextInterface : abi, connection),
    };
};
exports.getContract = getContract;
const getDeployedContracts = (chainId) => {
    // get list of all deployments for chain
    const [deployments] = Deployments[chainId];
    if (!deployments) {
        throw new Error(`No deployments found for chain ${chainId}!`);
    }
    const contracts = deployments.contracts;
    if (!contracts) {
        throw new Error(`No contracts found under deployments for chain ${chainId}!`);
    }
    return contracts;
};
exports.getDeployedContracts = getDeployedContracts;
const getHubConnectors = (chainId, env, connection) => {
    const contracts = (0, exports.getDeployedContracts)(chainId);
    const suffix = env === "staging" ? "Staging" : "";
    const connectors = [];
    for (const key of Object.keys(contracts)) {
        // TODO: Use regex? Or a more flexible method?
        // Ignore accidental L2 or Spoke Connector deployments...
        if (key.includes("L2") || key.includes("Spoke")) {
            continue;
        }
        if (key.endsWith("Connector" + suffix) && !key.includes("Mainnet")) {
            const contract = contracts[key];
            connectors.push({
                name: key,
                address: contract.address,
                abi: contract.abi,
                contract: new ethers_1.Contract(contract.address, contract.abi, connection),
            });
        }
    }
    return connectors;
};
exports.getHubConnectors = getHubConnectors;
const getSpokeConnector = (chainId, env, connection) => {
    const contracts = (0, exports.getDeployedContracts)(chainId);
    const suffix = env === "staging" ? "Staging" : "";
    const connectors = [];
    for (const key of Object.keys(contracts)) {
        if (key.endsWith("L2Connector" + env) || key.endsWith("SpokeConnector" + suffix)) {
            const contract = contracts[key];
            connectors.push({
                name: key,
                address: contract.address,
                abi: contract.abi,
                contract: new ethers_1.Contract(contract.address, contract.abi, connection),
            });
        }
    }
    if (connectors.length > 1) {
        throw new Error(`Multiple L2/Spoke Connectors found on spoke chain ${chainId} while consulting deployments.json! ` +
            "Please ensure outdated Connector deployment is deleted and removed.");
    }
    if (connectors.length == 0) {
        throw new Error(`No L2/Spoke Connectors found on spoke chain ${chainId} while consulting deployments.json!`);
    }
    return connectors[0];
};
exports.getSpokeConnector = getSpokeConnector;
//# sourceMappingURL=helpers.js.map