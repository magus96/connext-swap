"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.wouldYouLikeToPlayAGame = exports.optionDefinitions = void 0;
const dotenv_1 = require("dotenv");
const command_line_args_1 = __importDefault(require("command-line-args"));
const ethers_1 = require("ethers");
const config_1 = require("../../config");
const domain_1 = require("../../domain");
const helpers_1 = require("./helpers");
(0, dotenv_1.config)();
exports.optionDefinitions = [
    { name: "env", type: String },
    { name: "domains", type: String, multiple: true },
    { name: "period", type: Number, defaultValue: 172800000 }, // default 48h
];
const wouldYouLikeToPlayAGame = async () => {
    let cmdArgs;
    try {
        cmdArgs = (0, command_line_args_1.default)(exports.optionDefinitions);
    }
    catch (err) {
        throw new Error(`Parsing arguments failed, cmdArgs: ${process.argv}`);
    }
    /// MARK - Validate command line arguments
    // validate env
    const { env, domains: _domains, period } = cmdArgs;
    if (!["staging"].includes(env)) {
        throw new Error(`Firedrill should be run on staging, env: ${env}`);
    }
    // validate domains
    const domains = (_domains ?? helpers_1.SUPPORTED_DOMAINS[env]);
    for (const domain of domains) {
        if (!helpers_1.SUPPORTED_DOMAINS[env].includes(domain)) {
            throw new Error(`Unsupported domain parsed!, domain: ${domain}, supported: ${helpers_1.SUPPORTED_DOMAINS[env]}`);
        }
    }
    // validate period
    if (period < helpers_1.MIN_PERIOD || period > helpers_1.MAX_PERIOD) {
        throw new Error(`Period is outside of boundary, must be between 5m and 1w: ${period}`);
    }
    /// MARK - Deployer
    // Get deployer mnemonic, which should be provided in env if not in the config.
    const mnemonic = process.env.DEPLOYER || process.env.DEPLOYER_MNEMONIC || process.env.MNEMONIC;
    if (!mnemonic) {
        throw new Error("Deployer mnemonic was not specified. Please specify `deployer` in the config file, " +
            "or set DEPLOYER or DEPLOYER_MNEMONIC in env.");
    }
    // Convert deployer from mnemonic to Wallet.
    const deployer = ethers_1.Wallet.fromMnemonic(mnemonic);
    const networks = [];
    const filteredHardhatNetworks = Object.values(config_1.hardhatNetworks).filter((hardhatNetwork) => Object.keys(hardhatNetwork).includes("chainId") &&
        Object.keys(hardhatNetwork).includes("url"));
    // Get deployments for each domain if not specified in the config.
    // NOTE: will error if cannot find BigBroERC20
    for (const domain of domains) {
        const chainId = (0, domain_1.domainToChainId)(+domain);
        const chainConfig = Object.values(filteredHardhatNetworks).find((networkConfig) => networkConfig["chainId"] == chainId);
        if (!chainConfig || !chainConfig.url) {
            throw new Error(`Not configured network for chainId: ${chainId} in hardhat config`);
        }
        const rpc = new ethers_1.providers.JsonRpcProvider(chainConfig.url);
        // ensure deployer has funds
        const balance = await deployer.connect(rpc).getBalance();
        if (balance.lt(helpers_1.MIN_WALLET_GAS)) {
            throw new Error(`Deployer (${deployer.address}) needs more funds on ${chainId}. Has: ${ethers_1.utils.formatEther(balance)}; Needs: ${ethers_1.utils.formatEther(helpers_1.MIN_WALLET_GAS)}`);
        }
        const deployments = (0, helpers_1.getDeployments)({
            deployer,
            chainInfo: { chain: chainId.toString(), rpc },
        });
        networks.push({
            chain: chainId.toString(),
            domain,
            rpc,
            deployments,
        });
    }
    /// MARK - mint big bro token
    // randomly select network (hub excluded by supported domains check)
    const idx = Math.floor(Math.random() * networks.length);
    const { deployments: { WatcherToken: { contract }, }, } = networks[idx];
    // create callback
    const mint = async () => {
        console.log(`sending mint tx to: ${contract.address}`);
        const mintTx = await contract.mint(deployer.address, ethers_1.utils.parseEther("1"));
        console.log(`submitted mint tx to: ${contract.address}: ${mintTx.hash}`);
        const receipt = await mintTx.wait();
        console.log(`mined mint tx: ${receipt.transactionHash}`);
    };
    // randomly select timeout
    const timeout = Math.ceil(Math.random() * period);
    // initiate test
    console.log(`watcher alert timeout set...`);
    console.log(`gl....`);
    await (0, domain_1.delay)(timeout);
    await mint();
};
exports.wouldYouLikeToPlayAGame = wouldYouLikeToPlayAGame;
//# sourceMappingURL=firedrill.js.map