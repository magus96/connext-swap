import { utils } from "ethers";
export type Address = string;
/**
 * Converts a chain id (listed at at chainlist.org) to a domain.
 *
 * @param chainId A chain id number
 * @returns A domain number in decimal
 */
export declare function chainIdToDomain(chainId: number): number;
/**
 * Converts a domain id  to a chain id. (listed at at chainlist.org)
 *
 * @param domainId A domain id number
 * @returns A chain id
 */
export declare function domainToChainId(domainId: number): number;
/**
 * Converts a string (e.g. "eth" for Ethereum) to a domain displayed as
 * a hex string.
 * @dev Interprets string bytes as int.
 * @param name The chain string
 * @returns A 0x prefixed domain in hex (string)
 */
export declare function getHexDomainFromString(name: string): string;
/**
 * Converts a string (e.g. "eth" for Ethereum) to a decimal formatted domain.
 * @dev Interprets string bytes as int.
 * @param name The chain string
 * @returns A domain number in decimal
 */
export declare function getDomainFromString(name: string): number;
/**
 * Converts a 20-byte (or other length) ID to a 32-byte ID.
 * Ensures that a bytes-like is 32 long. left-padding with 0s if not.
 *
 * @param data A string or array of bytes to canonize
 * @returns A Uint8Array of length 32
 * @throws if the input is undefined, or not exactly 20 or 32 bytes long
 */
export declare function canonizeId(data?: utils.BytesLike): Uint8Array;
/**
 * Converts an ID of 20 or 32 bytes to the corresponding EVM Address.
 *
 * For 32-byte IDs this enforces the EVM convention of using the LAST 20 bytes.
 *
 * @param data The data to truncate
 * @returns A 20-byte, 0x-prepended hex string representing the EVM Address
 * @throws if the data is not 20 or 32 bytes
 */
export declare function evmId(data: utils.BytesLike): Address;
/**
 * Sleep async for some time.
 *
 * @param ms the number of milliseconds to sleep
 * @returns A delay promise
 */
export declare function delay(ms: number): Promise<void>;
//# sourceMappingURL=domain.d.ts.map