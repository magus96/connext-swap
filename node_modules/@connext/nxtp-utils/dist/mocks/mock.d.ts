import { providers } from "ethers";
import { XTransfer, XTransferStatus, Bid, TransferInfo, ExecuteArgs } from "..";
import { Auction, ExecutorData, XMessage, RootMessage, XCallArgs, OriginMessage, AggregatedRoot, PropagatedRoot, ReceivedAggregateRoot, XTransferErrorStatus, StableSwapPool, StableSwapExchange, StableSwapPoolEvent } from "../types";
export declare const mockSequencer: string;
/**
 * General mock toolset used for testing globally.
 */
export declare const mock: {
    domain: {
        A: string;
        B: string;
    };
    chain: {
        A: string;
        B: string;
    };
    asset: {
        A: {
            name: string;
            symbol: string;
            address: string;
        };
        B: {
            name: string;
            symbol: string;
            address: string;
        };
    };
    chainData: () => Map<string, import("..").ChainData>;
    signature: string;
    encodedData: () => string;
    address: {
        router: string;
        relayer: string;
    };
    loggingContext: (name?: string) => {
        methodContext: import("..").MethodContext;
        requestContext: import("..").RequestContextWithTransactionId;
    };
    entity: {
        callParams: (overrides?: Partial<TransferInfo>) => TransferInfo;
        xcallArgs: (overrides?: Partial<XCallArgs>) => XCallArgs;
        executeArgs: (overrides?: Partial<ExecuteArgs>) => ExecuteArgs;
        auction: (overrides: Partial<Auction>) => Auction;
        bid: (overrides?: Partial<Bid>) => Bid;
        executorData: (overrides?: Partial<ExecutorData>) => ExecutorData;
        xtransfer: (overrides?: {
            originDomain?: string;
            destinationDomain?: string;
            canonicalDomain?: string;
            canonicalId?: string;
            delegate?: string;
            slippage?: string;
            originSender?: string;
            bridgedAmt?: string;
            normalizedIn?: string;
            originChain?: string;
            destinationChain?: string;
            amount?: string;
            status?: XTransferStatus;
            errorStatus?: XTransferErrorStatus;
            asset?: string;
            transferId?: string;
            messageHash?: string;
            nonce?: number;
            user?: string;
            routers?: string[];
            relayerFee?: string;
        }) => XTransfer;
        dbTransfer: (overrides: any) => any;
        originMessage: (overrides?: Partial<OriginMessage>) => OriginMessage;
        xMessage: (overrides?: Partial<XMessage>) => XMessage;
        rootMessage: (overrides?: Partial<RootMessage>) => RootMessage;
        aggregatedRoot: (overrides?: Partial<AggregatedRoot>) => AggregatedRoot;
        propagatedRoot: (overrides?: Partial<PropagatedRoot>) => PropagatedRoot;
        receivedAggregateRoot: (overrides?: Partial<ReceivedAggregateRoot>) => ReceivedAggregateRoot;
        stableSwapPool: (overrides?: Partial<StableSwapPool>) => StableSwapPool;
        stableSwapExchange: (overrides?: Partial<StableSwapExchange>) => StableSwapExchange;
        stableswapPoolEvent: (overrides?: Partial<StableSwapPoolEvent>) => StableSwapPoolEvent;
    };
    ethers: {
        receipt: (overrides?: Partial<providers.TransactionReceipt>) => providers.TransactionReceipt;
    };
    contracts: {
        deployments: {
            connext: (_: number) => {
                address: string;
                abi: string;
            };
            relayerProxy: (_: number) => {
                address: string;
                abi: string;
            };
            priceOracle: (_: number) => {
                address: string;
                abi: string;
            };
            stableSwap: (_: number) => {
                address: string;
                abi: string;
            };
            spokeConnector: (_: number) => {
                address: string;
                abi: string;
            };
            hubConnector: (_: number) => {
                address: string;
                abi: string;
            };
            multisend: (_: number) => {
                address: string;
                abi: string;
            };
            unwrapper: (_: number) => {
                address: string;
                abi: string;
            };
        };
    };
};
//# sourceMappingURL=mock.d.ts.map