"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mock = exports.mockSequencer = void 0;
const ethers_1 = require("ethers");
const __1 = require("..");
const helpers_1 = require("../helpers");
const _1 = require(".");
exports.mockSequencer = (0, _1.mkAddress)("0x333");
/**
 * General mock toolset used for testing globally.
 */
exports.mock = {
    domain: {
        A: "13337",
        B: "13338",
    },
    chain: {
        A: "1337",
        B: "1338",
    },
    asset: {
        A: {
            name: "TEST-A",
            symbol: "TSTA",
            address: "0xBeEFBEEfBeEf0000000000000000000000000000",
        },
        B: {
            name: "TEST-B",
            symbol: "TSTB",
            address: "0x2fAceD0000000000000000000000000000000000",
        },
    },
    chainData: () => (0, __1.chainDataToMap)([
        {
            name: "Unit Test Chain 1",
            chainId: parseInt(exports.mock.chain.A),
            domainId: exports.mock.domain.A,
            confirmations: 1,
            assetId: {
                "0xBeEFBEEfBeEf0000000000000000000000000000": {
                    name: exports.mock.asset.A.name,
                    symbol: exports.mock.asset.A.symbol,
                    mainnetEquivalent: "0x0000000000000000000000000000000000000000",
                    decimals: 18,
                },
                "0x2fAceD0000000000000000000000000000000000": {
                    name: exports.mock.asset.B.name,
                    symbol: exports.mock.asset.B.symbol,
                    mainnetEquivalent: "0x0000000000000000000000000000000000000000",
                    decimals: 18,
                },
            },
            subgraphs: {
                runtime: [{ query: "http://example.com", health: "http://example.com" }],
                analytics: [{ query: "http://example.com", health: "http://example.com" }],
                maxLag: 10,
            },
        },
        {
            name: "Unit Test Chain 2",
            chainId: parseInt(exports.mock.chain.B),
            domainId: exports.mock.domain.B,
            confirmations: 1,
            assetId: {},
            subgraphs: {
                runtime: [{ query: "http://example.com", health: "http://example.com" }],
                analytics: [{ query: "http://example.com", health: "http://example.com" }],
                maxLag: 10,
            },
        },
    ]),
    signature: (0, _1.mkSig)("0xabcdef1c"),
    encodedData: () => (0, __1.getRandomBytes32)(),
    address: {
        router: (0, _1.mkAddress)("0xc0ffeebabe"),
        relayer: (0, _1.mkAddress)("0xdad"),
    },
    loggingContext: (name = "TEST") => (0, __1.createLoggingContext)(name, undefined, (0, _1.mkBytes32)()),
    entity: {
        callParams: (overrides = {}) => ({
            originDomain: exports.mock.domain.A,
            destinationDomain: exports.mock.domain.B,
            canonicalDomain: exports.mock.domain.A,
            to: (0, _1.mkAddress)("0xaaa"),
            delegate: (0, _1.mkAddress)("0xbbb"),
            receiveLocal: false,
            callData: "0x",
            slippage: "1000",
            originSender: (0, _1.mkAddress)("0x111"),
            bridgedAmt: "100",
            normalizedIn: "100",
            nonce: 1,
            canonicalId: (0, _1.mkAddress)("0x123"),
            ...overrides,
        }),
        xcallArgs: (overrides = {}) => ({
            destination: exports.mock.entity.callParams().destinationDomain,
            to: exports.mock.entity.callParams().to,
            asset: exports.mock.asset.A.address,
            delegate: (0, _1.mkAddress)(),
            amount: ethers_1.utils.parseEther("1").toString(),
            slippage: "1000",
            callData: "0x",
            ...overrides,
        }),
        executeArgs: (overrides = {}) => ({
            params: exports.mock.entity.callParams(),
            routers: [(0, _1.mkAddress)("0x222")],
            routerSignatures: [exports.mock.signature],
            sequencer: exports.mockSequencer,
            sequencerSignature: exports.mock.signature,
            ...overrides,
        }),
        auction: (overrides) => ({
            timestamp: (0, helpers_1.getNtpTimeSeconds)().toString(),
            origin: exports.mock.domain.A,
            destination: exports.mock.domain.B,
            bids: {
                [exports.mock.address.router]: exports.mock.entity.bid(),
            },
            ...overrides,
        }),
        bid: (overrides = {}) => ({
            routerVersion: "0.0.1",
            transferId: (0, __1.getRandomBytes32)(),
            origin: exports.mock.domain.A,
            router: exports.mock.address.router,
            signatures: {
                "1": (0, __1.getRandomBytes32)(),
                "2": (0, __1.getRandomBytes32)(),
                "3": (0, __1.getRandomBytes32)(),
            },
            ...overrides,
        }),
        executorData: (overrides = {}) => ({
            transferId: (0, __1.getRandomBytes32)(),
            origin: exports.mock.domain.A,
            executorVersion: "0.0.1",
            routerAddress: exports.mock.address.router,
            encodedData: "0xabcde",
            ...overrides,
        }),
        xtransfer: (overrides = {}) => {
            const originDomain = overrides.originDomain ?? exports.mock.domain.A;
            const destinationDomain = overrides.destinationDomain ?? exports.mock.domain.B;
            const canonicalDomain = overrides.canonicalDomain ?? exports.mock.domain.A;
            const canonicalId = overrides.canonicalId ?? "0";
            const delegate = overrides.delegate ?? (0, _1.mkAddress)("0x222");
            const slippage = overrides.slippage ?? "1000";
            const originSender = overrides.originSender ?? (0, _1.mkAddress)("0xaaa");
            const bridgedAmt = overrides.bridgedAmt ?? "100";
            const normalizedIn = overrides.normalizedIn ?? "100";
            const originChain = overrides.originChain ?? exports.mock.chain.A;
            const destinationChain = overrides.destinationChain ?? exports.mock.chain.B;
            const amount = overrides.amount ?? "1000";
            const status = overrides.status;
            const errorStatus = overrides.errorStatus;
            const asset = overrides.asset ?? exports.mock.asset.A.address;
            const transferId = overrides.transferId ?? (0, __1.getRandomBytes32)();
            const nonce = overrides.nonce ?? 1234;
            const user = overrides.user ?? (0, _1.mkAddress)("0xfaded");
            const routers = overrides.routers ?? [exports.mock.address.router];
            const messageHash = overrides.messageHash ?? (0, __1.getRandomBytes32)();
            const relayerFee = overrides.relayerFee ?? "0";
            const shouldHaveOriginDefined = true;
            const shouldHaveDestinationDefined = status && status != __1.XTransferStatus.XCalled;
            return {
                // Meta
                transferId,
                // Call Params
                xparams: {
                    originDomain,
                    destinationDomain,
                    canonicalDomain,
                    to: user,
                    callData: "0x",
                    slippage,
                    receiveLocal: false,
                    delegate,
                    originSender,
                    bridgedAmt,
                    normalizedIn,
                    nonce,
                    canonicalId,
                },
                origin: shouldHaveOriginDefined
                    ? {
                        chain: originChain,
                        messageHash,
                        relayerFee,
                        errorStatus,
                        // Assets
                        assets: {
                            transacting: {
                                asset,
                                amount,
                            },
                            bridged: {
                                asset,
                                amount,
                            },
                        },
                        // XCalled
                        xcall: {
                            // Event Data
                            caller: user,
                            transactionHash: (0, __1.getRandomBytes32)(),
                            timestamp: Math.floor(Date.now() / 1000 - 60),
                            gasPrice: ethers_1.utils.parseUnits("5", "gwei").toString(),
                            gasLimit: "80000",
                            blockNumber: 7654321,
                            txOrigin: user,
                        },
                    }
                    : undefined,
                destination: shouldHaveDestinationDefined
                    ? {
                        chain: destinationChain,
                        // Event Data
                        status,
                        routers,
                        // Assets
                        assets: {
                            // Transfer must have been Executed in order to have this defined.
                            transacting: status !== __1.XTransferStatus.Reconciled
                                ? {
                                    asset,
                                    amount,
                                }
                                : undefined,
                            local: {
                                asset,
                                amount,
                            },
                        },
                        // If status is executed, we should have executed fields defined (but leave reconciled fields empty).
                        execute: status === __1.XTransferStatus.Executed || status === __1.XTransferStatus.CompletedSlow
                            ? {
                                originSender: user,
                                caller: exports.mock.address.relayer,
                                transactionHash: (0, __1.getRandomBytes32)(),
                                timestamp: Math.floor(Date.now() / 1000 - 30),
                                gasPrice: ethers_1.utils.parseUnits("5", "gwei").toString(),
                                gasLimit: "80000",
                                blockNumber: 5651345,
                                txOrigin: user,
                            }
                            : undefined,
                        reconcile: status === __1.XTransferStatus.Reconciled || status === __1.XTransferStatus.CompletedFast
                            ? {
                                caller: exports.mock.address.relayer,
                                transactionHash: (0, __1.getRandomBytes32)(),
                                timestamp: Math.floor(Date.now() / 1000),
                                gasPrice: ethers_1.utils.parseUnits("5", "gwei").toString(),
                                gasLimit: "100000",
                                blockNumber: 5651390,
                                txOrigin: user,
                            }
                            : undefined,
                    }
                    : undefined,
            };
        },
        dbTransfer: (overrides) => ({
            origin_domain: exports.mock.domain.A,
            destination_domain: exports.mock.domain.B,
            nonce: 0,
            canonical_id: (0, _1.mkBytes32)("0x111"),
            canonical_domain: exports.mock.domain.A,
            to: (0, _1.mkAddress)("0x11111"),
            call_data: (0, _1.mkBytes32)("0xaaa"),
            transfer_id: (0, _1.mkBytes32)("0xbbb"),
            origin_chain: exports.mock.chain.A,
            origin_transacting_amount: 100,
            origin_transacting_asset: (0, _1.mkAddress)("0x11"),
            origin_bridged_amount: 100,
            origin_bridged_asset: (0, _1.mkAddress)("0x12"),
            xcall_block_number: 100,
            xcall_caller: (0, _1.mkAddress)("0x1"),
            xcall_gas_limit: 10000,
            xcall_gas_price: 5,
            xcall_timestamp: 1e8,
            xcall_transaction_hash: (0, _1.mkBytes32)("0xccc"),
            relayer_fee: 0,
            receive_local: false,
            slippage: 0,
            origin_sender: (0, _1.mkAddress)("0x1a1a1a"),
            bridged_amt: 100,
            normalized_in: 100,
            destination_chain: exports.mock.chain.B,
            destination_transacting_amount: 100,
            destination_transacting_asset: (0, _1.mkAddress)("0x22"),
            destination_local_amount: 100,
            destination_local_asset: (0, _1.mkAddress)("0x13"),
            routers: [],
            status: __1.XTransferStatus.XCalled,
            execute_block_number: 100,
            execute_caller: (0, _1.mkAddress)("0x2"),
            execute_gas_limit: 10000,
            execute_gas_price: 5,
            execute_timestamp: 1e8,
            execute_transaction_hash: (0, _1.mkBytes32)("0xddd"),
            execute_relayer_fee: 0,
            execute_origin_sender: (0, _1.mkAddress)("0x3"),
            reconcile_block_number: 100,
            reconcile_caller: (0, _1.mkAddress)("0x4"),
            reconcile_gas_limit: 10000,
            reconcile_gas_price: 5,
            reconcile_timestamp: 1e8,
            reconcile_transaction_hash: (0, _1.mkBytes32)("0xeee"),
            reconcile_relayer_fee: 0,
            reconcile_origin_sender: (0, _1.mkAddress)("0x5"),
            ...overrides,
        }),
        originMessage: (overrides = {}) => ({
            domain: exports.mock.domain.A,
            transferId: (0, __1.getRandomBytes32)(),
            destinationDomain: exports.mock.domain.B,
            leaf: (0, __1.getRandomBytes32)(),
            index: Math.floor(Date.now() / 1000),
            root: (0, __1.getRandomBytes32)(),
            message: (0, __1.getRandomBytes32)(),
            ...overrides,
        }),
        xMessage: (overrides = {}) => ({
            leaf: (0, __1.getRandomBytes32)(),
            originDomain: exports.mock.domain.A,
            destinationDomain: exports.mock.domain.B,
            transferId: (0, __1.getRandomBytes32)(),
            origin: {
                index: Math.floor(Date.now() / 1000),
                root: (0, __1.getRandomBytes32)(),
                message: (0, __1.getRandomBytes32)(),
            },
            destination: {
                processed: false,
                returnData: (0, __1.getRandomBytes32)(),
            },
            ...overrides,
        }),
        rootMessage: (overrides = {}) => ({
            id: (0, __1.getRandomBytes32)(),
            spokeDomain: exports.mock.domain.A,
            hubDomain: exports.mock.domain.B,
            root: (0, __1.getRandomBytes32)(),
            caller: exports.mock.address.relayer,
            transactionHash: (0, __1.getRandomBytes32)(),
            timestamp: Math.floor(Date.now() / 1000),
            gasPrice: ethers_1.utils.parseUnits("5", "gwei").toString(),
            gasLimit: "100000",
            blockNumber: Math.floor(Date.now() / 1000),
            processed: false,
            count: Math.floor(Date.now() / 1000),
            ...overrides,
        }),
        aggregatedRoot: (overrides = {}) => ({
            id: (0, __1.getRandomBytes32)(),
            domain: exports.mock.domain.A,
            receivedRoot: (0, __1.getRandomBytes32)(),
            index: Math.floor(Date.now() / 1000),
            ...overrides,
        }),
        propagatedRoot: (overrides = {}) => ({
            id: (0, __1.getRandomBytes32)(),
            aggregate: (0, __1.getRandomBytes32)(),
            domainsHash: (0, __1.getRandomBytes32)(),
            count: Math.floor(Date.now() / 1000),
            ...overrides,
        }),
        receivedAggregateRoot: (overrides = {}) => ({
            id: (0, __1.getRandomBytes32)(),
            domain: exports.mock.domain.A,
            root: (0, __1.getRandomBytes32)(),
            blockNumber: Math.floor(Date.now() / 1000),
            ...overrides,
        }),
        stableSwapPool: (overrides = {}) => ({
            key: (0, __1.getRandomBytes32)(),
            domain: exports.mock.domain.A,
            isActive: true,
            lpToken: (0, helpers_1.getRandomAddress)(),
            initialA: 200,
            futureA: 200,
            initialATime: 0,
            futureATime: 0,
            swapFee: "400000",
            adminFee: "0",
            pooledTokens: [(0, helpers_1.getRandomAddress)(), (0, helpers_1.getRandomAddress)()],
            tokenPrecisionMultipliers: ["1", "1"],
            poolTokenDecimals: [18, 18],
            balances: ["200000", "200000"],
            virtualPrice: "400000",
            invariant: "0",
            lpTokenSupply: "0",
            ...overrides,
        }),
        stableSwapExchange: (overrides = {}) => ({
            id: (0, __1.getRandomBytes32)(),
            poolId: (0, __1.getRandomBytes32)(),
            domain: exports.mock.domain.A,
            buyer: (0, helpers_1.getRandomAddress)(),
            boughtId: 1,
            soldId: 0,
            tokensSold: Math.floor(Date.now() / 1000),
            tokensBought: Math.floor(Date.now() / 1000),
            balances: [200, 200],
            fee: 2,
            blockNumber: Math.floor(Date.now() / 1000),
            transactionHash: (0, __1.getRandomBytes32)(),
            timestamp: Math.floor(Date.now() / 1000),
            ...overrides,
        }),
        stableswapPoolEvent: (overrides = {}) => ({
            id: `add_liquidity-${(0, __1.getRandomBytes32)()}`,
            poolId: (0, __1.getRandomBytes32)(),
            domain: exports.mock.domain.A,
            provider: (0, helpers_1.getRandomAddress)(),
            action: "Add",
            pooledTokens: [(0, helpers_1.getRandomAddress)(), (0, helpers_1.getRandomAddress)()],
            poolTokenDecimals: [18, 18],
            balances: [200, 200],
            fees: [2, 2],
            tokenAmounts: [200, 200],
            lpTokenAmount: Math.floor(Date.now() / 1000),
            lpTokenSupply: Math.floor(Date.now() / 1000),
            blockNumber: Math.floor(Date.now() / 1000),
            transactionHash: (0, __1.getRandomBytes32)(),
            timestamp: Math.floor(Date.now() / 1000),
            ...overrides,
        }),
    },
    ethers: {
        receipt: (overrides = {}) => ({
            blockHash: "foo",
            blockNumber: 1,
            byzantium: true,
            confirmations: 5,
            contractAddress: (0, _1.mkAddress)(),
            cumulativeGasUsed: ethers_1.constants.One,
            from: (0, _1.mkAddress)(),
            transactionHash: (0, _1.mkBytes32)(),
            effectiveGasPrice: ethers_1.BigNumber.from(10),
            gasUsed: ethers_1.constants.One,
            to: (0, _1.mkAddress)(),
            logs: [],
            logsBloom: "",
            transactionIndex: 1,
            ...overrides,
        }),
    },
    contracts: {
        deployments: {
            connext: function (_) {
                return {
                    address: (0, _1.mkAddress)("0x123123"),
                    abi: "fakeAbi()",
                };
            },
            relayerProxy: function (_) {
                return {
                    address: (0, _1.mkAddress)("0x123123"),
                    abi: "fakeAbi()",
                };
            },
            priceOracle: function (_) {
                return {
                    address: (0, _1.mkAddress)("0x321321"),
                    abi: "fakeAbi()",
                };
            },
            stableSwap: function (_) {
                return {
                    address: (0, _1.mkAddress)("0x222222"),
                    abi: "fakeAbi()",
                };
            },
            spokeConnector: function (_) {
                return {
                    address: (0, _1.mkAddress)("0x333333"),
                    abi: "fakeAbi()",
                };
            },
            hubConnector: function (_) {
                return {
                    address: (0, _1.mkAddress)("0x444444"),
                    abi: "fakeAbi()",
                };
            },
            multisend: function (_) {
                return {
                    address: (0, _1.mkAddress)("0x555555"),
                    abi: "fakeAbi()",
                };
            },
            unwrapper: function (_) {
                return {
                    address: (0, _1.mkAddress)("0x666666"),
                    abi: "fakeAbi()",
                };
            },
        },
    },
};
//# sourceMappingURL=mock.js.map