"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RouterDailyTVLSchema = exports.SlippageUpdateSchema = exports.RelayerFeesIncreaseSchema = exports.BidStatusSchema = exports.RouterBalanceSchema = exports.AssetBalanceSchema = exports.AssetSchema = exports.ExecuteArgsSchema = exports.XCallArgsSchema = exports.DestinationTransferSchema = exports.OriginTransferSchema = exports.XTransferSchema = exports.TransferIdInformationSchema = exports.XTransferDestinationSchema = exports.XTransferOriginSchema = exports.XTransferMethodCallSchema = exports.XTransferErrorStatus = exports.XTransferStatus = void 0;
const typebox_1 = require("@sinclair/typebox");
const _1 = require(".");
// dear Jake, please stop changing this to enum
exports.XTransferStatus = {
    XCalled: "XCalled",
    Executed: "Executed",
    Reconciled: "Reconciled",
    CompletedFast: "CompletedFast",
    CompletedSlow: "CompletedSlow",
};
exports.XTransferErrorStatus = {
    LowSlippage: "LowSlippage",
    LowRelayerFee: "LowRelayerFee",
    ExecutionError: "ExecutionError",
    NoBidsReceived: "NoBidsReceived",
};
exports.XTransferMethodCallSchema = typebox_1.Type.Object({
    caller: _1.TAddress,
    transactionHash: typebox_1.Type.String(),
    timestamp: typebox_1.Type.Number(),
    gasPrice: _1.TIntegerString,
    gasLimit: _1.TIntegerString,
    blockNumber: typebox_1.Type.Number(),
    txOrigin: typebox_1.Type.Optional(_1.TAddress),
});
exports.XTransferOriginSchema = typebox_1.Type.Object({
    chain: _1.TIntegerString,
    // Event Data
    messageHash: typebox_1.Type.String(),
    // Failure reason
    errorStatus: typebox_1.Type.Optional(typebox_1.Type.Enum(exports.XTransferErrorStatus)),
    // Assets
    assets: typebox_1.Type.Object({
        transacting: typebox_1.Type.Object({
            asset: typebox_1.Type.String(),
            amount: _1.TIntegerString,
        }),
        bridged: typebox_1.Type.Object({
            asset: typebox_1.Type.String(),
            amount: _1.TIntegerString,
        }),
    }),
    relayerFee: _1.TIntegerString,
    // XCall Transaction
    xcall: typebox_1.Type.Intersect([exports.XTransferMethodCallSchema]),
});
exports.XTransferDestinationSchema = typebox_1.Type.Object({
    chain: _1.TIntegerString,
    // Event Data
    status: typebox_1.Type.Enum(exports.XTransferStatus),
    // Both Executed and Reconciled events emit `routers`.
    routers: typebox_1.Type.Array(_1.TAddress),
    updatedSlippage: typebox_1.Type.Optional(_1.TIntegerString),
    // Assets
    assets: typebox_1.Type.Object({
        // Transacting assets only come from Executed event.
        transacting: typebox_1.Type.Optional(typebox_1.Type.Object({
            asset: typebox_1.Type.String(),
            amount: _1.TIntegerString,
        })),
        // Local asset comes from Reconciled and Executed events.
        local: typebox_1.Type.Object({
            asset: typebox_1.Type.String(),
            amount: _1.TIntegerString,
        }),
    }),
    // Execute Transaction
    execute: typebox_1.Type.Optional(typebox_1.Type.Intersect([
        exports.XTransferMethodCallSchema,
        typebox_1.Type.Object({
            // Executed Event Data
            originSender: typebox_1.Type.Optional(_1.TAddress),
        }),
    ])),
    // Reconcile Transaction
    reconcile: typebox_1.Type.Optional(exports.XTransferMethodCallSchema),
});
exports.TransferIdInformationSchema = typebox_1.Type.Object({
    originDomain: typebox_1.Type.String(),
    destinationDomain: typebox_1.Type.String(),
    canonicalDomain: typebox_1.Type.String(),
    to: _1.TAddress,
    delegate: _1.TAddress,
    receiveLocal: typebox_1.Type.Boolean(),
    callData: typebox_1.Type.String(),
    slippage: _1.TIntegerString,
    originSender: _1.TAddress,
    bridgedAmt: typebox_1.Type.String(),
    normalizedIn: _1.TIntegerString,
    nonce: typebox_1.Type.Number(),
    canonicalId: typebox_1.Type.String(),
});
exports.XTransferSchema = typebox_1.Type.Intersect([
    typebox_1.Type.Object({
        transferId: typebox_1.Type.String(),
        // Call Params
        // NOTE: TransferInfo is emitted by XCalled and Executed events, but not Reconciled event.
        xparams: exports.TransferIdInformationSchema,
    }),
    typebox_1.Type.Object({
        origin: typebox_1.Type.Optional(exports.XTransferOriginSchema),
        destination: typebox_1.Type.Optional(exports.XTransferDestinationSchema),
    }),
]);
exports.OriginTransferSchema = typebox_1.Type.Intersect([
    typebox_1.Type.Object({
        transferId: typebox_1.Type.String(),
        xparams: exports.TransferIdInformationSchema,
    }),
    typebox_1.Type.Object({
        origin: exports.XTransferOriginSchema,
        destination: typebox_1.Type.Optional(exports.XTransferDestinationSchema),
    }),
]);
exports.DestinationTransferSchema = typebox_1.Type.Intersect([
    typebox_1.Type.Object({
        transferId: typebox_1.Type.String(),
        xparams: typebox_1.Type.Object({
            originDomain: typebox_1.Type.String(),
            destinationDomain: typebox_1.Type.String(),
            canonicalDomain: typebox_1.Type.String(),
            to: _1.TAddress,
            delegate: _1.TAddress,
            receiveLocal: typebox_1.Type.Boolean(),
            callData: typebox_1.Type.String(),
            slippage: typebox_1.Type.Optional(_1.TIntegerString),
            originSender: _1.TAddress,
            bridgedAmt: typebox_1.Type.String(),
            normalizedIn: _1.TIntegerString,
            amount: _1.TIntegerString,
            nonce: typebox_1.Type.Optional(typebox_1.Type.Number()),
            canonicalId: typebox_1.Type.String(),
        }),
    }),
    typebox_1.Type.Object({
        origin: typebox_1.Type.Optional(exports.XTransferOriginSchema),
        destination: exports.XTransferDestinationSchema,
    }),
]);
exports.XCallArgsSchema = typebox_1.Type.Object({
    destination: typebox_1.Type.String(),
    to: _1.TAddress,
    asset: _1.TAddress,
    delegate: _1.TAddress,
    amount: _1.TIntegerString,
    slippage: _1.TIntegerString,
    callData: typebox_1.Type.String(),
});
exports.ExecuteArgsSchema = typebox_1.Type.Object({
    params: exports.TransferIdInformationSchema,
    routers: typebox_1.Type.Array(_1.TAddress),
    routerSignatures: typebox_1.Type.Array(typebox_1.Type.String()),
    sequencer: _1.TAddress,
    sequencerSignature: typebox_1.Type.String(),
});
exports.AssetSchema = typebox_1.Type.Object({
    id: _1.TAddress,
    key: typebox_1.Type.String(),
    adoptedAsset: _1.TAddress,
    canonicalId: typebox_1.Type.String(),
    canonicalDomain: typebox_1.Type.String(),
    localAsset: _1.TAddress,
    blockNumber: typebox_1.Type.String(),
});
exports.AssetBalanceSchema = typebox_1.Type.Intersect([
    exports.AssetSchema,
    typebox_1.Type.Object({
        balance: _1.TIntegerString,
        feesEarned: _1.TIntegerString,
        domain: typebox_1.Type.String(),
    }),
]);
exports.RouterBalanceSchema = typebox_1.Type.Object({ router: _1.TAddress, assets: typebox_1.Type.Array(exports.AssetBalanceSchema) });
exports.BidStatusSchema = typebox_1.Type.Object({
    timestamp: typebox_1.Type.String(),
    attempts: typebox_1.Type.Number(),
});
exports.RelayerFeesIncreaseSchema = typebox_1.Type.Object({
    id: typebox_1.Type.String(),
    transferId: _1.TBytes32,
    increase: _1.TIntegerString,
    domain: typebox_1.Type.String(),
    timestamp: _1.TIntegerString,
});
exports.SlippageUpdateSchema = typebox_1.Type.Object({
    id: typebox_1.Type.String(),
    transferId: _1.TBytes32,
    slippage: _1.TIntegerString,
    domain: typebox_1.Type.String(),
    timestamp: typebox_1.Type.Number(),
});
exports.RouterDailyTVLSchema = typebox_1.Type.Object({
    id: typebox_1.Type.String(),
    asset: _1.TAddress,
    router: _1.TAddress,
    domain: typebox_1.Type.String(),
    timestamp: typebox_1.Type.Number(),
    balance: _1.TIntegerString,
});
//# sourceMappingURL=xtransfers.js.map