"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateExitPayload = void 0;
const __1 = require("..");
/**
 * generateExitPayload
 * @param {String} domain
 * @param {String} mirrorDomain
 * @param {String} burnTxHash
 * @param {String} eventSignature
 * @param {Map<String, string[]>} providers
 * @returns {string}
 */
const generateExitPayload = async (domain, mirrorDomain, burnTxHash, eventSignature, providers) => {
    const allChainData = await (0, __1.getChainData)();
    if (!allChainData.has(domain)) {
        throw new Error(`ChainData doesn't have a record for domain: ${domain}`);
    }
    if (!allChainData.has(mirrorDomain)) {
        throw new Error(`ChainData doesn't have a record for mirrorDomain: ${mirrorDomain}`);
    }
    const chainData = allChainData.get(domain);
    const mirrorChainData = allChainData.get(mirrorDomain);
    const isMainnet = chainData.type === "mainnet";
    const maticRPC = providers?.get(domain) ?? chainData.rpc;
    const ethereumRPC = providers?.get(mirrorDomain) ?? mirrorChainData.rpc;
    const rpcLength = Math.min(maticRPC.length, ethereumRPC.length);
    const maxRetries = rpcLength * 2;
    const initialRpcIndex = 0;
    let result;
    let isCheckpointed;
    // loop over rpcs to retry in case of an in case of an rpc error
    for (let i = 0; i < maxRetries; i++) {
        const rpcIndex = (initialRpcIndex + i) % rpcLength;
        try {
            // initialize matic client
            const maticClient = await (0, __1.initMatic)(isMainnet, maticRPC[rpcIndex], ethereumRPC[rpcIndex]);
            // check for checkpoint
            try {
                // Checking for checkpoint status
                isCheckpointed = await maticClient.exitUtil.isCheckPointed(burnTxHash);
            }
            catch (error) {
                if (i === maxRetries - 1) {
                    throw new __1.InfoError(__1.MaticJsErrorType.IncorrectTx, "Incorrect burn transaction");
                }
                throw new Error("Null receipt received");
            }
            if (!isCheckpointed) {
                throw new __1.InfoError(__1.MaticJsErrorType.TxNotCheckpointed, "Burn transaction has not been checkpointed yet");
            }
            // build payload for exit
            try {
                result = await maticClient.exitUtil.buildPayloadForExit(burnTxHash, eventSignature, false);
            }
            catch (error) {
                if (error?.message === "Index is grater than the number of tokens in this transaction") {
                    throw new __1.InfoError(__1.MaticJsErrorType.BlockNotIncluded, error.message);
                }
                if (i === maxRetries - 1) {
                    throw new __1.InfoError(__1.MaticJsErrorType.BlockNotIncluded, "Event Signature log not found in tx receipt");
                }
                throw new Error("Null receipt received");
            }
            if (!result) {
                throw new Error("Null result received");
            }
            break;
        }
        catch (error) {
            if (error.type === __1.MaticJsErrorType.TxNotCheckpointed ||
                error.type === __1.MaticJsErrorType.IncorrectTx ||
                error.type === __1.MaticJsErrorType.BlockNotIncluded ||
                i === maxRetries - 1) {
                throw error;
            }
        }
    }
    return result;
};
exports.generateExitPayload = generateExitPayload;
//# sourceMappingURL=proof.js.map