"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGelatoOracles = exports.isOracleActive = exports.getConversionRate = exports.getGelatoEstimatedFee = exports.GELATO_RELAYER_ADDRESS = exports.GELATO_SERVER = void 0;
const ethers_1 = require("ethers");
const interval_promise_1 = __importDefault(require("interval-promise"));
const helpers_1 = require("../helpers");
const types_1 = require("../types");
exports.GELATO_SERVER = "https://relay.gelato.digital";
exports.GELATO_RELAYER_ADDRESS = "0xaBcC9b596420A9E9172FD5938620E265a0f9Df92";
const getGelatoEstimatedFee = async (_chainId, paymentToken, gasLimit, isHighPriority, logger) => {
    let result = ethers_1.BigNumber.from("0");
    const params = { paymentToken, gasLimit, isHighPriority };
    const chainId = EquivalentChainsForGelato[_chainId] ?? _chainId;
    try {
        const res = await (0, helpers_1.axiosGet)(`${exports.GELATO_SERVER}/oracles/${chainId}/estimate`, { params });
        result = ethers_1.BigNumber.from(res.data.estimatedFee);
    }
    catch (error) {
        if (logger)
            logger.error("Error in getGelatoEstimatedFee", undefined, undefined, (0, types_1.jsonifyError)(error));
    }
    return result;
};
exports.getGelatoEstimatedFee = getGelatoEstimatedFee;
/// MARK - This is used for testnets which aren't being supported by gelato
const EquivalentChainsForGelato = {
    4: 1,
    5: 1,
    1337: 1,
    1338: 1,
    13337: 1,
    13338: 1,
    420: 1,
    80001: 137,
    421613: 1,
    10200: 100,
    97: 56, // chapel (bnb testnet)
};
/**
 * Get the conversion rate from the native token to the requested token
 * @param _chainId - The Id of chain where the conversion rate is estimated
 * @param to - The token address in which the conversion rate is estimated from the native token of the selected chain.
 *    If a value is not provided, it will default to the USDC address on the selected chain
 * @param logger - The logger instance
 * @returns The conversion rate in number
 */
const getConversionRate = async (_chainId, to, logger) => {
    let result = 0;
    const chainId = EquivalentChainsForGelato[_chainId] ?? _chainId;
    let apiEndpoint = `${exports.GELATO_SERVER}/oracles/${chainId}/conversionRate`;
    if (to) {
        apiEndpoint = apiEndpoint.concat(`/to=${to}`);
    }
    let totalRetries = 5;
    const retryInterval = 2000;
    await new Promise((res) => {
        (0, interval_promise_1.default)(async (_, stop) => {
            if (totalRetries === 0) {
                stop();
                res(undefined);
            }
            try {
                totalRetries--;
                const axiosRes = await (0, helpers_1.axiosGet)(apiEndpoint);
                result = axiosRes.data.conversionRate;
                if (result > 0) {
                    stop();
                    res(undefined);
                }
            }
            catch (error) {
                if (logger)
                    logger.error(`Error in getConversionRate. Retrying in ${retryInterval} ms`, undefined, undefined, (0, types_1.jsonifyError)(error));
            }
        }, retryInterval);
    });
    try {
        const res = await (0, helpers_1.axiosGet)(apiEndpoint);
        result = res.data.conversionRate;
    }
    catch (error) {
        if (logger)
            logger.error("Error in getConversionRate", undefined, undefined, (0, types_1.jsonifyError)(error));
    }
    return result;
};
exports.getConversionRate = getConversionRate;
const isOracleActive = async (chainId) => {
    const oracles = await (0, exports.getGelatoOracles)();
    return oracles.includes(chainId.toString());
};
exports.isOracleActive = isOracleActive;
const getGelatoOracles = async (logger) => {
    let result = [];
    try {
        const res = await (0, helpers_1.axiosGet)(`${exports.GELATO_SERVER}/oracles/`);
        result = res.data.oracles;
    }
    catch (error) {
        if (logger)
            logger.error("Error in getGelatoOracles", undefined, undefined, (0, types_1.jsonifyError)(error));
    }
    return result;
};
exports.getGelatoOracles = getGelatoOracles;
//# sourceMappingURL=gelato.js.map