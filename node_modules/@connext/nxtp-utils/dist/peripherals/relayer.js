"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateRelayerFee = void 0;
const ethers_1 = require("ethers");
const constants_1 = require("../constants");
const helpers_1 = require("../helpers");
const logging_1 = require("../logging");
const gelato_1 = require("./gelato");
const relayerBufferPercentage = 20; // 20% bump on total estimated relayer fee
const calculateRelayerFee = async (params, chainData, logger, _requestContext) => {
    const { requestContext, methodContext } = (0, logging_1.createLoggingContext)(exports.calculateRelayerFee.name, _requestContext);
    if (logger) {
        logger.info("Method Start", requestContext, methodContext, { params });
    }
    const { originDomain, destinationDomain, callDataGasAmount, originNativeToken: _originNativeToken, destinationNativeToken: _destinationNativeToken, isHighPriority: _isHighPriority, getGasPriceCallback, } = params;
    const originNativeToken = _originNativeToken ?? ethers_1.constants.AddressZero;
    const destinationNativeToken = _destinationNativeToken ?? ethers_1.constants.AddressZero;
    const isHighPriority = _isHighPriority ?? false;
    const originChainId = await (0, helpers_1.getChainIdFromDomain)(originDomain, chainData);
    const destinationChainId = await (0, helpers_1.getChainIdFromDomain)(destinationDomain, chainData);
    // fetch executeGasAmount from chainData
    const { execute: executeGasAmount, executeL1: executeL1GasAmount, gasPriceFactor, } = await (0, constants_1.getHardcodedGasLimits)(destinationDomain, chainData);
    if (logger) {
        logger.debug("Hardcoded gasLimits", requestContext, methodContext, {
            execute: executeGasAmount,
            executeL1: executeL1GasAmount,
            gasPriceFactor,
        });
    }
    const totalGasAmount = callDataGasAmount
        ? Number(executeGasAmount) + Number(callDataGasAmount)
        : Number(executeGasAmount);
    let estimatedRelayerFee = await (0, gelato_1.getGelatoEstimatedFee)(destinationChainId, destinationNativeToken, Number(totalGasAmount), isHighPriority);
    if (!estimatedRelayerFee || (estimatedRelayerFee == ethers_1.BigNumber.from("0") && getGasPriceCallback)) {
        let gasPrice = ethers_1.BigNumber.from(0);
        try {
            gasPrice = await getGasPriceCallback(Number(params.destinationDomain));
            estimatedRelayerFee = ethers_1.BigNumber.from(totalGasAmount).mul(gasPrice);
        }
        catch (e) {
            if (logger) {
                logger.warn("Error getting GasPrice", requestContext, methodContext, {
                    error: e,
                    domain: params.destinationDomain,
                });
                return ethers_1.BigNumber.from(0);
            }
        }
    }
    if (destinationChainId == 10) {
        // consider l1gas for optimism network
        if (logger) {
            const l1EstimatedRelayerFee = await (0, gelato_1.getGelatoEstimatedFee)(1, ethers_1.constants.AddressZero, Number(executeL1GasAmount), isHighPriority);
            logger.info("Adding l1Gas", requestContext, methodContext, {
                executeGasAmount,
                executeL1GasAmount,
                l1EstimatedRelayerFee: l1EstimatedRelayerFee.toString(),
            });
            estimatedRelayerFee = ethers_1.BigNumber.from(estimatedRelayerFee).add(l1EstimatedRelayerFee);
        }
    }
    if (logger) {
        logger.info("Estimate Relayer Fee", requestContext, methodContext, {
            originNativeToken,
            originChainId,
            destinationNativeToken,
            destinationChainId,
            executeGasAmount,
            callDataGasAmount,
        });
    }
    // add relayerFee bump to estimatedRelayerFee
    const bumpedFee = estimatedRelayerFee.add(estimatedRelayerFee.mul(ethers_1.BigNumber.from(relayerBufferPercentage)).div(100));
    const [originTokenPrice, destinationTokenPrice, originTokenDecimals, destinationTokenDecimals] = await Promise.all([
        (0, gelato_1.getConversionRate)(originChainId, undefined, undefined),
        (0, gelato_1.getConversionRate)(destinationChainId, undefined, undefined),
        (0, helpers_1.getDecimalsForAsset)(originNativeToken, originChainId, undefined, chainData),
        (0, helpers_1.getDecimalsForAsset)(destinationNativeToken, destinationChainId, undefined, chainData),
    ]);
    if (originTokenPrice == 0 || destinationTokenPrice == 0) {
        return ethers_1.BigNumber.from(0);
    }
    // converstion rate is float-point number. we multiply by 1000 to be more precise
    const impactedOriginTokenPrice = Math.floor(originTokenPrice * 1000);
    const impactedDestinationTokenPrice = Math.floor(destinationTokenPrice * 1000);
    const relayerFeeInOrginNativeAsset = originTokenDecimals >= destinationTokenDecimals
        ? bumpedFee
            .mul(impactedDestinationTokenPrice)
            .div(impactedOriginTokenPrice)
            .mul(ethers_1.BigNumber.from(10).pow(originTokenDecimals - destinationTokenDecimals))
        : bumpedFee
            .mul(impactedDestinationTokenPrice)
            .div(impactedOriginTokenPrice)
            .div(ethers_1.BigNumber.from(10).pow(destinationTokenDecimals - originTokenDecimals));
    if (logger) {
        logger.info("Fee estimation completed!", requestContext, methodContext, {
            bumpedFee: bumpedFee.toString(),
            originTokenPrice,
            destinationTokenPrice,
            relayerFeeInOrginNativeAsset: relayerFeeInOrginNativeAsset.toString(),
        });
    }
    return relayerFeeInOrginNativeAsset;
};
exports.calculateRelayerFee = calculateRelayerFee;
//# sourceMappingURL=relayer.js.map