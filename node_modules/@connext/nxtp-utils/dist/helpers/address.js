"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAndParseAddress = exports.compressPublicKey = exports.getAddressFromPublicKey = void 0;
const ethers_1 = require("ethers");
const secp256k1_1 = require("secp256k1");
/**
 * Function to derive the address from an EC public key
 *
 * @param publicKey the public key to derive
 *
 * @returns the address
 */
const getAddressFromPublicKey = (publicKey) => {
    try {
        return ethers_1.utils.computeAddress((0, exports.compressPublicKey)(publicKey));
    }
    catch (e) {
        throw new Error(`Invalid public key, errorMsg: ${e.toString()}`);
    }
};
exports.getAddressFromPublicKey = getAddressFromPublicKey;
/**
 * Converts a public key to its compressed form.
 */
const compressPublicKey = (publicKey) => {
    publicKey = publicKey.replace(/^0x/, "");
    // if there are more bytes than the key itself, it means there is already a prefix
    if (publicKey.length % 32 === 0) {
        publicKey = `04${publicKey}`;
    }
    return (0, secp256k1_1.publicKeyConvert)(Buffer.from(publicKey, "hex"));
};
exports.compressPublicKey = compressPublicKey;
/**
 * Validates an address and returns the parsed (checksummed) version of that address
 *
 * @param address the unchecksummed hex address
 * @returns The checksummed address
 */
function validateAndParseAddress(address) {
    try {
        return ethers_1.utils.getAddress(address);
    }
    catch (error) {
        throw new Error(`${address} is not a valid address.`);
    }
}
exports.validateAndParseAddress = validateAndParseAddress;
//# sourceMappingURL=address.js.map