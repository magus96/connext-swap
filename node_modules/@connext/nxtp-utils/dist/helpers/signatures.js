"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.recoverRouterPathPayload = exports.getRouterPathHashToSign = exports.signRouterPathPayload = exports.signSequencerPermitPayload = exports.sign = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const _1 = require(".");
/**
 * Occasionally have seen metamask return signatures with v = 00 or v = 01.
 * Signatures having these values will revert when used onchain. Ethers handles
 * these cases in the `splitSignature` function, where it regenerates an
 * appropriate `v` value:
 * https://github.com/ethers-io/ethers.js/blob/c2c0ce75039e7256b287f9a764188d08ed0b7296/packages/bytes/src.ts/index.ts#L348-L355
 *
 * This function will rely on the edgecase handling there to ensure any
 * signatures are properly formatted. This has been tested manually against
 * offending signatures.
 *
 * @param sig Signature to sanitize
 */
const sanitizeSignature = (sig) => {
    if (sig.endsWith("1c") || sig.endsWith("1b")) {
        return sig;
    }
    // Must be sanitized
    const { v } = (0, utils_1.splitSignature)(sig);
    const hex = ethers_1.BigNumber.from(v).toHexString();
    return sig.slice(0, sig.length - 2) + hex.slice(2);
};
const sign = async (hash, signer) => {
    const msg = (0, utils_1.arrayify)(hash);
    const addr = await signer.getAddress();
    if (typeof signer.provider?.send === "function") {
        try {
            return sanitizeSignature((await signer.provider.send("personal_sign", [hash, addr])));
        }
        catch (err) {
            // console.error("Error using personal_sign, falling back to signer.signMessage: ", err);
        }
    }
    return sanitizeSignature(await signer.signMessage(msg));
};
exports.sign = sign;
/**
 * Generates a signature on the transfer ID and routers array payload for the `execute` transaction.
 * Permit represents a (allowlisted) sequencer's indication that they were responsible for assigning
 * this path of routers to this particular transfer.
 *
 * @param transferId - The ID of the transfer.
 * @param routers - The addresses of the routers that are supplying fast liquidity for the transfer.
 * @param signer - The Wallet / Signer of the signing sequencer.
 * @returns Signature of the payload from the signer.
 */
const signSequencerPermitPayload = async (transferId, routers, signer) => {
    const payload = (0, _1.encodeSequencerPermitPayload)(transferId, routers);
    const hash = (0, utils_1.solidityKeccak256)(["bytes"], [payload]);
    return await (0, exports.sign)(hash, signer);
};
exports.signSequencerPermitPayload = signSequencerPermitPayload;
/**
 * Generates a signature on the router path length payload in `execute` transaction. Represents
 * consent of the signing router to use a portion of their liquidity (minus a fee) to `execute` the
 * transfer.
 *
 * @param transferId - The ID of the transfer.
 * @param pathLength - The number of routers that are supplying fast liquidity for the transfer.
 * @param signer - The Wallet / Signer of the signing router.
 * @returns Signature of the payload from the signer.
 */
const signRouterPathPayload = async (transferId, pathLength, signer) => {
    const hash = (0, exports.getRouterPathHashToSign)(transferId, pathLength);
    return await (0, exports.sign)(hash, signer);
};
exports.signRouterPathPayload = signRouterPathPayload;
/**
 * Generates a hash to sign of the router path length payload in `execute` transaction
 *
 * @param transferId - The nonce of the origin domain at the time the transaction was prepared. Used to generate
 * the transaction id for the crosschain transaction
 * @param pathLength - The number of routers in transfer
 * @returns Hash that should be signed
 */
const getRouterPathHashToSign = (transferId, pathLength) => {
    const payload = (0, _1.encodeRouterPathPayload)(transferId, pathLength);
    const hash = (0, utils_1.solidityKeccak256)(["bytes"], [payload]);
    return hash;
};
exports.getRouterPathHashToSign = getRouterPathHashToSign;
/**
 * Returns the recovered signer from the router path length payload
 *
 * @param transferId - The transferId generated on the origin domain
 * @param pathLength - The number of routers in transfer
 * @returns Recovered address of signer
 */
const recoverRouterPathPayload = (transferId, pathLength, signature) => {
    const hashed = (0, exports.getRouterPathHashToSign)(transferId, pathLength);
    return (0, utils_1.verifyMessage)((0, utils_1.arrayify)(hashed), signature);
};
exports.recoverRouterPathPayload = recoverRouterPathPayload;
//# sourceMappingURL=signatures.js.map