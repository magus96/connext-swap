"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCanonicalHash = exports.getExternalCallHash = exports.encodeExternalCallData = exports.getReconciledHash = exports.encodeReconcileData = exports.encodeRouterPathPayload = exports.encodeSequencerPermitPayload = exports.ReconciledTransactionDataEncoding = exports.ExternalCallDataEncoding = exports.SignedRouterPathEncoding = exports.tidy = void 0;
const utils_1 = require("ethers/lib/utils");
const __1 = require("..");
/**
 * Cleans any strings so they replace the newlines and properly format whitespace. Used to translate human readable encoding to contract-compatible encoding.
 *
 * @param str String to clean
 * @returns Cleaned version of the input
 */
const tidy = (str) => `${str.replace(/\n/g, "").replace(/ +/g, " ")}`;
exports.tidy = tidy;
exports.SignedRouterPathEncoding = (0, exports.tidy)(`tuple(
  bytes32 transferId,
  uint256 pathLength
)`);
exports.ExternalCallDataEncoding = (0, exports.tidy)(`tuple(
  address to,
  bytes callData
)`);
exports.ReconciledTransactionDataEncoding = (0, exports.tidy)(`tuple(
  bytes32 externalHash,
  address local,
  uint256 amount,
  address recipient
)`);
/**
 * Encodes a sequencer payload object, as defined in the BridgeFacet contract.
 *
 * @param transferId - The ID of the transfer.
 * @param routers - The addresses of the routers in the path.
 * @returns Encoded sequencer permit payload.
 */
const encodeSequencerPermitPayload = (transferId, routers) => {
    return utils_1.defaultAbiCoder.encode(["bytes32", "address[]"], [transferId, routers]);
};
exports.encodeSequencerPermitPayload = encodeSequencerPermitPayload;
/**
 * Encodes a router path payload object, as defined in the BridgeFacet contract.
 *
 * @param transferId - The ID of the transfer.
 * @param pathLength - The number of routers in the path.
 * @returns Encoded router path payload.
 */
const encodeRouterPathPayload = (transferId, pathLength) => {
    return utils_1.defaultAbiCoder.encode([exports.SignedRouterPathEncoding], [{ transferId, pathLength }]);
};
exports.encodeRouterPathPayload = encodeRouterPathPayload;
/**
 * Encodes a reconcile transaction payload object, as defined in the Connext contract
 *
 * @param externalHash - Hash of the `ExternalCall`
 * @param local - The address of the bridged asset
 * @param amount - The amount forwarded through the bridge
 * @param recipient - The address that gets the funds on the destination chain
 * @returns Encoded reconcile transaction payload
 */
const encodeReconcileData = (reconcileData) => {
    return utils_1.defaultAbiCoder.encode([exports.ReconciledTransactionDataEncoding], [reconcileData]);
};
exports.encodeReconcileData = encodeReconcileData;
/**
 * Hashes ReconciledData payload object
 *
 * @param reconciledData Object to encode and hash
 * @returns Hash of encode object
 */
const getReconciledHash = (reconciledData) => {
    const digest = (0, utils_1.keccak256)(utils_1.defaultAbiCoder.encode([exports.ReconciledTransactionDataEncoding], [reconciledData]));
    return digest;
};
exports.getReconciledHash = getReconciledHash;
/**
 * Encodes an external call transaction payload object, as defined in the Connext contract
 *
 * @param recipient - The address that should receive the funds on the destination domain if no call is
 * specified, or the fallback if an external call fails
 * @param callTo - The address of the receiving chain to execute the `callData` on
 * @param callData - The data to execute on the receiving chain
 * @returns Encoded exteranl call payload
 */
const encodeExternalCallData = (exteranalCallData) => {
    return utils_1.defaultAbiCoder.encode([exports.ExternalCallDataEncoding], [exteranalCallData]);
};
exports.encodeExternalCallData = encodeExternalCallData;
/**
 * Hashes ExternalCall payload object
 *
 * @param externalCallData Object to encode and hash
 * @returns Hash of encoded object
 */
const getExternalCallHash = (externalCallData) => {
    const digest = (0, utils_1.keccak256)(utils_1.defaultAbiCoder.encode([exports.ExternalCallDataEncoding], [externalCallData]));
    return digest;
};
exports.getExternalCallHash = getExternalCallHash;
const getCanonicalHash = (canonicalDomain, _canonicalId) => {
    const canonicalId = (0, utils_1.hexlify)((0, __1.canonizeId)(_canonicalId));
    const payload = utils_1.defaultAbiCoder.encode(["tuple(bytes32 canonicalId,uint32 canonicalDomain)"], [{ canonicalId, canonicalDomain }]);
    return (0, utils_1.solidityKeccak256)(["bytes"], [payload]);
};
exports.getCanonicalHash = getCanonicalHash;
//# sourceMappingURL=encode.js.map