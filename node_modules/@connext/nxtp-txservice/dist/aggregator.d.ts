import { Logger, RequestContext } from "@connext/nxtp-utils";
import { BigNumber, Signer, providers } from "ethers";
import { ChainConfig } from "./config";
import { ReadTransaction, SyncProvider, OnchainTransaction, WriteTransaction } from "./shared";
/**
 * @classdesc An aggregator for all the providers that are used to make RPC calls on a specified chain. Only
 * 1 aggregator should exist per chain. Responsible for provider fallback capabilities, syncing, and caching.
 */
export declare class RpcProviderAggregator {
    protected readonly logger: Logger;
    readonly domain: number;
    protected readonly config: ChainConfig;
    private readonly providers;
    leadProvider: SyncProvider | undefined;
    readonly fallbackProvider: providers.FallbackProvider;
    private readonly signer?;
    private lastUsedGasPrice;
    private cachedDecimals;
    private blockPeriod;
    private cache;
    /**
     * A class for managing the usage of an ethers FallbackProvider, and for wrapping calls in
     * retries. Will ensure provider(s) are ready before any use case.
     *
     * @param logger - Logger used for logging.
     * @param signer - Signer instance or private key used for signing transactions.
     * @param domain - The ID of the chain for which this class's providers will be servicing.
     * @param chainConfig - Configuration for this specified chain, including the providers we'll
     * be using for it.
     * @param config - The shared TransactionServiceConfig with general configuration.
     *
     * @throws ChainError.reasons.ProviderNotFound if no valid providers are found in the
     * configuration.
     */
    constructor(logger: Logger, domain: number, config: ChainConfig, signer?: string | Signer);
    /**
     * Send the transaction request to the provider.
     *
     * @remarks This method is set to access protected since it should really only be used by the inheriting class,
     * TransactionDispatch, as of the time of writing this.
     *
     * @param tx The transaction used for the request.
     *
     * @returns The ethers TransactionResponse.
     */
    protected sendTransaction(transaction: OnchainTransaction): Promise<providers.TransactionResponse>;
    /**
     * Get the receipt for the transaction with the specified hash, optionally blocking
     * until a specified timeout.
     *
     * @param hash - The hexadecimal hash string of the transaction.
     * @param confirmations - Optional parameter to override the configured number of confirmations
     * required to validate the receipt.
     * @param timeout - Optional timeout parameter in ms to override the configured parameter.
     *
     * @returns The ethers TransactionReceipt, if mined, otherwise null.
     */
    confirmTransaction(transaction: OnchainTransaction, confirmations?: number, timeout?: number): Promise<providers.TransactionReceipt>;
    /**
     * Execute a read transaction using the passed in transaction data, which includes
     * the target contract which we are reading from.
     *
     * @param tx - Minimal transaction data needed to read from chain.
     * @param blockTag - Block number to look at, defaults to latest
     *
     * @returns A string of data read from chain.
     * @throws ChainError.reasons.ContractReadFailure in the event of a failure
     * to read from chain.
     */
    readContract(tx: ReadTransaction, blockTag?: providers.BlockTag): Promise<string>;
    /**
     * Get the onchain transaction corresponding with the given hash.
     *
     * @param tx - Either the string hash of the transaction to retrieve, or the OnchainTransaction object.
     *
     * @returns An array of TransactionResponses (the transaction data), or null. If the array is all null, then the
     * transaction and any/all replacements could not be found. Only 1 element in the array should ever be not null.
     */
    getTransaction(tx: string | OnchainTransaction): Promise<(providers.TransactionResponse | null)[]>;
    /**
     * Estimate gas cost for the specified transaction.
     *
     * @remarks
     *
     * Because estimateGas is almost always our "point of failure" - the point where its
     * indicated by the provider that our tx would fail on chain - and ethers obscures the
     * revert error code when it fails through its typical API, we had to implement our own
     * estimateGas call through RPC directly.
     *
     * @param transaction - The ethers TransactionRequest data in question.
     *
     * @returns A BigNumber representing the estimated gas value.
     */
    estimateGas(transaction: providers.TransactionRequest): Promise<BigNumber>;
    /**
     * Get the current gas price for the chain for which this instance is servicing.
     *
     * @param context - RequestContext instance in which we are executing this method.
     * @param useInitialBoost (default: true) - boolean indicating whether to use the configured initial boost
     * percentage value.
     *
     * @returns The BigNumber value for the current gas price.
     */
    getGasPrice(context: RequestContext, useInitialBoost?: boolean): Promise<BigNumber>;
    /**
     * Get the current balance for the specified address.
     *
     * @param address - The hexadecimal string address whose balance we are getting.
     * @param assetId - The ID (address) of the asset whose balance we are getting.
     * @param abi (default = ERC20) - The ABI of the token contract to use, if non-native token.
     *
     * @returns A BigNumber representing the current value held by the wallet at the
     * specified address.
     */
    getBalance(address: string, assetId: string, abi?: string[]): Promise<BigNumber>;
    /**
     * Get the decimals for the ERC20 token contract.
     *
     * @param address The hexadecimal string address of the asset.
     *
     * @returns A number representing the current decimals.
     */
    getDecimalsForAsset(assetId: string): Promise<number>;
    /**
     * Gets the current block number.
     *
     * @returns A number representing the current block number.
     */
    getBlock(blockHashOrBlockTag: providers.BlockTag | Promise<providers.BlockTag>): Promise<providers.Block>;
    /**
     * Gets the current blocktime.
     *
     * @param blockTag (default: "latest") - The block tag to get the blocktime for, could be a block number or a block hash.
     * By default, this will get the current blocktime.
     *
     * @returns A number representing the current blocktime.
     */
    getBlockTime(blockTag?: string): Promise<number>;
    /**
     * Gets the current block number.
     *
     * @returns A number representing the current block number.
     */
    getBlockNumber(): Promise<number>;
    /**
     * Gets the signer's address.
     *
     * @returns A hash string address belonging to the signer.
     */
    getAddress(): Promise<string>;
    /**
     * Retrieves a transaction's receipt by the transaction hash.
     *
     * @param hash - the transaction hash to get the receipt for.
     *
     * @returns A TransactionReceipt instance.
     */
    getTransactionReceipt(hash: string): Promise<providers.TransactionReceipt>;
    /**
     * Returns a hexcode string representation of the contract code at the given
     * address. If there is no contract deployed at the given address, returns "0x".
     *
     * @param address - contract address.
     *
     * @returns Hexcode string representation of contract code.
     */
    getCode(address: string): Promise<string>;
    /**
     * Checks estimate for gas limit for given transaction on given chain.
     *
     * @param tx - transaction to check gas limit for.
     *
     * @returns BigNumber representing the estimated gas limit in gas units.
     * @throws Error if the transaction is invalid, or would be reverted onchain.
     */
    getGasEstimate(tx: ReadTransaction | WriteTransaction): Promise<BigNumber>;
    /**
     * Gets the current transaction count.
     *
     * @param blockTag (default: "latest") - The block tag to get the transaction count for. Use "latest" mined-only transactions.
     * Use "pending" for transactions that have not been mined yet, but will (supposedly) be mined in the pending
     * block (essentially, transactions included in the mempool, but this behavior is not consistent).
     *
     * @returns Number of transactions sent AKA the current nonce.
     */
    getTransactionCount(blockTag?: string): Promise<number>;
    /**
     * A helper to throw a custom error if the method requires a signer but no signer has
     * been injected into the provider.
     *
     * @throws NxtpError if signer is required and not provided.
     */
    private checkSigner;
    /**
     * The RPC method execute wrapper is used for wrapping and parsing errors, as well as ensuring that
     * providers are ready before any call is made. Also used for executing multiple retries for RPC
     * requests to providers. This is to circumvent any issues related to unreliable internet/network
     * issues, whether locally, or externally (for the provider's network).
     *
     * @param method - The method callback to execute and wrap in retries.
     * @returns The object of the specified generic type.
     * @throws NxtpError if the method fails to execute.
     */
    private execute;
    /**
     * Callback method used for handling a block update from synchronized providers.
     *
     * @remarks
     * Since being "in-sync" is actually a relative matter, it's possible to have all providers
     * be out of sync (e.g. 100 blocks behind the current block in reality), but also have them
     * be considered in-sync here, since we only use the highest block among our providers to determine
     * the "true" current block.
     *
     *
     * @param provider - SyncProvider instance this block update applies to.
     * @param blockNumber - Current block number (according to the provider).
     * @param url - URL of the provider.
     * @returns boolean indicating whether the provider is in sync.
     */
    protected syncProviders(): Promise<void>;
    /**
     * Helper method to stall, possibly until we've surpassed a specified number of blocks. Only works
     * with block number if we're running in synchronized mode.
     *
     * @param numBlocks (default: 1) - the number of blocks to wait.
     */
    private wait;
    /**
     * Helper method for getting tier-shuffled synced providers.
     *
     * @returns all in-sync providers in order of synchronicity with chain, with the lead provider
     * in the first position and the rest shuffled by tier (lag).
     */
    private shuffleSyncedProviders;
    private setBlockPeriod;
}
//# sourceMappingURL=aggregator.d.ts.map