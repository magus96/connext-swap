import { Signer, providers, BigNumber, utils } from "ethers";
import { Logger, RequestContext } from "@connext/nxtp-utils";
import { TransactionServiceConfig } from "./config";
import { ReadTransaction, WriteTransaction, MultireadTransaction } from "./shared";
import { RpcProviderAggregator } from "./aggregator";
export declare const cachedPriceMap: Map<string, {
    timestamp: number;
    price: BigNumber;
}>;
/**
 * @classdesc Performs onchain reads with embedded retries.
 */
export declare class ChainReader {
    protected readonly logger: Logger;
    protected providers: Map<number, RpcProviderAggregator>;
    protected readonly config: TransactionServiceConfig;
    /**
     * A singleton-like interface for handling all logic related to conducting on-chain transactions.
     *
     * @remarks
     * Using the Signer instance passed into this constructor outside of the context of this
     * class is not recommended, and may cause issues with nonce being tracked improperly
     * due to the caching mechanisms used here.
     *
     * @param logger The Logger used for logging.
     * @param signer The Signer or Wallet instance, or private key, for signing transactions.
     * @param config At least a partial configuration used by TransactionService for chains,
     * providers, etc.
     */
    constructor(logger: Logger, config: any, signer?: string | Signer);
    /**
     * Create a non-state changing contract call. Returns hexdata that needs to be decoded.
     *
     * @param tx - ReadTransaction to create contract call
     * @param tx.domain - Chain to read transaction on
     * @param tx.to - Address to execute read on
     * @param tx.data - Calldata to send
     * @param blockTag - (optional) Block tag to query, defaults to latest
     *
     * @returns Encoded hexdata representing result of the read from the chain.
     */
    readTx(tx: ReadTransaction, blockTag?: providers.BlockTag): Promise<string>;
    /**
     * Create a non-state changing contract call. Returns hexdata that needs to be decoded.
     *
     * @param params.domain - Chain to read transaction on.
     * @param params.txs - ReadTransaction(s) we will be executing using a static call.
     * @param params.resultTypes - A list of result types we should use when decoding the multisend response
     * (e.g. ["uint256", "address", "string", "tuple(uint256 b, string c) d"]).
     * @param params.multisendContract - (optional) The multisend contract address. If not provided, we will
     * query the multisend for this chain internally.
     * @param params.blockTag - (optional) Block tag to query, defaults to latest.
     *
     * @returns Decoded return values based on the expected result types.
     */
    multiread(params: {
        domain: number;
        txs: MultireadTransaction[];
        multisendContract?: string;
        blockTag?: providers.BlockTag;
        requestContext?: RequestContext;
    }): Promise<utils.Result>;
    /**
     * Gets the asset balance for a specified address for the specified chain. Optionally pass in the
     * assetId; by default, gets the native asset.
     *
     * @param domain - The ID of the chain for which this call is related.
     * @param address - The hexadecimal string address whose balance we are getting.
     * @param assetId (default = ETH) - The ID (address) of the asset whose balance we are getting.
     * @param abi - The ABI of the token contract to use for interfacing with it, if applicable (non-native).
     * Defaults to ERC20.
     *
     * @returns BigNumber representing the current value held by the wallet at the
     * specified address.
     */
    getBalance(domain: number, address: string, assetId?: string, abi?: string[]): Promise<BigNumber>;
    /**
     * Get the current gas price for the chain for which this instance is servicing.
     *
     * @param domain - The ID of the chain for which this call is related.
     * @param requestContext - The request context.
     * @returns BigNumber representing the current gas price.
     */
    getGasPrice(domain: number, requestContext: RequestContext): Promise<BigNumber>;
    /**
     * Gets the decimals for an asset by domain
     *
     * @param domain - The ID of the chain for which this call is related.
     * @param assetId - The hexadecimal string address whose decimals we are getting.
     * @returns number representing the decimals of the asset
     */
    getDecimalsForAsset(domain: number, assetId: string): Promise<number>;
    /**
     * Gets a block
     *
     * @param domain - The ID of the chain for which this call is related.
     * @returns block representing the specified
     */
    getBlock(domain: number, blockHashOrBlockTag: providers.BlockTag | Promise<providers.BlockTag>): Promise<providers.Block | undefined>;
    /**
     * Gets the current blocktime
     *
     * @param domain - The ID of the chain for which this call is related.
     * @returns number representing the current blocktime
     */
    getBlockTime(domain: number): Promise<number>;
    /**
     * Gets the current block number
     *
     * @param domain - The ID of the chain for which this call is related.
     * @returns number representing the current block
     */
    getBlockNumber(domain: number): Promise<number>;
    /**
     * Gets a trsanction receipt by hash
     *
     * @param domain - The ID of the chain for which this call is related.
     * @returns number representing the current blocktime
     */
    getTransactionReceipt(domain: number, hash: string): Promise<providers.TransactionReceipt>;
    /**
     * Returns a hexcode string representation of the contract code at the given
     * address. If there is no contract deployed at the given address, returns "0x".
     *
     * @param address - contract address.
     *
     * @returns Hexcode string representation of contract code.
     */
    getCode(domain: number, address: string): Promise<string>;
    /**
     * Checks estimate for gas limit for given transaction on given chain.
     *
     * @param domain - chain on which the transaction is intended to be executed.
     * @param tx - transaction to check gas limit for.
     *
     * @returns BigNumber representing the estimated gas limit in gas units.
     * @throws Error if the transaction is invalid, or would be reverted onchain.
     */
    getGasEstimate(domain: number, tx: ReadTransaction | WriteTransaction): Promise<BigNumber>;
    /**
     * Checks estimate for gas limit for given transaction on given chain. Includes revert
     * error codes if failure occurs.
     *
     * @param domain - chain on which the transaction is intended to be executed.
     * @param tx - transaction to check gas limit for.
     *
     * @returns BigNumber representing the estimated gas limit in gas units.
     * @throws Error if the transaction is invalid, or would be reverted onchain.
     */
    getGasEstimateWithRevertCode(tx: ReadTransaction | WriteTransaction): Promise<BigNumber>;
    /**
     * Gets token price in usd from cache or price oracle
     *
     * @param domain - The network identifier.
     * @param assetId - The asset address to get price for.
     */
    getTokenPrice(domain: number, assetId: string, blockTag?: providers.BlockTag, _requestContext?: RequestContext): Promise<BigNumber>;
    /**
     * Gets token price in usd from price oracle
     *
     * @param domain - The network identifier.
     * @param assetId - The asset address to get price for.
     */
    getTokenPriceFromOnChain(domain: number, assetId: string, blockTag?: providers.BlockTag, _requestContext?: RequestContext): Promise<BigNumber>;
    /**
     * Helper to check for chain support gently.
     *
     * @param domain - domain of the chain to check
     * @returns boolean indicating whether chain of domain is supported by the service
     */
    isSupportedChain(domain: number): boolean;
    /**
     * Helper to wrap getting provider for specified domain.
     * @param domain The ID of the chain for which we want a provider.
     * @returns The ChainRpcProvider for that chain.
     * @throws TransactionError.reasons.ProviderNotFound if provider is not configured for
     * that ID.
     */
    protected getProvider(domain: number): RpcProviderAggregator;
    /**
     * Populate the provider mapping using chain configurations.
     * @param context - The request context object used for logging.
     * @param signer - The signer that will be used for onchain operations.
     */
    protected setupProviders(context: RequestContext, signer?: string | Signer): void;
}
//# sourceMappingURL=chainreader.d.ts.map