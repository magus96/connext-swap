import { Signer, providers } from "ethers";
import { Logger, RequestContext } from "@connext/nxtp-utils";
import { WriteTransaction, NxtpTxServiceEventPayloads, NxtpTxServiceEvent } from "./shared";
import { ChainReader } from "./chainreader";
import { TransactionDispatch } from "./dispatch";
/**
 * @classdesc Handles submitting, confirming, and bumping gas of arbitrary transactions onchain. Also performs onchain reads with embedded retries
 */
export declare class TransactionService extends ChainReader {
    private static instance?;
    private evts;
    /**
     * A singleton-like interface for handling all logic related to conducting on-chain transactions.
     *
     * @remarks
     * Using the Signer instance passed into this constructor outside of the context of this
     * class is not recommended, and may cause issues with nonce being tracked improperly
     * due to the caching mechanisms used here.
     *
     * @param logger The Logger used for logging.
     * @param signer The Signer or Wallet instance, or private key, for signing transactions.
     * @param config At least a partial configuration used by TransactionService for chains,
     * providers, etc.
     * @param ghostInstance Used in the event that we are conducting an integration test (which will have
     * multiple txservice instances) and want to prevent this instantiation from being saved as the singleton.
     */
    constructor(logger: Logger, config: any, signer: string | Signer, _ghostInstance?: boolean);
    /**
     * Send specified transaction on specified chain and wait for the configured number of confirmations.
     * Will emit events throughout its lifecycle.
     *
     * @param tx - Tx to send
     * @param tx.domain - Domain identifier of chain to send transaction on
     * @param tx.to - Address to send tx to
     * @param tx.value - Value to send tx with
     * @param tx.data - Calldata to execute
     * @param tx.from - (optional) Account to send tx from
     *
     * @returns TransactionReceipt once the tx is mined if the transaction was successful.
     *
     * @throws TransactionError with one of the reasons specified in ValidSendErrors. If another error occurs,
     * something went wrong within TransactionService process.
     * @throws TransactionServiceFailure, which indicates something went wrong with the service logic.
     */
    sendTx(tx: WriteTransaction, context: RequestContext): Promise<providers.TransactionReceipt>;
    /**
     * Attaches a callback to the emitted event
     *
     * @param event - The event name to attach a handler for
     * @param callback - The callback to invoke on event emission
     * @param filter - (optional) A filter where callbacks are only invoked if the filter returns true
     * @param timeout - (optional) A timeout to detach the handler within. I.e. if no events fired within the timeout, then the handler is detached
     */
    attach<T extends NxtpTxServiceEvent>(event: T, callback: (data: NxtpTxServiceEventPayloads[T]) => void, filter?: (data: NxtpTxServiceEventPayloads[T]) => boolean, timeout?: number): void;
    /**
     * Attaches a callback to the emitted event that will be executed one time and then detached.
     *
     * @param event - The event name to attach a handler for
     * @param callback - The callback to invoke on event emission
     * @param filter - (optional) A filter where callbacks are only invoked if the filter returns true
     * @param timeout - (optional) A timeout to detach the handler within. I.e. if no events fired within the timeout, then the handler is detached
     *
     */
    attachOnce<T extends NxtpTxServiceEvent>(event: T, callback: (data: NxtpTxServiceEventPayloads[T]) => void, filter?: (data: NxtpTxServiceEventPayloads[T]) => boolean, timeout?: number): void;
    /**
     * Removes all attached handlers from the given event.
     *
     * @param event - (optional) The event name to remove handlers from. If not provided, will detach handlers from *all* subgraph events
     */
    detach<T extends NxtpTxServiceEvent>(event?: T): void;
    /**
     * Returns a promise that resolves when the event matching the filter is emitted
     *
     * @param event - The event name to wait for
     * @param timeout - The ms to continue waiting before rejecting
     * @param filter - (optional) A filter where the promise is only resolved if the filter returns true
     *
     * @returns Promise that will resolve with the event payload once the event is emitted, or rejects if the timeout is reached.
     *
     */
    waitFor<T extends NxtpTxServiceEvent>(event: T, timeout: number, filter?: (data: NxtpTxServiceEventPayloads[T]) => boolean): Promise<NxtpTxServiceEventPayloads[T]>;
    /**
     * Helper to wrap getting signer address for specified domain.
     * @returns The signer address for that chain.
     * @throws TransactionError.reasons.ProviderNotFound if provider is not configured for
     * that ID.
     */
    getAddress(): Promise<string>;
    /**
     * Helper to wrap getting provider for specified domain.
     * @param domain The domain of the chain for which we want a provider.
     * @returns The ChainRpcProvider for that chain.
     * @throws TransactionError.reasons.ProviderNotFound if provider is not configured for
     * that ID.
     */
    getProvider(domain: number): TransactionDispatch;
    /**
     * Populate the provider mapping using chain configurations.
     * @param context - The request context object used for logging.
     * @param signer - The signer that will be used for onchain operations.
     */
    protected setupProviders(context: RequestContext, signer: string | Signer): void;
}
//# sourceMappingURL=transactionservice.d.ts.map