import { Signer, providers } from "ethers";
import { Logger, RequestContext } from "@connext/nxtp-utils";
import { WriteTransaction, OnchainTransaction } from "./shared";
import { ChainConfig } from "./config";
import { RpcProviderAggregator } from "./aggregator";
export type DispatchCallbacks = {
    onSubmit: (transaction: OnchainTransaction) => void;
    onMined: (transaction: OnchainTransaction) => void;
    onConfirm: (transaction: OnchainTransaction) => void;
    onFail: (transaction: OnchainTransaction) => void;
};
/**
 * @classdesc Transaction lifecycle manager.
 *
 */
export declare class TransactionDispatch extends RpcProviderAggregator {
    readonly domain: number;
    private readonly callbacks;
    private loopsRunning;
    static MAX_INFLIGHT_TRANSACTIONS: number;
    private inflightBuffer;
    private minedBuffer;
    private readonly queue;
    private nonce;
    private lastReceivedTxCount;
    /**
     * Transaction lifecycle management class. Extends ChainRpcProvider, thus exposing all provider methods
     * through this class.
     *
     * @param logger Logger used for logging.
     * @param signer Signer instance or private key used for signing transactions.
     * @param domain The ID of the chain for which this class's providers will be servicing.
     * @param chainConfig Configuration for this specified chain, including the providers we'll
     * be using for it.
     * @param config The shared TransactionServiceConfig with general configuration.
     *
     * @throws ChainError.reasons.ProviderNotFound if no valid providers are found in the
     * configuration.
     */
    constructor(logger: Logger, domain: number, config: ChainConfig, signer: string | Signer, callbacks: DispatchCallbacks, startLoops?: boolean);
    /**
     * Start background loops for mining and confirming transactions.
     */
    startLoops(): void;
    /**
     * Check for mined transactions in the inflight buffer; if any are present it will wait for 1 confirmation
     * and then push the transaction to the mined buffer for each one in FIFO order.
     */
    private mineLoop;
    /**
     * Check for mined transactions in the mined buffer; if any are present it will wait for the target confirmations for each
     * one in FIFO order.
     */
    private confirmLoop;
    /**
     * Determine the nonce assignment for a transaction based on the current state, as well as what nonces have already
     * been attempted, etc.
     * @remarks
     * This should only ever be called within the queue in the send() method.
     *
     * @param attemptedNonces - Array of nonces that have already been attempted, in order of attempt.
     * @param error - (optional) The last error that was thrown when attempting to send an initial transaction.
     * @param previousNonce - (optional) The previous nonce assigned. Should only be defined if the error argument is also
     * passed in.
     * @returns object - containing nonce, backfill, and transactionCount.
     */
    private determineNonce;
    /**
     *
     * @param minTx - Minimum transaction params needed to form a transaction.
     * @param context - Request context object used for logging.
     *
     * @returns A list of receipts or errors that occurred for each.
     */
    send(minTx: WriteTransaction, context: RequestContext): Promise<providers.TransactionReceipt>;
    /**
     * Submit an OnchainTransaction to the chain.
     *
     * @param transaction - OnchainTransaction object to modify based on submit result.
     */
    private submit;
    /**
     * Wait for an OnchainTransaction to be mined (1 confirmation).
     *
     * @param transaction - OnchainTransaction object to modify based on mine result.
     */
    private mine;
    /**
     * Makes an attempt to confirm this transaction, waiting up to a designated period to achieve
     * a desired number of confirmation blocks. If confirmation times out, throws TimeoutError.
     * If all txs, including replacements, are reverted, throws TransactionReverted.
     *
     * @param transaction - OnchainTransaction object to modify based on confirm result.
     */
    private confirm;
    /**
     * Bump the gas price for this tx up by the configured percentage.
     *
     * @param transaction - OnchainTransaction object to modify based on bump result.
     */
    bump(transaction: OnchainTransaction): Promise<void>;
    /**
     * Handles OnchainTransaction failure.
     *
     * @param transaction - OnchainTransaction object to read from and modify based on fail event.
     */
    private fail;
}
//# sourceMappingURL=dispatch.d.ts.map