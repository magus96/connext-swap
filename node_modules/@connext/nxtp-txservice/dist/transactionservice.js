"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionService = void 0;
const ethers_1 = require("ethers");
const evt_1 = require("evt");
const nxtp_utils_1 = require("@connext/nxtp-utils");
const shared_1 = require("./shared");
const chainreader_1 = require("./chainreader");
const dispatch_1 = require("./dispatch");
// TODO: Should take on the logic of Dispatch (rename to TransactionDispatch) and consume ChainReader instead of extending it.
/**
 * @classdesc Handles submitting, confirming, and bumping gas of arbitrary transactions onchain. Also performs onchain reads with embedded retries
 */
class TransactionService extends chainreader_1.ChainReader {
    /**
     * A singleton-like interface for handling all logic related to conducting on-chain transactions.
     *
     * @remarks
     * Using the Signer instance passed into this constructor outside of the context of this
     * class is not recommended, and may cause issues with nonce being tracked improperly
     * due to the caching mechanisms used here.
     *
     * @param logger The Logger used for logging.
     * @param signer The Signer or Wallet instance, or private key, for signing transactions.
     * @param config At least a partial configuration used by TransactionService for chains,
     * providers, etc.
     * @param ghostInstance Used in the event that we are conducting an integration test (which will have
     * multiple txservice instances) and want to prevent this instantiation from being saved as the singleton.
     */
    constructor(logger, config, signer, _ghostInstance = false) {
        super(logger, config, signer);
        /// Events emitted in lifecycle of TransactionService's sendTx.
        this.evts = {
            [shared_1.NxtpTxServiceEvents.TransactionSubmitted]: evt_1.Evt.create(),
            [shared_1.NxtpTxServiceEvents.TransactionMined]: evt_1.Evt.create(),
            [shared_1.NxtpTxServiceEvents.TransactionConfirmed]: evt_1.Evt.create(),
            [shared_1.NxtpTxServiceEvents.TransactionFailed]: evt_1.Evt.create(),
        };
        const { requestContext, methodContext } = (0, nxtp_utils_1.createLoggingContext)("ChainService.constructor");
        // TODO: #152 See above TODO. Should we have a getInstance() method and make constructor private ??
        // const _signer: string = typeof signer === "string" ? signer : signer.getAddress();
        // if (TransactionService._instances.has(_signer)) {}
        if (TransactionService.instance) {
            const msg = "CRITICAL: ChainService.constructor was called twice! Please report this incident.";
            const error = new nxtp_utils_1.NxtpError(msg);
            logger.error(msg, requestContext, methodContext, error, {
                instance: TransactionService.instance.toString(),
            });
            throw error;
        }
        // Set the singleton instance.
        if (!_ghostInstance) {
            TransactionService.instance = this;
        }
    }
    /**
     * Send specified transaction on specified chain and wait for the configured number of confirmations.
     * Will emit events throughout its lifecycle.
     *
     * @param tx - Tx to send
     * @param tx.domain - Domain identifier of chain to send transaction on
     * @param tx.to - Address to send tx to
     * @param tx.value - Value to send tx with
     * @param tx.data - Calldata to execute
     * @param tx.from - (optional) Account to send tx from
     *
     * @returns TransactionReceipt once the tx is mined if the transaction was successful.
     *
     * @throws TransactionError with one of the reasons specified in ValidSendErrors. If another error occurs,
     * something went wrong within TransactionService process.
     * @throws TransactionServiceFailure, which indicates something went wrong with the service logic.
     */
    async sendTx(tx, context) {
        const { requestContext, methodContext } = (0, nxtp_utils_1.createLoggingContext)(this.sendTx.name, context);
        this.logger.debug("Method start", requestContext, methodContext, {
            tx: { ...tx, value: tx.value.toString(), data: `${tx.data.substring(0, 9)}...` },
        });
        return await this.getProvider(tx.domain).send(tx, context);
    }
    /// LISTENER METHODS
    /**
     * Attaches a callback to the emitted event
     *
     * @param event - The event name to attach a handler for
     * @param callback - The callback to invoke on event emission
     * @param filter - (optional) A filter where callbacks are only invoked if the filter returns true
     * @param timeout - (optional) A timeout to detach the handler within. I.e. if no events fired within the timeout, then the handler is detached
     */
    attach(event, callback, filter = (_data) => true, timeout) {
        const args = [timeout, callback].filter((x) => !!x);
        // eslint-disable-next-line
        this.evts[event].pipe(filter).attach(...args);
    }
    /**
     * Attaches a callback to the emitted event that will be executed one time and then detached.
     *
     * @param event - The event name to attach a handler for
     * @param callback - The callback to invoke on event emission
     * @param filter - (optional) A filter where callbacks are only invoked if the filter returns true
     * @param timeout - (optional) A timeout to detach the handler within. I.e. if no events fired within the timeout, then the handler is detached
     *
     */
    attachOnce(event, callback, filter = (_data) => true, timeout) {
        const args = [timeout, callback].filter((x) => !!x);
        // eslint-disable-next-line
        this.evts[event].pipe(filter).attachOnce(...args);
    }
    /**
     * Removes all attached handlers from the given event.
     *
     * @param event - (optional) The event name to remove handlers from. If not provided, will detach handlers from *all* subgraph events
     */
    detach(event) {
        if (event) {
            this.evts[event].detach();
            return;
        }
        Object.values(this.evts).forEach((evt) => evt.detach());
    }
    /**
     * Returns a promise that resolves when the event matching the filter is emitted
     *
     * @param event - The event name to wait for
     * @param timeout - The ms to continue waiting before rejecting
     * @param filter - (optional) A filter where the promise is only resolved if the filter returns true
     *
     * @returns Promise that will resolve with the event payload once the event is emitted, or rejects if the timeout is reached.
     *
     */
    waitFor(event, timeout, filter = (_data) => true) {
        return this.evts[event].pipe(filter).waitFor(timeout);
    }
    /// HELPERS
    /**
     * Helper to wrap getting signer address for specified domain.
     * @returns The signer address for that chain.
     * @throws TransactionError.reasons.ProviderNotFound if provider is not configured for
     * that ID.
     */
    getAddress() {
        // Ensure that a signer, provider, etc are present to execute on this domain.
        const [chain, provider] = [...this.providers.entries()][0];
        if (!chain) {
            throw new shared_1.ProviderNotConfigured(chain.toString());
        }
        return provider.getAddress();
    }
    /**
     * Helper to wrap getting provider for specified domain.
     * @param domain The domain of the chain for which we want a provider.
     * @returns The ChainRpcProvider for that chain.
     * @throws TransactionError.reasons.ProviderNotFound if provider is not configured for
     * that ID.
     */
    getProvider(domain) {
        // Ensure that a signer, provider, etc are present to execute on this domain.
        if (!this.providers.has(domain)) {
            throw new shared_1.ProviderNotConfigured(domain.toString());
        }
        return this.providers.get(domain);
    }
    // TODO: Use a generic type in ChainReader.setupProviders for this method such that we don't have to overload it here.
    /**
     * Populate the provider mapping using chain configurations.
     * @param context - The request context object used for logging.
     * @param signer - The signer that will be used for onchain operations.
     */
    setupProviders(context, signer) {
        const { methodContext } = (0, nxtp_utils_1.createLoggingContext)(this.setupProviders.name, context);
        // For each domain / provider, map out all the utils needed for each chain.
        Object.keys(this.config).forEach((_domain) => {
            // Convert to number
            const domain = +_domain;
            // Get this chain's config.
            const chain = this.config[domain];
            // Ensure at least one provider is configured.
            if (chain.providers.length === 0) {
                const error = new shared_1.ConfigurationError([
                    {
                        parameter: "providers",
                        error: "No valid providers were supplied in configuration for this chain.",
                        value: ethers_1.providers,
                    },
                ], {
                    domain,
                });
                this.logger.error("Failed to create transaction service", context, methodContext, error.toJson(), {
                    domain,
                    providers: ethers_1.providers,
                });
                throw error;
            }
            const provider = new dispatch_1.TransactionDispatch(this.logger, domain, chain, signer, {
                onSubmit: (transaction) => this.evts[shared_1.NxtpTxServiceEvents.TransactionSubmitted].post({ responses: transaction.responses }),
                onMined: (transaction) => this.evts[shared_1.NxtpTxServiceEvents.TransactionMined].post({ receipt: transaction.receipt }),
                onConfirm: (transaction) => this.evts[shared_1.NxtpTxServiceEvents.TransactionConfirmed].post({ receipt: transaction.receipt }),
                onFail: (transaction) => this.evts[shared_1.NxtpTxServiceEvents.TransactionFailed].post({
                    error: transaction.error,
                    receipt: transaction.receipt,
                }),
            });
            this.providers.set(domain, provider);
        });
    }
}
exports.TransactionService = TransactionService;
//# sourceMappingURL=transactionservice.js.map