"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_CHAIN_CONFIG_VALUE_MINS = exports.DEFAULT_CHAIN_CONFIG = exports.validateTransactionServiceConfig = exports.validateProviderConfig = exports.ProviderConfigSchema = void 0;
const typebox_1 = require("@sinclair/typebox");
const ajv_1 = __importDefault(require("ajv"));
const ajv_formats_1 = __importDefault(require("ajv-formats"));
const utils_1 = require("ethers/lib/utils");
const shared_1 = require("./shared");
const TIntegerString = typebox_1.Type.RegEx(/^([0-9])*$/);
const TUrl = typebox_1.Type.String({ format: "uri" });
const ajv = (0, ajv_formats_1.default)(new ajv_1.default(), [
    "date-time",
    "time",
    "date",
    "email",
    "hostname",
    "ipv4",
    "ipv6",
    "uri",
    "uri-reference",
    "uuid",
    "uri-template",
    "json-pointer",
    "relative-json-pointer",
    "regex",
])
    .addKeyword("kind")
    .addKeyword("modifier");
/// PROVIDER CONFIG
exports.ProviderConfigSchema = typebox_1.Type.Object({
    // URL string.
    url: TUrl,
    // Auth header params, if needed.
    user: typebox_1.Type.Optional(typebox_1.Type.String()),
    password: typebox_1.Type.Optional(typebox_1.Type.String()),
    /* From ethers:
     * The priority used for the provider. Lower-value priorities are favoured over higher-value priorities. If
     * multiple providers share the same priority, they are chosen at random.
     *
     * Defaults to 1.
     */
    priority: typebox_1.Type.Optional(typebox_1.Type.Number()),
    /* From ethers:
     * The weight a response from this provider provides. This can be used if a given Provider is more trusted, for example.
     *
     * Defaults to 1.
     */
    weight: typebox_1.Type.Optional(typebox_1.Type.Number()),
    /* From ethers:
     * The timeout (in ms) after which another Provider will be attempted. This does not affect the current Provider;
     * if it returns a result it is counted as part of the quorum.
     * Lower values will result in more network traffic, but may reduce the response time of requests.
     */
    stallTimeout: typebox_1.Type.Optional(typebox_1.Type.Number()),
});
exports.validateProviderConfig = ajv.compile(exports.ProviderConfigSchema);
/// CHAIN CONFIG
const CoreChainConfigSchema = typebox_1.Type.Object({
    /// GAS STATIONS
    // Gas station URL, if any, to retrieve current gas price from. If gas station is down or otherwise fails,
    // we'll use the RPC provider's gas as a backup.
    // Gas station should return a "rapid" gas price within the response.data.
    gasStations: typebox_1.Type.Optional(typebox_1.Type.Array(typebox_1.Type.String())),
    /// GAS PRICE
    // % to bump gas by from provider or gas station initial quote.
    gasPriceInitialBoostPercent: typebox_1.Type.Integer(),
    // % to bump gas by when tx confirmation times out.
    gasPriceReplacementBumpPercent: typebox_1.Type.Integer(),
    // Gas shouldn't ever exceed this amount.
    gasPriceMaximum: TIntegerString,
    // Minimum gas price.
    gasPriceMinimum: TIntegerString,
    // Each time we submit a tx, this is the percentage scalar we use to set the maximum for the gas price we assign it.
    // The higher this number is, the more tolerant we are of gas price increases. The lower it is, the more we curb
    // increases in gas price from tx to tx.
    // NOTE: This value should ALWAYS be greater than 100, unless you want to disable it entirely (in which case, just set it to 0).
    gasPriceMaxIncreaseScalar: typebox_1.Type.Integer(),
    // Hardcoded initial value for gas. This shouldn't be used normally - only temporarily
    // in the event that a gas station is malfunctioning.
    hardcodedGasPrice: typebox_1.Type.Optional(TIntegerString),
    /// GAS LIMIT
    // An integer value by which we will inflate the gas LIMIT that is returned by the provider (flat increase).
    // Use this if your provider is returning low values and you're getting "out of gas" call exceptions.
    gasLimitInflation: typebox_1.Type.Optional(typebox_1.Type.Integer()),
    /// CONFIRMATIONS
    // The amount of time (ms) to wait before a confirmation polling period times out,
    // indicating we should resubmit tx with higher gas if the tx is not confirmed.
    confirmationTimeout: typebox_1.Type.Integer(),
    // Number of confirmations needed for each chain, specified by domain.
    confirmations: typebox_1.Type.Integer(),
    /// RPC PROVIDERS
    // Target maximum provider calls per second. Default is 4. Will NOT actually cap calls per second, but rather deprioritize
    // a provider if it reaches the maximum calls per second.
    maxProviderCPS: typebox_1.Type.Integer(),
    // How often (ms) we will check all RPC providers to measure how in-sync they are with the blockchain.
    // By default, every 5 mins (5 * 60_000).
    syncProvidersInterval: typebox_1.Type.Integer(),
    // Whether we want to maximize quorum/consensus from all available providers when we're doing read calls.
    // Set this value if it's critically important to maintain accurate responses from a number of providers that
    // vary in quality. This will increase the number of RPC calls we're making overall, but guarantees accuracy.
    quorum: typebox_1.Type.Optional(typebox_1.Type.Integer()),
    /// DEBUGGING / DEVELOPMENT
    // WARNING: Please do not alter these configuration values; they should be used for development and/or debugging
    // purposes only, and can greatly affect performance.
    // Whether to log rpc calls.
    debug_logRpcCalls: typebox_1.Type.Boolean(),
});
const ChainConfigSchema = typebox_1.Type.Intersect([
    typebox_1.Type.Object({
        /// PROVIDERS
        // List of configurations for providers for this chain.
        providers: typebox_1.Type.Array(exports.ProviderConfigSchema),
    }),
    CoreChainConfigSchema,
]);
/// TX SERVICE CONFIG
// Configuration for each chain that this txservice will be supporting.
const TransactionServiceConfigSchema = typebox_1.Type.Record(TIntegerString, ChainConfigSchema);
const validateTransactionServiceConfig = (_config) => {
    // Get the default (aka "all") values to be used as defaults for all chain configs.
    const userDefaultChainConfig = _config["all"] ?? _config["default"] ?? {};
    const defaultChainConfig = {
        ...exports.DEFAULT_CHAIN_CONFIG,
        ...userDefaultChainConfig,
    };
    // For each chain, validate the config and merge it with the main config.
    const config = {};
    Object.entries(_config).forEach(([domain, _chainConfig]) => {
        const chainConfig = {
            ...defaultChainConfig,
            ..._chainConfig,
        };
        // Ignore non-number domains.
        if (isNaN(parseInt(domain))) {
            return;
        }
        // Ensure providers are specified AND number of providers >= quorum
        if (chainConfig.providers.length === 0) {
            throw new shared_1.ConfigurationError([
                {
                    parameter: "providers",
                    error: `Providers array was empty. Please specify providers for domain ${domain}.`,
                    value: chainConfig.providers,
                },
            ]);
        }
        else if (chainConfig.quorum > chainConfig.providers.length) {
            throw new shared_1.ConfigurationError([
                {
                    parameter: "providers",
                    error: `Number of providers (${chainConfig.providers.length}) must be greater than ` +
                        `configured quorum (${chainConfig.quorum}) for domain ${domain}.`,
                    value: chainConfig.providers,
                },
            ]);
        }
        // Make sure config values that must be > X are so (if they are specified).
        const configValueMins = {
            ...exports.DEFAULT_CHAIN_CONFIG_VALUE_MINS,
            hardcodedGasPrice: chainConfig.gasPriceMinimum,
        };
        Object.entries(configValueMins).forEach(([key, min]) => {
            if (chainConfig[key] !== undefined && chainConfig[key] <= min) {
                const error = new shared_1.ConfigurationError([
                    {
                        parameter: key,
                        error: `${key} must be greater than 100.`,
                        value: chainConfig[key],
                    },
                ]);
                throw error;
            }
        });
        // Backwards compatibility with specifying only a single provider under the key "provider".
        const _providers = chainConfig.providers ?? chainConfig.provider;
        const providers = typeof _providers === "string" ? [{ url: _providers }] : _providers;
        // Remove unused from the mix (such as subgraphs, etc).
        // NOTE: We use CoreChainConfigSchema here because we will format them separately below.
        const sanitizedCoreConfig = {};
        Object.keys(CoreChainConfigSchema.properties).forEach((property) => {
            sanitizedCoreConfig[property] = chainConfig[property];
        });
        // Merge the default values with the specified chain config.
        config[domain] = {
            ...sanitizedCoreConfig,
            providers: providers.map((provider) => typeof provider === "string"
                ? {
                    url: provider,
                }
                : provider),
        };
    });
    ajv.compile(TransactionServiceConfigSchema)(config);
    return config;
};
exports.validateTransactionServiceConfig = validateTransactionServiceConfig;
// Set up the default configuration for CoreChainConfig.
exports.DEFAULT_CHAIN_CONFIG = {
    syncProvidersInterval: 5 * 60000,
    maxProviderCPS: 4,
    gasPriceInitialBoostPercent: 30,
    gasStations: [],
    // From ethers docs:
    // Generally, the new gas price should be about 50% + 1 wei more, so if a gas price
    // of 10 gwei was used, the replacement should be 15.000000001 gwei.
    gasPriceReplacementBumpPercent: 20,
    gasPriceMaximum: (0, utils_1.parseUnits)("1500", "gwei").toString(),
    gasPriceMinimum: (0, utils_1.parseUnits)("5", "gwei").toString(),
    gasPriceMaxIncreaseScalar: 200,
    confirmations: 10,
    // NOTE: This should be the amount of time we are willing to wait for a transaction
    // to get 1 confirmation.
    confirmationTimeout: 90000,
    debug_logRpcCalls: false,
    quorum: 1,
};
exports.DEFAULT_CHAIN_CONFIG_VALUE_MINS = {
    gasPriceMaxIncreaseScalar: 100,
    gasPriceReplacementBumpPercent: 0,
    gasLimitInflation: 0,
};
//# sourceMappingURL=config.js.map