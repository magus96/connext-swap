import { Logger } from "@connext/nxtp-utils";
import { BigNumber, BigNumberish, providers, utils } from "ethers";
export type ReadTransaction = {
    domain: number;
    to: string;
    data: string;
};
export type WriteTransaction = {
    from?: string;
    value: BigNumberish;
    gasLimit?: BigNumberish;
    gasPrice?: BigNumberish;
} & ReadTransaction;
export type MultireadTransaction = Omit<ReadTransaction, "domain"> & {
    resultTypes: (string | utils.ParamType)[];
};
export type TxServiceSubmittedEvent = {
    responses: providers.TransactionResponse[];
};
export type TxServiceMinedEvent = {
    receipt: providers.TransactionReceipt;
};
export type TxServiceConfirmedEvent = {
    receipt: providers.TransactionReceipt;
};
export type TxServiceFailedEvent = {
    error: Error;
    receipt?: providers.TransactionReceipt;
};
export declare const NxtpTxServiceEvents: {
    readonly TransactionSubmitted: "TransactionSubmitted";
    readonly TransactionMined: "TransactionMined";
    readonly TransactionConfirmed: "TransactionConfirmed";
    readonly TransactionFailed: "TransactionFailed";
};
export type NxtpTxServiceEvent = typeof NxtpTxServiceEvents[keyof typeof NxtpTxServiceEvents];
export interface NxtpTxServiceEventPayloads {
    [NxtpTxServiceEvents.TransactionSubmitted]: TxServiceSubmittedEvent;
    [NxtpTxServiceEvents.TransactionMined]: TxServiceMinedEvent;
    [NxtpTxServiceEvents.TransactionConfirmed]: TxServiceConfirmedEvent;
    [NxtpTxServiceEvents.TransactionFailed]: TxServiceFailedEvent;
}
export type Gas = {
    limit: BigNumber;
    price?: BigNumber;
    maxFeePerGas?: BigNumber;
    maxPriorityFeePerGas?: BigNumber;
};
/**
 * Cache item used in ProviderCache schema property; either blocks to live (BTL) or time to live (TTL) must
 * be specified (the former is preferred but the latter can be used as a backup when a block listener will not
 * be actively updating the cache's block number).
 */
type ProviderCacheSchema<T> = {
    [K in keyof T]: {
        btl: number;
        ttl?: number;
    } | {
        btl?: number;
        ttl: number;
    };
};
/**
 * @classdesc A data structure for managing time-sensitive (expiring) cached information from chain
 * that expires after a set number of blocks or amount of time.
 */
export declare class ProviderCache<T> {
    private readonly logger;
    private readonly schema;
    private _blockNumber;
    get blockNumber(): number;
    private _data;
    get data(): Partial<T>;
    /**
     * @param schema - A schema for the cache that determines whether each item expires after a set period of
     * time (ttl, ms) or a set number of blocks (btl, number).
     */
    constructor(logger: Logger, schema: ProviderCacheSchema<T>);
    /**
     * Update the cache block number, and optionally the data.
     * @param blockNumber - Current block number.
     * @param data - Optional data to update the cache with.
     */
    update(blockNumber: number, data?: Partial<T>): void;
    /**
     * Set a value in the cache.
     * @param data - The data to set.
     */
    set(data: Partial<T>): void;
    /**
     * Helper for retrieving item from data depending on whether it's expired.
     * @param key - a key of the cache data schema.
     * @returns
     */
    private getItem;
}
export {};
//# sourceMappingURL=types.d.ts.map