import { providers, utils } from "ethers";
export declare const StaticJsonRpcProvider: typeof providers.StaticJsonRpcProvider;
/**
 * @classdesc An extension of StaticJsonRpcProvider that manages a providers chain synchronization status
 * and intercepts all RPC send() calls to ensure that the provider is in sync.
 */
export declare class SyncProvider extends StaticJsonRpcProvider {
    readonly domain: number;
    private readonly stallTimeout;
    private readonly debugLogging;
    private readonly connectionInfo;
    readonly name: string;
    synced: boolean;
    lag: number;
    priority: number;
    private static readonly N_SAMPLES;
    private static readonly RELIABILITY_STEP;
    reliability: number;
    private cpsTimestamps;
    get cps(): number;
    private latencies;
    get latency(): number;
    private _syncedBlockNumber;
    get syncedBlockNumber(): number;
    constructor(_connectionInfo: utils.ConnectionInfo | string, domain: number, stallTimeout?: number, debugLogging?: boolean);
    /**
     * Synchronizes the provider with chain by checking the current block number and updating the syncedBlockNumber
     * property.
     */
    sync(): Promise<void>;
    /**
     * Overridden RPC send method. If the provider is currently out of sync, this method will
     * now throw an RpcError indicating such. This way, we ensure an out of sync provider is never
     * consulted (except when checking the block number, which is used for syncing).
     *
     * @param method - RPC method name.
     * @param params - RPC method params.
     * @returns any - RPC response.
     * @throws RpcError - If the provider is currently out of sync.
     */
    send(method: string, params: Array<any>): Promise<any>;
    private updateMetrics;
    private debugLog;
}
//# sourceMappingURL=provider.d.ts.map