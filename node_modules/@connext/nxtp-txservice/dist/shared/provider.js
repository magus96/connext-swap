"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyncProvider = exports.StaticJsonRpcProvider = void 0;
const nxtp_utils_1 = require("@connext/nxtp-utils");
const ethers_1 = require("ethers");
const smart_contracts_1 = require("@connext/smart-contracts");
const errors_1 = require("./errors");
exports.StaticJsonRpcProvider = ethers_1.providers.StaticJsonRpcProvider;
// TODO: Wrap metrics in a type, and add a getter for it for logging purposes (after sync() calls, for example)
// TODO: Should be a multiton mapped by URL (such that no duplicate instances are created).
/**
 * @classdesc An extension of StaticJsonRpcProvider that manages a providers chain synchronization status
 * and intercepts all RPC send() calls to ensure that the provider is in sync.
 */
class SyncProvider extends exports.StaticJsonRpcProvider {
    get cps() {
        // Average CPS over the last 10 seconds.
        const now = Date.now();
        this.cpsTimestamps = this.cpsTimestamps.filter((ts) => now - ts < 10000);
        return this.cpsTimestamps.length / 10;
    }
    get latency() {
        if (this.latencies.length === 0) {
            return 0.0;
        }
        // Average execution time over the last N samples.
        this.latencies = this.latencies.slice(-SyncProvider.N_SAMPLES);
        return this.latencies.reduce((a, b) => a + b, 0) / this.latencies.length;
    }
    get syncedBlockNumber() {
        return this._syncedBlockNumber;
    }
    constructor(_connectionInfo, domain, stallTimeout = 10000, debugLogging = false) {
        // NOTE: super (StaticJsonRpc) uses the hard-coded chainId when instantiated for all future
        // .getNetwork() requests, so it is important to use the chainId here, not the domain
        super(_connectionInfo, (0, smart_contracts_1.domainToChainId)(domain));
        this.domain = domain;
        this.stallTimeout = stallTimeout;
        this.debugLogging = debugLogging;
        this.synced = true;
        this.lag = 0;
        this.priority = 0;
        // A metric used for measuring reliability, based on the number of successful calls / last N calls made.
        this.reliability = 1.0;
        // Used for tracking how many calls we've made in the last second.
        this.cpsTimestamps = [];
        this.latencies = [];
        // This variable is used to track the last block number this provider synced to, and is kept separately from the
        // inherited `blockNumber` property (which is a getter that uses an update method).
        this._syncedBlockNumber = -1;
        this.connectionInfo = typeof _connectionInfo === "string" ? { url: _connectionInfo } : _connectionInfo;
        this.name = (0, nxtp_utils_1.parseHostname)(this.connectionInfo.url)
            ? (0, nxtp_utils_1.parseHostname)(this.connectionInfo.url).split(".").slice(0, -1).join(".")
            : this.connectionInfo.url;
    }
    /**
     * Synchronizes the provider with chain by checking the current block number and updating the syncedBlockNumber
     * property.
     */
    async sync() {
        const blockNumber = await this.getBlockNumber();
        this.debugLog("SYNCING_BLOCK_EVENT", blockNumber, this.syncedBlockNumber);
        this._syncedBlockNumber = blockNumber;
    }
    /**
     * Overridden RPC send method. If the provider is currently out of sync, this method will
     * now throw an RpcError indicating such. This way, we ensure an out of sync provider is never
     * consulted (except when checking the block number, which is used for syncing).
     *
     * @param method - RPC method name.
     * @param params - RPC method params.
     * @returns any - RPC response.
     * @throws RpcError - If the provider is currently out of sync.
     */
    async send(method, params) {
        // provider.ready returns a Promise which will stall until the network has been established, ignoring
        // errors due to the target node not being active yet. This will ensure we wait until the node is up
        // and running smoothly.
        const ready = await this.ready;
        if (!ready) {
            throw new errors_1.RpcError(errors_1.RpcError.reasons.OutOfSync, {
                provider: this.name,
                domain: this.domain,
                lastSyncedBlockNumber: this.syncedBlockNumber,
                synced: this.synced,
                lag: this.lag,
                ready,
            });
        }
        // TODO: Make # of retries configurable?
        const errors = [];
        let sendTimestamp = -1;
        for (let i = 1; i <= 5; i++) {
            try {
                sendTimestamp = Date.now();
                this.cpsTimestamps.push(sendTimestamp);
                return await Promise.race([
                    new Promise((resolve, reject) => {
                        super
                            .send(method, params)
                            .then((res) => {
                            this.updateMetrics(true, sendTimestamp, i, method, params);
                            resolve(res);
                        })
                            .catch((e) => {
                            const error = (0, errors_1.parseError)(e);
                            reject(error);
                        });
                    }),
                ].concat(this.stallTimeout
                    ? [
                        new Promise(async (_, reject) => {
                            await (0, nxtp_utils_1.delay)(this.stallTimeout);
                            reject(new errors_1.StallTimeout({
                                attempt: i,
                                provider: this.name,
                                domain: this.domain,
                                stallTimeout: this.stallTimeout,
                                errors,
                            }));
                        }),
                    ]
                    : []));
            }
            catch (error) {
                this.updateMetrics(false, sendTimestamp, i, method, params, {
                    type: error.type.toString(),
                    context: error.context,
                });
                if (error.type === errors_1.RpcError.type) {
                    // e.g. ConnectionReset, NetworkError, etc.
                    // This type of error indicates we should retry the call attempt with this provider again.
                    errors.push(error);
                }
                else {
                    // e.g. a TransactionReverted, TransactionReplaced, etc.
                    // NOTE: If this is a StallTimeout or ServerError, we should assume this provider is unresponsive
                    // at the moment, and throw.
                    throw error;
                }
            }
        }
        throw new errors_1.RpcError(errors_1.RpcError.reasons.FailedToSend, {
            provider: this.name,
            domain: this.domain,
            errors,
        });
    }
    updateMetrics(success, sendTimestamp, iteration, method, params, error) {
        const latency = +((Date.now() - sendTimestamp) / 1000).toFixed(2);
        this.latencies.push(latency);
        if (success) {
            this.reliability = Math.min(1, +(this.reliability + SyncProvider.RELIABILITY_STEP).toFixed(2));
        }
        else if (error?.type === errors_1.RpcError.type) {
            // If the error is an RPC Error, update reliability to reflect provider misbehavior.
            this.reliability = Math.max(0, +(this.reliability - SyncProvider.RELIABILITY_STEP).toFixed(2));
        }
        else if (error?.type === errors_1.StallTimeout.type || error?.type === errors_1.ServerError.type) {
            // If the provider really is not responding in stallTimeout time (by default 10s!) or giving bad responses,
            //  we should assume it is unresponsive in general and severely penalize reliability score as a result.
            this.reliability = 0;
        }
        this.debugLog(success ? "RPC_CALL" : "RPC_ERROR", `#${iteration}`, method, this.cps, latency, this.reliability, 
        // TODO: Logging params for these methods is for debugging purposes only.
        ["eth_getBlockByNumber", "eth_getTransactionByHash", "eth_getTransactionReceipt"].includes(method)
            ? params.length > 0
                ? params[0]
                : params
            : "", error ? error.type : "", error ? error.context : "");
    }
    debugLog(message, ...args) {
        if (this.debugLogging) {
            // eslint-disable-next-line
            console.log(`[${Date.now()}]`, `(${this.name})`, message, ...args);
        }
    }
}
exports.SyncProvider = SyncProvider;
SyncProvider.N_SAMPLES = 100;
// Denominator is the target reliability sample size.
SyncProvider.RELIABILITY_STEP = 1 / SyncProvider.N_SAMPLES;
//# sourceMappingURL=provider.js.map