import { Values, NxtpError } from "@connext/nxtp-utils";
import { providers } from "ethers";
export declare class MaxBufferLengthError extends NxtpError {
    readonly context: any;
    /**
     * Thrown if a backfill transaction fails and other txs are attempted
     */
    static readonly type: string;
    constructor(context?: any);
}
export declare class StallTimeout extends NxtpError {
    readonly context: any;
    static readonly type: string;
    constructor(context?: any);
}
export declare class QuorumNotMet extends NxtpError {
    readonly context: any;
    static readonly type: string;
    constructor(highestQuorum: number, requiredQuorum: number, context?: any);
}
export declare class RpcError extends NxtpError {
    readonly reason: Values<typeof RpcError.reasons>;
    readonly context: any;
    static readonly type: string;
    /**
     * Indicates the RPC Providers are malfunctioning. If errors of this type persist,
     * ensure you have a sufficient number of backup providers configured.
     */
    static readonly reasons: {
        OutOfSync: string;
        FailedToSend: string;
        NetworkError: string;
        ConnectionReset: string;
    };
    constructor(reason: Values<typeof RpcError.reasons>, context?: any);
}
export declare class TransactionReadError extends NxtpError {
    readonly reason: Values<typeof TransactionReverted.reasons>;
    readonly context: any;
    /**
     * An error that indicates that a read transaction failed.
     */
    static readonly type: string;
    static readonly reasons: {
        ContractReadError: string;
    };
    constructor(reason: Values<typeof TransactionReverted.reasons>, context?: any);
}
export declare class TransactionReverted extends NxtpError {
    readonly reason: Values<typeof TransactionReverted.reasons>;
    readonly receipt?: providers.TransactionReceipt | undefined;
    readonly context: any;
    /**
     * An error that indicates that the transaction was reverted on-chain.
     *
     * Could be harmless if this was from a subsuquent attempt, e.g. if the tx
     * was already mined (NonceExpired, AlreadyMined)
     *
     * Alternatively, if this is from the first attempt, it must be thrown as the reversion
     * was for a legitimate reason.
     */
    static readonly type: string;
    static readonly reasons: {
        GasEstimateFailed: string;
        InsufficientFunds: string;
        /**
         * From ethers docs:
         * If the transaction execution failed (i.e. the receipt status is 0), a CALL_EXCEPTION error will be rejected with the following properties:
         * error.transaction - the original transaction
         * error.transactionHash - the hash of the transaction
         * error.receipt - the actual receipt, with the status of 0
         */
        CallException: string;
        /**
         * No difference between the following two errors, except to distinguish a message we
         * get back from providers on execution failure.
         */
        ExecutionFailed: string;
        AlwaysFailingTransaction: string;
        GasExceedsAllowance: string;
    };
    constructor(reason: Values<typeof TransactionReverted.reasons>, receipt?: providers.TransactionReceipt | undefined, context?: any);
}
export declare class TransactionReplaced extends NxtpError {
    readonly receipt: providers.TransactionReceipt;
    readonly replacement: providers.TransactionResponse;
    readonly context: any;
    /**
     * From ethers docs:
     * If the transaction is replaced by another transaction, a TRANSACTION_REPLACED error will be rejected with the following properties:
     * error.hash - the hash of the original transaction which was replaced
     * error.reason - a string reason; one of "repriced", "cancelled" or "replaced"
     * error.cancelled - a boolean; a "repriced" transaction is not considered cancelled, but "cancelled" and "replaced" are
     * error.replacement - the replacement transaction (a TransactionResponse)
     * error.receipt - the receipt of the replacement transaction (a TransactionReceipt)
     */
    static readonly type: string;
    constructor(receipt: providers.TransactionReceipt, replacement: providers.TransactionResponse, context?: any);
}
export declare class OperationTimeout extends NxtpError {
    readonly context: any;
    /**
     * An error indicating that an operation (typically confirmation) timed out.
     */
    static readonly type: string;
    constructor(context?: any);
}
export declare class TransactionBackfilled extends NxtpError {
    readonly context: any;
    /**
     * An error indicating that a transaction was replaced by a backfill, likely because it
     * was unresponsive.
     */
    static readonly type: string;
    constructor(context?: any);
}
export declare class UnpredictableGasLimit extends NxtpError {
    readonly context: any;
    /**
     * An error that we get back from ethers when we try to do a gas estimate, but this
     * may need to be handled differently.
     */
    static readonly type: string;
    constructor(context?: any);
}
export declare class BadNonce extends NxtpError {
    readonly reason: Values<typeof BadNonce.reasons>;
    readonly context: any;
    /**
     * An error indicating that we got a "nonce expired"-like message back from
     * ethers while conducting sendTransaction.
     */
    static readonly type: string;
    static readonly reasons: {
        NonceExpired: string;
        ReplacementUnderpriced: string;
        NonceIncorrect: string;
    };
    constructor(reason: Values<typeof BadNonce.reasons>, context?: any);
}
export declare class ServerError extends NxtpError {
    readonly reason?: string | undefined;
    readonly context: any;
    /**
     * An error indicating that an operation on the node server (such as validation
     * before submitting a transaction) occurred.
     *
     * This error could directly come from geth, or be altered by the node server,
     * depending on which service is used. As a result, we coerce this to a single error
     * type.
     */
    static readonly type: string;
    static readonly reasons: {
        BadResponse: string;
    };
    constructor(reason?: string | undefined, context?: any);
}
export declare class TransactionAlreadyKnown extends NxtpError {
    readonly context: any;
    /**
     * This one occurs (usually) when we try to send a transaction to multiple providers
     * and one or more of them already has the transaction in their mempool.
     */
    static readonly type: string;
    constructor(context?: any);
}
export declare class TransactionKilled extends NxtpError {
    readonly context: any;
    /**
     * An error indicating that the transaction was killed by the monitor loop due to
     * it taking too long, and blocking (potentially too many) transactions in the pending
     * queue.
     *
     * It will be replaced with a backfill transaction at max gas.
     */
    static readonly type: string;
    constructor(context?: any);
}
export declare class MaxAttemptsReached extends NxtpError {
    readonly context: any;
    static readonly type: string;
    static getMessage(attempts: number): string;
    constructor(attempts: number, context?: any);
}
export declare class NotEnoughConfirmations extends NxtpError {
    readonly context: any;
    static readonly type: string;
    static getMessage(required: number, hash: string, confs: number): string;
    constructor(required: number, hash: string, confs: number, context?: any);
}
export declare class GasEstimateInvalid extends NxtpError {
    readonly context: any;
    static readonly type: string;
    static getMessage(returned: string): string;
    constructor(returned: string, context?: any);
}
export declare class ChainNotSupported extends NxtpError {
    readonly chainId: string;
    readonly context: any;
    static readonly type: string;
    static getMessage(chainId: string): string;
    constructor(chainId: string, context?: any);
}
export declare class ProviderNotConfigured extends NxtpError {
    readonly chainId: string;
    readonly context: any;
    static readonly type: string;
    static getMessage(chainId: string): string;
    constructor(chainId: string, context?: any);
}
export declare class ConfigurationError extends NxtpError {
    readonly invalidParameters: {
        parameter: string;
        error: string;
        value: any;
    }[];
    readonly context: any;
    static readonly type: string;
    constructor(invalidParameters: {
        parameter: string;
        error: string;
        value: any;
    }[], context?: any);
}
export declare class InitialSubmitFailure extends NxtpError {
    readonly context: any;
    static readonly type: string;
    constructor(context?: any);
}
export declare class TransactionProcessingError extends NxtpError {
    readonly reason: Values<typeof TransactionProcessingError.reasons>;
    readonly method: string;
    readonly context: any;
    static readonly type: string;
    static readonly reasons: {
        SubmitOutOfOrder: string;
        MineOutOfOrder: string;
        ConfirmOutOfOrder: string;
        DuplicateHash: string;
        NoReceipt: string;
        NullReceipt: string;
        ReplacedButNoReplacement: string;
        DidNotThrowRevert: string;
        InsufficientConfirmations: string;
    };
    constructor(reason: Values<typeof TransactionProcessingError.reasons>, method: string, context?: any);
}
/**
 * Parses error strings into strongly typed NxtpError.
 * @param error from ethers.js package
 * @returns NxtpError
 */
export declare const parseError: (error: any) => NxtpError;
//# sourceMappingURL=errors.d.ts.map