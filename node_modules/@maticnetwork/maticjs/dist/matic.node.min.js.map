{"version":3,"sources":["webpack://Matic/webpack/bootstrap","webpack://Matic/external \"ethereumjs-util\"","webpack://Matic/./node_modules/safe-buffer/index.js","webpack://Matic/external \"@ethereumjs/common\"","webpack://Matic/external \"merkle-patricia-tree\"","webpack://Matic/external \"@ethereumjs/block\"","webpack://Matic/external \"buffer\"","webpack://Matic/external \"node-fetch\"","webpack://Matic/./src/abstracts/contract_method.ts","webpack://Matic/./src/enums/log_event_signature.ts","webpack://Matic/./src/enums/error_type.ts","webpack://Matic/./src/abstracts/base_web3_client.ts","webpack://Matic/./src/abstracts/base_contract.ts","webpack://Matic/./src/abstracts/base_big_number.ts","webpack://Matic/./src/implementation/bn.ts","webpack://Matic/./src/utils/use.ts","webpack://Matic/./src/utils/event_bus.ts","webpack://Matic/./src/utils/error_helper.ts","webpack://Matic/./src/utils/logger.ts","webpack://Matic/./src/utils/merge.ts","webpack://Matic/./src/utils/map_promise.ts","webpack://Matic/./src/constant.ts","webpack://Matic/./src/utils/merkle_tree.ts","webpack://Matic/./src/utils/proof_util.ts","webpack://Matic/./src/utils/http_request.ts","webpack://Matic/./src/utils/converter.ts","webpack://Matic/./src/utils/web3_side_chain_client.ts","webpack://Matic/./src/utils/promise_resolve.ts","webpack://Matic/./src/utils/base_token.ts","webpack://Matic/./src/services/abi_service.ts","webpack://Matic/./src/config.ts","webpack://Matic/./src/services/network_service.ts","webpack://Matic/./src/services/index.ts","webpack://Matic/./src/utils/set_proof_api_url.ts","webpack://Matic/./src/utils/resolve.ts","webpack://Matic/./src/utils/bridge_client.ts","webpack://Matic/./src/utils/abi_manager.ts","webpack://Matic/./src/utils/not_implemented.ts","webpack://Matic/./src/utils/zkevm_bridge_client.ts","webpack://Matic/./src/utils/index.ts","webpack://Matic/./src/pos/pos_token.ts","webpack://Matic/./src/pos/erc20.ts","webpack://Matic/./src/pos/root_chain_manager.ts","webpack://Matic/./src/pos/exit_util.ts","webpack://Matic/./src/pos/root_chain.ts","webpack://Matic/./src/pos/erc721.ts","webpack://Matic/./src/pos/erc1155.ts","webpack://Matic/./src/pos/gas_swapper.ts","webpack://Matic/./src/pos/index.ts","webpack://Matic/./src/default.ts","webpack://Matic/./src/zkevm/zkevm_token.ts","webpack://Matic/./src/zkevm/zkevm_custom_bridge.ts","webpack://Matic/./src/zkevm/erc20.ts","webpack://Matic/./src/zkevm/zkevm_bridge.ts","webpack://Matic/./src/zkevm/bridge_util.ts","webpack://Matic/./src/zkevm/zkevm_wrapper.ts","webpack://Matic/./src/zkevm/index.ts","webpack://Matic/./src/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","buffer","Buffer","copyProps","src","dst","SafeBuffer","arg","encodingOrOffset","length","from","alloc","allocUnsafe","allocUnsafeSlow","TypeError","size","fill","encoding","buf","undefined","SlowBuffer","Log_Event_Signature","ERROR_TYPE","logger","getRootHash","startBlock","endBlock","this","sendRPCRequest","jsonrpc","method","params","Number","id","Date","getTime","then","payload","String","result","getAccountsUsingRPC_","address","isBN","throwNotImplemented","toString","base","toNumber","toBuffer","add","sub","mul","div","lte","lt","gte","gt","eq","use","plugin","pluginInstance","setup","defaultExport","eventBusPromise","executor","promise","Promise","eventBus","EventBus","on","emit","ctx","_events","_ctx","event","cb","push","off","index","indexOf","splice","events","all","map","args","resolve","destroy","type","info","message","getMsg_","throw","errMsg","AllowedOnChild","AllowedOnRoot","AllowedOnMainnet","ProofAPINotSet","BurnTxNotCheckPointed","EIP1559NotSupported","NullSpenderAddress","Unknown","enableLog","isEnabled","log","console","error","merge","assign","obj","mapPromise","values","converter","option","valuesLength","concurrency","limitPromiseRun","promises","maps","val","runPromises","promiseResult","concat","promiseResolve","Permit","utils","sha3","keccak256","leaves","Error","depth","Math","ceil","Array","pow","zeros","layers","createHashes","nodes","treeLevel","left","right","data","getLeaves","getLayers","getRoot","getProof","leaf","compare","proof","siblingIndex","floor","verify","root","isArray","hash","node","getFastMerkleProof","web3","blockNumber","merkleTreeDepth","log2","reversedProof","targetIndex","offset","leftBound","rightBound","nLeaves","pivotLeaf","newLeftBound","queryRootHash","subTreeMerkleRoot","newRightBound","min","expectedHeight","recursiveZeroHash","subTreeHeight","heightDifference","remainingNodesHash","reverse","buildBlockProof","maticWeb3","ProofUtil","client","rootHash","catch","_","subHash","encodeParameters","getReceiptProof","receipt","block","requestConcurrency","receiptsVal","receiptPromise","stateSyncTxHash","getStateSyncTxHash","receiptsTrie","transactions","forEach","tx","transactionHash","getTransactionReceipt","receipts","siblingReceipt","path","encode","transactionIndex","rawReceipt","getReceiptBytes","put","findPath","remaining","blockHash","parentNodes","stack","raw","getRawHeader","receiptTrie","isTypedReceipt","decode","hexType","toHex","status","number","encodedData","cumulativeGasUsed","logsBloom","logs","topics","_block","difficulty","common","chain","Mainnet","hardfork","London","fromHeaderData","fetch","default","baseUrl","url","query","keys","encodeURIComponent","join","headers","res","json","post","body","JSON","stringify","amount","dataType","BN","slice","chainIdToConfigPath","1","5","137","80001","1442","1101","init","config","parent","defaultConfig","child","Web3Client","UnstoppableDomains","resolution","provider","network","version","abiManager","err","getABI","getConfig","isEIP1559Supported","chainId","promiseAny","promisesArray","promiseErrors","counter","reject","MAX_AMOUNT","ADDRESS_ZERO","DAI_PERMIT_TYPEHASH","EIP_2612_PERMIT_TYPEHASH","EIP_2612_DOMAIN_TYPEHASH","UNISWAP_DOMAIN_TYPEHASH","contractParam","getContract","contract_","bridgeType","abi","getContract_","isParent","tokenAddress","getChainId","chainId_","getClient","processWrite","validateTxOption_","createTransactionConfig","txConfig","isWrite","returnTransaction","encodeABI","to","write","sendTransaction","readTransaction","read","TransactionOptionNotObject","processRead","parentDefaultConfig","childDefaultConfig","clientChainId","maxFeePerGas","maxPriorityFeePerGas","isMaxFeeProvided","gasLimit","estimateGas","trunc","nonce","getTransactionCount","transferERC20","contract","transferERC721","tokenId","checkForNonNative","methodName","AllowedOnNonNativeTokens","checkForRoot","checkForChild","checkAdapterPresent","bridgeAdapterAddress","BridgeAdapterNotFound","transferERC1155","param","httpRequest","HttpRequest","contractName","getAddress","abiStoreUrl","zkEvmBridgeService","createUrlForPos","createUrlForZkEvm","getBlockIncluded","headerBlockNumber","decimalHeaderBlockNumber","parseInt","getExitProof","burnTxHash","eventSignature","start","end","getMerkleProofForZkEvm","networkID","depositCount","getBridgeTransactionDetails","deposit","service","setProofApi","setZkEvmProofApi","zkEvmNetwork","split","reduce","prev","curr","isCheckPointed","txHash","exitUtil","isDeposited","depositTxHash","token","lastStateId","targetLog","find","q","rootStateId","decodeParameters","rootStateIdBN","cache","networkName","targetBridgeABICache","abiForContract","setABI","abiStore","isDepositClaimable","rootChainBridge","bridgeUtil","getBridgeLogData","details","ready_for_claim","isWithdrawExitable","childChainBridge","isClaimed","isExited","BaseWeb3Client","getPOSContracts","rootChainManager","gasSwapper","getPredicateAddress","predicateAddress","tokenType","typeToPredicateMethod","isWithdrawn","getExitHash","exitHash","isExitProcessed","isWithdrawnOnIndex","withdrawExitPOS","isFast","buildPayloadForExit","exit","getContracts","getBalance","userAddress","getAllowance","spenderAddress","predicatePromise","approve","approveMax","amountInABI","depositWithGas","swapEthAmount","swapCallData","depositEther_","withdrawStart","withdrawExit_","burnTransactionHash","burnEventSignature","Erc20Transfer","withdrawExit","withdrawExitFaster","isWithdrawExited","transfer","client_","depositData","exitPayload","rootChain","maticClient_","getLogIndex_","logEventSig","logIndex","findIndex","toLowerCase","getAllLogIndices_","logIndices","getChainBlockInfo","getLastChildBlock","getTransaction","lastChildBlock","txBlockNumber","isCheckPointed_","getRootBlockInfo","rootBlockNumber","findRootBlockFromChild","rootBlockInfo","getRootBlockInfoFromAPI","headerBlock","getBlockProof","getBlockProofFromAPI","blockProof","getExitProofFromAPI","burnHash","exitProof","blockInfo","getBlockWithTransaction","rootBlockInfoResult","blockProofResult","receiptProof","encodePayload_","timestamp","transactionsRoot","receiptsRoot","buildMultiplePayloadsForExit","payloads","headerNumber","receiptParentNodes","blockResult","nibbleArr","byte","etheriumSha3","rootChainDefaultBlock","childBlockNumber","bigOne","bigtwo","checkPointInterval","currentHeaderBlock","ans","mid","headerStart","headerEnd","validateMany_","tokenIds","getTokensCount","options","count","getTokenIdAtIndexForUser","getAllTokens","limit","isApproved","isApprovedAll","approveAll","depositMany","tokensInHex","withdrawStartWithMetaData","withdrawStartMany","Erc721Transfer","withdrawExitOnIndex","isWithdrawExitedMany","Erc721BatchTransfer","isWithdrawExitedOnIndex","erc1155","getAddress_","addresses","addressConfig","approveAll_","predicateAddressPromise","approveAllForMintable","amounts","emptyHex","a","amountsInHex","Erc1155Transfer","withdrawExitMany","Erc1155BatchTransfer","withdrawExitFasterMany","depositAmount","mainPOSContracts","RootChainManagerProxy","mainPlasmaContracts","RootChainProxy","GasSwapper","RootChainManager","erc20","getContracts_","erc721","depositEther","POSClient","getZkEvmContracts","parentBridge","zkEVMWrapper","childBridge","bridgeToken","recipient","forceUpdateGlobalExitRoot","bridgeAdapter","getBridgeAddress","contractAddress","isEtherToken","isApprovalNeeded","getOriginTokenInfo","tokenInfo","permitData","networkId","bridgeAsset","ethGasAmount","v","depositPermitWithGas","now","getPermitSignatureParams_","signatureParams","depositWithPermit","getPermitData","depositCustomERC20","customERC20DepositClaim","buildPayloadForClaim","claimMessage","smtProof","mainnetExitRoot","rollupExitRoot","originNetwork","originTokenAddress","destinationNetwork","destinationAddress","metadata","depositClaim","claimAsset","withdraw","withdrawCustomERC20","customERC20WithdrawExit","withdrawWithPermit","getPermit","contractInstance","permitTypehash","DAI","DOMAIN_TYPEHASH","EIP712DOMAIN_HASH","domainTypehash","EIP_2612","UNISWAP","getTypedData_","permitType","account","typedData","types","EIP712Domain","primaryType","domain","verifyingContract","holder","spender","expiry","allowed","owner","deadline","getSignatureParameters_","signature","hexToNumber","includes","encodePermitFunctionData_","getAccounts","nameMethod","nonceMethod","signTypedData","getPermitData_","signatureParameters","ZkEvmToken","bridgeMessage","getMappedTokenInfo","precalculatedMappedTokenInfo","wrappedToken","networkID_","BRIDGE_TOPIC","decodedBridgeData_","filter","decodedData","inputs","leafType","getBridgeLogData_","getProof_","merkle_proof","main_exit_root","rollup_exit_root","mainZkEvmContracts","zkEvmContracts","PolygonZkEVMBridgeProxy","PolygonZkEVMBridge","ZkEVMWrapper"],"mappings":"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","file":"matic.node.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","module.exports = require(\"ethereumjs-util\");","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","module.exports = require(\"@ethereumjs/common\");","module.exports = require(\"merkle-patricia-tree\");","module.exports = require(\"@ethereumjs/block\");","module.exports = require(\"buffer\");","module.exports = require(\"node-fetch\");","import { ITransactionRequestConfig, ITransactionWriteResult } from \"../interfaces\";\nimport { Logger } from \"../utils\";\n\nexport abstract class BaseContractMethod {\n    constructor(public logger: Logger) {\n\n    }\n    abstract get address(): string;\n    abstract read<T>(tx?: ITransactionRequestConfig, defaultBlock?: number | string): Promise<T>;\n    abstract write(tx: ITransactionRequestConfig,): ITransactionWriteResult;\n    abstract estimateGas(tx: ITransactionRequestConfig,): Promise<number>;\n    abstract encodeABI(): any;\n}","export enum Log_Event_Signature {\n    // PlasmaErc20WithdrawEventSig = '0xebff2602b3f468259e1e99f613fed6691f3a6526effe6ef3e768ba7ae7a36c4f',\n    // PlasmaErc721WithdrawEventSig = '0x9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb',\n    Erc20Transfer = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n    Erc721Transfer = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n    Erc1155Transfer = '0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62',\n    Erc721BatchTransfer = '0xf871896b17e9cb7a64941c62c188a4f5c621b86800e3d15452ece01ce56073df',\n    Erc1155BatchTransfer = '0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb',\n    Erc721TransferWithMetadata = '0xf94915c6d1fd521cee85359239227480c7e8776d7caf1fc3bacad5c269b66a14',\n\n}","export enum ERROR_TYPE {\n    AllowedOnRoot = \"allowed_on_root\",\n    AllowedOnChild = \"allowed_on_child\",\n    Unknown = \"unknown\",\n    ProofAPINotSet = \"proof_api_not_set\",\n    TransactionOptionNotObject = \"transation_object_not_object\",\n    BurnTxNotCheckPointed = \"burn_tx_not_checkpointed\",\n    EIP1559NotSupported = \"eip-1559_not_supported\",\n    NullSpenderAddress = \"null_spender_address\",\n    AllowedOnNonNativeTokens = \"allowed_on_non_native_token\",\n    AllowedOnMainnet = \"allowed_on_mainnet\",\n    BridgeAdapterNotFound = \"bridge_adapter_address_not_passed\"\n}\n","import { BaseContract } from \"../abstracts\";\nimport { ITransactionRequestConfig, ITransactionReceipt, ITransactionData, IBlock, IBlockWithTransaction, IJsonRpcRequestPayload, IJsonRpcResponse, ITransactionWriteResult } from \"../interfaces\";\nimport { Logger } from \"../utils\";\n\nexport abstract class BaseWeb3Client {\n    abstract name: string;\n\n    constructor(public logger: Logger) {\n\n    }\n\n    abstract getContract(address: string, abi: any): BaseContract;\n\n    abstract read(config: ITransactionRequestConfig): Promise<string>;\n\n    abstract write(config: ITransactionRequestConfig): ITransactionWriteResult;\n    abstract getGasPrice(): Promise<string>;\n    abstract estimateGas(config: ITransactionRequestConfig): Promise<number>;\n    abstract getChainId(): Promise<number>;\n    abstract getTransactionCount(address: string, blockNumber: any): Promise<number>;\n\n    abstract getTransaction(transactionHash: string): Promise<ITransactionData>;\n    abstract getTransactionReceipt(transactionHash: string): Promise<ITransactionReceipt>;\n    // abstract extend(property: string, methods: IMethod[])\n\n    abstract getBlock(blockHashOrBlockNumber): Promise<IBlock>;\n    abstract getBlockWithTransaction(blockHashOrBlockNumber): Promise<IBlockWithTransaction>;\n    abstract hexToNumber(value: any): number;\n    abstract hexToNumberString(value: any): string;\n    abstract getBalance(address: string): string;\n    abstract getAccounts(): string[];\n    abstract signTypedData(signer: string, typedData: object): string;\n\n    getRootHash?(startBlock: number, endBlock: number) {\n        return this.sendRPCRequest({\n            jsonrpc: '2.0',\n            method: 'eth_getRootHash',\n            params: [Number(startBlock), Number(endBlock)],\n            id: new Date().getTime()\n        }).then(payload => {\n            return String(payload.result);\n        });\n    }\n\n    getAccountsUsingRPC_() {\n        return this.sendRPCRequest({\n            jsonrpc: '2.0',\n            method: 'eth_accounts',\n            params: [],\n            id: new Date().getTime()\n        }).then(payload => {\n            return payload.result;\n        });\n    }\n\n    abstract sendRPCRequest(request: IJsonRpcRequestPayload): Promise<IJsonRpcResponse>;\n\n    abstract encodeParameters(params: any[], types: any[]): string;\n    abstract decodeParameters(hexString: string, types: any[]): any[];\n    abstract etheriumSha3(...value): string;\n\n}\n","import { BaseContractMethod } from \"../abstracts\";\nimport { Logger } from \"../utils\";\n\nexport abstract class BaseContract {\n\n    constructor(public address: string, public logger:Logger) {\n\n    }\n\n    abstract method(methodName: string, ...args): BaseContractMethod;\n}","import { throwNotImplemented } from \"..\";\n\nexport abstract class BaseBigNumber {\n    static isBN(value) {\n        return throwNotImplemented<boolean>();\n    }\n\n    abstract toString(): string;\n    abstract toNumber(): number;\n    abstract toBuffer(): Buffer;\n    abstract add(value: BaseBigNumber): BaseBigNumber;\n    abstract sub(value: BaseBigNumber): BaseBigNumber;\n    abstract mul(value: BaseBigNumber): BaseBigNumber;\n    abstract div(value: BaseBigNumber): BaseBigNumber;\n\n    abstract lte(value: BaseBigNumber): boolean;\n    abstract lt(value: BaseBigNumber): boolean;\n    abstract gte(value: BaseBigNumber): boolean;\n    abstract gt(value: BaseBigNumber): boolean;\n    abstract eq(value: BaseBigNumber): boolean;\n}","import { throwNotImplemented } from \"..\";\nimport { BaseBigNumber } from \"../abstracts\";\n\nexport class EmptyBigNumber extends BaseBigNumber {\n\n    constructor(value) {\n        super();\n    }\n\n    toString(base?) {\n        return throwNotImplemented<string>();\n    }\n\n    toNumber() {\n        return throwNotImplemented<number>();\n    }\n\n    toBuffer(base?) {\n        return throwNotImplemented<Buffer>();\n    }\n\n    add(value: BaseBigNumber) {\n        return throwNotImplemented<BaseBigNumber>();\n    }\n\n    sub(value: BaseBigNumber) {\n        return throwNotImplemented<BaseBigNumber>();\n    }\n\n    mul(value: BaseBigNumber) {\n        return throwNotImplemented<BaseBigNumber>();\n    }\n\n    div(value: BaseBigNumber) {\n        return throwNotImplemented<BaseBigNumber>();\n    }\n\n    lte(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n    }\n\n    lt(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n\n    }\n\n    gte(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n\n    }\n\n    gt(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n\n    }\n\n    eq(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n    }\n}","import { IPlugin } from \"../interfaces\";\nimport { defaultExport } from \"../default\";\n\nexport const use = (plugin, ...payload) => {\n    const pluginInstance: IPlugin = typeof plugin === \"function\" ? new plugin() : plugin;\n    return pluginInstance.setup(defaultExport, ...payload);\n};","export interface IEventBusPromise<T> extends Promise<T> {\n    on(event: string, cb: Function);\n    emit(event: string, ...args);\n    destroy();\n}\n\nexport const eventBusPromise = function <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void) {\n    const promise: IEventBusPromise<T> = new Promise(executor) as any;\n    const eventBus = new EventBus();\n    promise.on = eventBus.on.bind(eventBus);\n    promise.emit = eventBus.emit.bind(eventBus);\n    return promise;\n};\n\nexport class EventBus {\n\n    constructor(ctx?) {\n        this._ctx = ctx;\n    }\n\n    private _ctx;\n\n    private _events: {\n        [key: string]: Function[]\n    } = {};\n\n    on(event: string, cb: Function) {\n        if (this._events[event] == null) {\n            this._events[event] = [];\n        }\n        this._events[event].push(cb);\n        return this;\n    }\n\n    off(event: string, cb: Function) {\n        if (this._events[event]) {\n            if (cb) {\n                const index = this._events[event].indexOf(cb);\n                this._events[event].splice(index, 1);\n            }\n            else {\n                this._events[event] = [];\n            }\n        }\n    }\n\n    emit(event: string, ...args) {\n        const events = this._events[event] || [];\n        return Promise.all(\n            events.map(cb => {\n                const result = cb.call(this._ctx, ...args);\n                return result && result.then ? result : Promise.resolve(result);\n            })\n        );\n    }\n\n    destroy() {\n        this._events = null;\n        this._ctx = null;\n    }\n}","import { ERROR_TYPE } from \"../enums\";\nimport { IError } from \"../interfaces\";\n\nexport class ErrorHelper implements IError {\n    type: ERROR_TYPE;\n    message: string;\n\n    constructor(type: ERROR_TYPE, info?) {\n        this.type = type;\n        this.message = this.getMsg_(info);\n    }\n\n    throw() {\n        throw this.get();\n    }\n\n    get() {\n        return {\n            message: this.message,\n            type: this.type\n        } as IError;\n    }\n\n    private getMsg_(info) {\n        let errMsg: string;\n        switch (this.type) {\n            case ERROR_TYPE.AllowedOnChild:\n                errMsg = `The action ${info} is allowed only on child token.`;\n                break;\n            case ERROR_TYPE.AllowedOnRoot:\n                errMsg = `The action ${info} is allowed only on root token.`;\n                break;\n            case ERROR_TYPE.AllowedOnMainnet:\n                errMsg = `The action is allowed only on mainnet chains.`;\n                break;\n            case ERROR_TYPE.ProofAPINotSet:\n                errMsg = `Proof api is not set, please set it using \"setProofApi\"`;\n                break;\n            case ERROR_TYPE.BurnTxNotCheckPointed:\n                errMsg = `Burn transaction has not been checkpointed as yet`;\n                break;\n            case ERROR_TYPE.EIP1559NotSupported:\n                errMsg = `${info ? 'Root' : 'Child'} chain doesn't support eip-1559`;\n                break;\n            case ERROR_TYPE.NullSpenderAddress:\n                errMsg = `Please provide spender address.`;\n                break;\n            default:\n                if (!this.type) {\n                    this.type = ERROR_TYPE.Unknown;\n                }\n                errMsg = this.message;\n                break;\n        }\n        return errMsg;\n    }\n}","import { ERROR_TYPE } from \"../enums\";\nimport { ErrorHelper } from \"./error_helper\";\n\nexport class Logger {\n\n    private isEnabled: boolean;\n\n    enableLog(value) {\n        this.isEnabled = value ? true : false;\n    }\n\n    log(...message) {\n        if (this.isEnabled) {\n            console.log(...message);\n        }\n    }\n\n    error(type: ERROR_TYPE, info?) {\n        return new ErrorHelper(type, info);\n    }\n}","export const merge = (...obj) => {\n    return Object.assign({}, ...obj);\n};","import { promiseResolve } from '..';\nimport { IMapPromiseOption } from '../interfaces';\n\nconst runPromises = (promises: Array<Promise<any>>, converter: Function) => {\n  const maps = promises.map((val, index) => {\n    return converter(val, index);\n  });\n  return Promise.all(maps);\n};\n\nexport function mapPromise(values: any[], converter: Function, option: IMapPromiseOption = {} as any) {\n  const valuesLength = values.length;\n  const concurrency = option.concurrency || valuesLength;\n\n  let result = [];\n  const limitPromiseRun: () => Promise<any> = () => {\n    const promises = values.splice(0, concurrency);\n    return runPromises(promises, converter).then(promiseResult => {\n      result = result.concat(promiseResult);\n\n      return valuesLength > result.length ?\n        limitPromiseRun() : promiseResolve(result);\n    });\n  };\n\n  return limitPromiseRun();\n}\n","export const MAX_AMOUNT = '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';\nexport const ADDRESS_ZERO = '0x0000000000000000000000000000000000000000';\nexport const DAI_PERMIT_TYPEHASH = \"0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb\";\nexport const EIP_2612_PERMIT_TYPEHASH = \"0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9\";\nexport const EIP_2612_DOMAIN_TYPEHASH = \"0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f\";\nexport const UNISWAP_DOMAIN_TYPEHASH = \"0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866\";\nexport enum Permit {\n    DAI = \"DAI\",\n    EIP_2612 = \"EIP_2612\",\n    UNISWAP = \"UNISWAP\",\n}\n","const utils = require('ethereumjs-util');\n// const SafeBuffer = require('safe-buffer').Buffer;\nconst sha3 = utils.keccak256;\n\nimport { Buffer as SafeBuffer } from \"safe-buffer\";\n\nexport class MerkleTree {\n    leaves: any;\n    layers: any;\n\n    constructor(leaves = []) {\n        if (leaves.length < 1) {\n            throw new Error('Atleast 1 leaf needed');\n        }\n\n        const depth = Math.ceil(Math.log(leaves.length) / Math.log(2));\n        if (depth > 20) {\n            throw new Error('Depth must be 20 or less');\n        }\n\n        this.leaves = leaves.concat(\n            Array.from(\n                // tslint:disable-next-line\n                Array(Math.pow(2, depth) - leaves.length),\n                () => utils.zeros(32)\n            )\n        );\n        this.layers = [this.leaves];\n        this.createHashes(this.leaves);\n    }\n\n    createHashes(nodes) {\n        if (nodes.length === 1) {\n            return false;\n        }\n\n\n        const treeLevel = [];\n        for (let i = 0; i < nodes.length; i += 2) {\n            const left = nodes[i];\n            const right = nodes[i + 1];\n\n            const data = SafeBuffer.concat([left, right]);\n            treeLevel.push(sha3(data));\n        }\n\n        // is odd number of nodes\n        if (nodes.length % 2 === 1) {\n            treeLevel.push(nodes[nodes.length - 1]);\n        }\n\n        this.layers.push(treeLevel);\n        this.createHashes(treeLevel);\n    }\n\n    getLeaves() {\n        return this.leaves;\n    }\n\n    getLayers() {\n        return this.layers;\n    }\n\n    getRoot() {\n        return this.layers[this.layers.length - 1][0];\n    }\n\n    getProof(leaf) {\n        let index = -1;\n        for (let i = 0; i < this.leaves.length; i++) {\n            if (SafeBuffer.compare(leaf, this.leaves[i]) === 0) {\n                index = i;\n            }\n        }\n\n        const proof = [];\n        if (index <= this.getLeaves().length) {\n            let siblingIndex;\n            for (let i = 0; i < this.layers.length - 1; i++) {\n                if (index % 2 === 0) {\n                    siblingIndex = index + 1;\n                } else {\n                    siblingIndex = index - 1;\n                }\n                index = Math.floor(index / 2);\n                proof.push(this.layers[i][siblingIndex]);\n            }\n        }\n        return proof;\n    }\n\n    verify(value, index, root, proof) {\n        if (!Array.isArray(proof) || !value || !root) {\n            return false;\n        }\n\n        let hash = value;\n        for (let i = 0; i < proof.length; i++) {\n            const node = proof[i];\n            if (index % 2 === 0) {\n                hash = sha3(SafeBuffer.concat([hash, node]));\n            } else {\n                hash = sha3(SafeBuffer.concat([node, hash]));\n            }\n\n            index = Math.floor(index / 2);\n        }\n\n        return SafeBuffer.compare(hash, root) === 0;\n    }\n}\n\n","import { BaseWeb3Client } from \"../abstracts\";\nimport { MerkleTree } from \"./merkle_tree\";\nimport { bufferToHex, keccak256, rlp, setLengthLeft, toBuffer } from \"ethereumjs-util\";\nimport { ITransactionReceipt, IBlock, IBlockWithTransaction } from \"../interfaces\";\nimport { mapPromise } from \"./map_promise\";\nimport { BaseTrie as TRIE } from 'merkle-patricia-tree';\nimport { BlockHeader } from '@ethereumjs/block';\nimport { Converter, promiseResolve, utils } from \"..\";\nimport Common, { Chain, Hardfork } from '@ethereumjs/common';\n\n// Implementation adapted from Tom French's `matic-proofs` library used under MIT License\n// https://github.com/TomAFrench/matic-proofs\n\nexport class ProofUtil {\n\n    static async getFastMerkleProof(\n        web3: BaseWeb3Client,\n        blockNumber: number,\n        startBlock: number,\n        endBlock: number\n    ): Promise<string[]> {\n        const merkleTreeDepth = Math.ceil(Math.log2(endBlock - startBlock + 1));\n\n        // We generate the proof root down, whereas we need from leaf up\n        const reversedProof: string[] = [];\n\n        const offset = startBlock;\n        const targetIndex = blockNumber - offset;\n        let leftBound = 0;\n        let rightBound = endBlock - offset;\n        //   console.log(\"Searching for\", targetIndex);\n        for (let depth = 0; depth < merkleTreeDepth; depth += 1) {\n            const nLeaves = 2 ** (merkleTreeDepth - depth);\n\n            // The pivot leaf is the last leaf which is included in the left subtree\n            const pivotLeaf = leftBound + nLeaves / 2 - 1;\n\n            if (targetIndex > pivotLeaf) {\n                // Get the root hash to the merkle subtree to the left\n                const newLeftBound = pivotLeaf + 1;\n                // eslint-disable-next-line no-await-in-loop\n                const subTreeMerkleRoot = await this.queryRootHash(web3, offset + leftBound, offset + pivotLeaf);\n                reversedProof.push(subTreeMerkleRoot);\n                leftBound = newLeftBound;\n            } else {\n                // Things are more complex when querying to the right.\n                // Root hash may come some layers down so we need to build a full tree by padding with zeros\n                // Some trees may be completely empty\n\n                const newRightBound = Math.min(rightBound, pivotLeaf);\n\n                // Expect the merkle tree to have a height one less than the current layer\n                const expectedHeight = merkleTreeDepth - (depth + 1);\n                if (rightBound <= pivotLeaf) {\n                    // Tree is empty so we repeatedly hash zero to correct height\n                    const subTreeMerkleRoot = this.recursiveZeroHash(expectedHeight, web3);\n                    reversedProof.push(subTreeMerkleRoot);\n                } else {\n                    // Height of tree given by RPC node\n                    const subTreeHeight = Math.ceil(Math.log2(rightBound - pivotLeaf));\n\n                    // Find the difference in height between this and the subtree we want\n                    const heightDifference = expectedHeight - subTreeHeight;\n\n                    // For every extra layer we need to fill 2*n leaves filled with the merkle root of a zero-filled Merkle tree\n                    // We need to build a tree which has heightDifference layers\n\n                    // The first leaf will hold the root hash as returned by the RPC\n                    // eslint-disable-next-line no-await-in-loop\n                    const remainingNodesHash = await this.queryRootHash(web3, offset + pivotLeaf + 1, offset + rightBound);\n\n                    // The remaining leaves will hold the merkle root of a zero-filled tree of height subTreeHeight\n                    const leafRoots = this.recursiveZeroHash(subTreeHeight, web3);\n\n                    // Build a merkle tree of correct size for the subtree using these merkle roots\n                    const leaves = Array.from({ length: 2 ** heightDifference }, () => toBuffer(leafRoots));\n                    leaves[0] = remainingNodesHash;\n                    const subTreeMerkleRoot = new MerkleTree(leaves).getRoot();\n                    reversedProof.push(subTreeMerkleRoot);\n                }\n                rightBound = newRightBound;\n            }\n        }\n\n        return reversedProof.reverse();\n    }\n\n    static buildBlockProof(maticWeb3: BaseWeb3Client, startBlock: number, endBlock: number, blockNumber: number) {\n        return ProofUtil.getFastMerkleProof(\n            maticWeb3, blockNumber, startBlock, endBlock\n        ).then(proof => {\n            return bufferToHex(\n                Buffer.concat(\n                    proof.map(p => {\n                        return toBuffer(p);\n                    })\n                )\n            );\n        });\n    }\n\n    static queryRootHash(client: BaseWeb3Client, startBlock: number, endBlock: number) {\n        return client.getRootHash(startBlock, endBlock).then(rootHash => {\n            return toBuffer(`0x${rootHash}`);\n        }).catch(_ => {\n            return null;\n        });\n    }\n\n    static recursiveZeroHash(n: number, client: BaseWeb3Client) {\n        if (n === 0) return '0x0000000000000000000000000000000000000000000000000000000000000000';\n        const subHash = this.recursiveZeroHash(n - 1, client);\n        return keccak256(\n            toBuffer(client.encodeParameters([subHash, subHash], ['bytes32', 'bytes32'],))\n        );\n    }\n\n    static getReceiptProof(receipt: ITransactionReceipt, block: IBlockWithTransaction, web3: BaseWeb3Client, requestConcurrency = Infinity, receiptsVal?: ITransactionReceipt[]) {\n        const stateSyncTxHash = bufferToHex(ProofUtil.getStateSyncTxHash(block));\n        const receiptsTrie = new TRIE();\n        let receiptPromise: Promise<ITransactionReceipt[]>;\n        if (!receiptsVal) {\n            const receiptPromises = [];\n            block.transactions.forEach(tx => {\n                if (tx.transactionHash === stateSyncTxHash) {\n                    // ignore if tx hash is bor state-sync tx\n                    return;\n                }\n                receiptPromises.push(\n                    web3.getTransactionReceipt(tx.transactionHash)\n                );\n            });\n            receiptPromise = mapPromise(\n                receiptPromises,\n                val => {\n                    return val;\n                },\n                {\n                    concurrency: requestConcurrency,\n                }\n            );\n        }\n        else {\n            receiptPromise = promiseResolve(receiptsVal);\n        }\n\n        return receiptPromise.then(receipts => {\n            return Promise.all(\n                receipts.map(siblingReceipt => {\n                    const path = rlp.encode(siblingReceipt.transactionIndex);\n                    const rawReceipt = ProofUtil.getReceiptBytes(siblingReceipt);\n                    return receiptsTrie.put(path, rawReceipt);\n                })\n            );\n        }).then(_ => {\n            return receiptsTrie.findPath(rlp.encode(receipt.transactionIndex), true);\n        }).then(result => {\n            if (result.remaining.length > 0) {\n                throw new Error('Node does not contain the key');\n            }\n            // result.node.value\n            const prf = {\n                blockHash: toBuffer(receipt.blockHash),\n                parentNodes: result.stack.map(s => s.raw()),\n                root: ProofUtil.getRawHeader(block).receiptTrie,\n                path: rlp.encode(receipt.transactionIndex),\n                value: ProofUtil.isTypedReceipt(receipt) ? result.node.value : rlp.decode(result.node.value)\n            };\n            return prf;\n        });\n    }\n\n    static isTypedReceipt(receipt: ITransactionReceipt) {\n        const hexType = Converter.toHex(receipt.type);\n        return receipt.status != null && hexType !== \"0x0\" && hexType !== \"0x\";\n    }\n\n    // getStateSyncTxHash returns block's tx hash for state-sync receipt\n    // Bor blockchain includes extra receipt/tx for state-sync logs,\n    // but it is not included in transactionRoot or receiptRoot.\n    // So, while calculating proof, we have to exclude them.\n    //\n    // This is derived from block's hash and number\n    // state-sync tx hash = keccak256(\"matic-bor-receipt-\" + block.number + block.hash)\n    static getStateSyncTxHash(block): Buffer {\n        return keccak256(\n            Buffer.concat([\n                // prefix for bor receipt\n                Buffer.from('matic-bor-receipt-', 'utf-8'),\n                setLengthLeft(toBuffer(block.number), 8), // 8 bytes of block number (BigEndian)\n                toBuffer(block.hash), // block hash\n            ])\n        );\n    }\n\n    static getReceiptBytes(receipt: ITransactionReceipt) {\n        let encodedData = rlp.encode([\n            toBuffer(\n                receipt.status !== undefined && receipt.status != null ? (receipt.status ? '0x1' : '0x') : receipt.root\n            ),\n            toBuffer(receipt.cumulativeGasUsed),\n            toBuffer(receipt.logsBloom),\n            // encoded log array\n            receipt.logs.map(l => {\n                // [address, [topics array], data]\n                return [\n                    toBuffer(l.address), // convert address to buffer\n                    l.topics.map(toBuffer), // convert topics to buffer\n                    toBuffer(l.data), // convert data to buffer\n                ];\n            }),\n        ]);\n        if (ProofUtil.isTypedReceipt(receipt)) {\n            encodedData = Buffer.concat([toBuffer(receipt.type), encodedData]);\n        }\n        return encodedData;\n    }\n\n    static getRawHeader(_block) {\n        _block.difficulty = Converter.toHex(_block.difficulty) as any;\n        const common = new Common({\n            chain: Chain.Mainnet, hardfork: Hardfork.London\n        });\n        const rawHeader = BlockHeader.fromHeaderData(_block, {\n            common: common\n        });\n        return rawHeader;\n    }\n}\n","const fetch: (input: RequestInfo, init?: RequestInit) => Promise<Response> =\n    (() => {\n        if (process.env.BUILD_ENV === \"node\") {\n            return require('node-fetch').default;\n        }\n        return window.fetch;\n    })();\n\n\nexport class HttpRequest {\n    baseUrl = \"\";\n\n    constructor(option: { baseUrl: string } | string = {} as any) {\n        option = typeof option === \"string\" ? {\n            baseUrl: option\n        } : option;\n\n        if (option.baseUrl) {\n            this.baseUrl = option.baseUrl;\n        }\n    }\n\n    get<T>(url = \"\", query = {}): Promise<T> {\n        url = this.baseUrl + url + Object.keys(query).\n            map(key => `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`).join('&');\n\n        return fetch(url, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json'\n            }\n        }).then(res => {\n            return res.json();\n        });\n    }\n\n    post(url = \"\", body) {\n        url = this.baseUrl + url;\n\n        return fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json'\n            },\n            body: body ? JSON.stringify(body) : null\n        }).then(res => {\n            return res.json();\n        });\n    }\n}","import { BaseBigNumber } from \"../abstracts\";\nimport { utils } from \"../utils\";\n\nexport class Converter {\n    static toHex(amount: BaseBigNumber | string | number) {\n        const dataType = typeof amount;\n        if (dataType === 'number') {\n            amount = new utils.BN(amount);\n        } else if (dataType === 'string') {\n            if ((amount as string).slice(0, 2) === '0x') {\n                return amount;\n            }\n            amount = new utils.BN(amount);\n        }\n        if (utils.BN.isBN(amount)) {\n            return '0x' + amount.toString(16);\n        }\n        else {\n            throw new Error(`Invalid value ${amount}, value is not a number.`);\n        }\n    }\n}\n","import { IBaseClientConfig } from \"../interfaces\";\nimport { BaseWeb3Client } from \"../abstracts\";\nimport { ABIManager } from \"../utils\";\nimport { Logger } from \"./logger\";\nimport { utils } from \"..\";\n\nconst chainIdToConfigPath = {\n    1: 'Main',\n    5: 'Main',\n    137: 'Matic',\n    80001: 'Matic',\n    1442: 'zkEVM',\n    1101: 'zkEVM'\n};\n\nexport class Web3SideChainClient<T_CONFIG> {\n    parent: BaseWeb3Client;\n    child: BaseWeb3Client;\n\n    config: T_CONFIG;\n\n    abiManager: ABIManager;\n\n    logger = new Logger();\n    resolution: {};\n\n    init(config: IBaseClientConfig) {\n        config = config || {} as any;\n        config.parent.defaultConfig = config.parent.defaultConfig || {} as any;\n        config.child.defaultConfig = config.child.defaultConfig || {} as any;\n        this.config = config as any;\n\n        // tslint:disable-next-line\n        const Web3Client = utils.Web3Client;\n\n        if (!Web3Client) {\n            throw new Error(\"Web3Client is not set\");\n        }\n\n        if (utils.UnstoppableDomains) {\n            this.resolution = utils.UnstoppableDomains;\n        }\n\n        this.parent = new (Web3Client as any)(config.parent.provider, this.logger);\n        this.child = new (Web3Client as any)(config.child.provider, this.logger);\n\n        this.logger.enableLog(config.log);\n\n        const network = config.network;\n        const version = config.version;\n        const abiManager = this.abiManager =\n            new ABIManager(network, version);\n        this.logger.log(\"init called\", abiManager);\n        return abiManager.init().catch(err => {\n            throw new Error(`network ${network} - ${version} is not supported`);\n        });\n    }\n\n    getABI(name: string, type?: string) {\n        return this.abiManager.getABI(name, type);\n    }\n\n    getConfig(path: string) {\n        return this.abiManager.getConfig(path);\n    }\n\n    get mainPlasmaContracts() {\n        return this.getConfig(\"Main.Contracts\");\n    }\n\n    get mainPOSContracts() {\n        return this.getConfig(\"Main.POSContracts\");\n    }\n\n    get mainZkEvmContracts() {\n        return this.getConfig(\"Main.Contracts\");\n    }\n\n    get zkEvmContracts() {\n        return this.getConfig(\"zkEVM.Contracts\");\n    }\n\n    isEIP1559Supported(chainId: number): boolean {\n        return this.getConfig(`${chainIdToConfigPath[chainId]}.SupportsEIP1559`);\n    }\n\n}\n","export const promiseResolve = <T>(value?) => {\n    return Promise.resolve<T>(value);\n};\n\nexport const promiseAny = (promisesArray) => {\n    const promiseErrors = new Array(promisesArray.length);\n    let counter = 0;\n\n    //return a new promise\n    return new Promise((resolve, reject) => {\n        promisesArray.forEach((promise) => {\n            Promise.resolve(promise)\n                .then(resolve) // resolve, when any of the input promise resolves\n                .catch((error) => {\n                    promiseErrors[counter] = error;\n                    counter = counter + 1;\n                    if (counter === promisesArray.length) {\n                        // all promises rejected, reject outer promise\n                        reject(promiseErrors);\n                    }\n                }); // reject, when any of the input promise rejects\n        });\n    });\n};\n","import { Web3SideChainClient } from \"./web3_side_chain_client\";\nimport { ITransactionRequestConfig, ITransactionOption, IContractInitParam, IBaseClientConfig, ITransactionWriteResult } from \"../interfaces\";\nimport { BaseContractMethod, BaseContract } from \"../abstracts\";\nimport { Converter, merge, utils } from \"../utils\";\nimport { promiseResolve } from \"./promise_resolve\";\nimport { ERROR_TYPE } from \"../enums\";\nimport { POSERC1155TransferParam, TYPE_AMOUNT } from \"../types\";\nimport { ErrorHelper } from \"./error_helper\";\nimport { ADDRESS_ZERO } from '../constant';\n\nexport interface ITransactionConfigParam {\n    txConfig: ITransactionRequestConfig;\n    method?: BaseContractMethod;\n    isWrite?: boolean;\n    isParent?: boolean;\n}\n\nexport class BaseToken<T_CLIENT_CONFIG> {\n\n    private contract_: BaseContract;\n    private chainId_: number;\n\n    constructor(\n        protected contractParam: IContractInitParam,\n        protected client: Web3SideChainClient<T_CLIENT_CONFIG>,\n    ) {\n    }\n\n    get contractAddress() {\n        return this.contractParam.address;\n    }\n\n    getContract(): Promise<BaseContract> {\n        if (this.contract_) {\n            return promiseResolve<BaseContract>(this.contract_ as any);\n        }\n        const contractParam = this.contractParam;\n        return this.client.getABI(\n            contractParam.name,\n            contractParam.bridgeType,\n        ).then(abi => {\n            this.contract_ = this.getContract_({\n                abi,\n                isParent: contractParam.isParent,\n                tokenAddress: contractParam.address\n            });\n            return this.contract_;\n        });\n    }\n\n    getChainId(): Promise<number> {\n        if (this.chainId_) {\n            return promiseResolve<number>(this.chainId_ as any);\n        }\n        const client = this.getClient(this.contractParam.isParent);\n        return client.getChainId().then(chainId => {\n            this.chainId_ = chainId;\n            return this.chainId_;\n        });\n    }\n\n    protected processWrite(method: BaseContractMethod, option: ITransactionOption = {}): Promise<ITransactionWriteResult> {\n        this.validateTxOption_(option);\n\n        this.client.logger.log(\"process write\");\n        return this.createTransactionConfig(\n            {\n                txConfig: option,\n                isWrite: true,\n                method,\n                isParent: this.contractParam.isParent\n            }).then(config => {\n                this.client.logger.log(\"process write config\");\n                if (option.returnTransaction) {\n                    return merge(config, {\n                        data: method.encodeABI(),\n                        to: method.address\n                    } as ITransactionRequestConfig);\n                }\n                const methodResult = method.write(\n                    config,\n                );\n                return methodResult;\n            });\n    }\n\n    protected sendTransaction(option: ITransactionOption = {}): Promise<ITransactionWriteResult> {\n        this.validateTxOption_(option);\n\n        const isParent = this.contractParam.isParent;\n        const client = this.getClient(isParent);\n        client.logger.log(\"process write\");\n\n        return this.createTransactionConfig(\n            {\n                txConfig: option,\n                isWrite: true,\n                method: null as any,\n                isParent: this.contractParam.isParent\n            }).then(config => {\n                client.logger.log(\"process write config\");\n                if (option.returnTransaction) {\n                    return config as any;\n                }\n                const methodResult = client.write(\n                    config,\n                );\n                return methodResult;\n            });\n    }\n\n    protected readTransaction(option: ITransactionOption = {}): Promise<ITransactionWriteResult> {\n        this.validateTxOption_(option);\n        const isParent = this.contractParam.isParent;\n        const client = this.getClient(isParent);\n        client.logger.log(\"process read\");\n        return this.createTransactionConfig(\n            {\n                txConfig: option,\n                isWrite: true,\n                method: null as any,\n                isParent: this.contractParam.isParent\n            }).then(config => {\n                client.logger.log(\"write tx config created\");\n                if (option.returnTransaction) {\n                    return config as any;\n                }\n                return client.read(\n                    config,\n                );\n            });\n    }\n\n    private validateTxOption_(option: ITransactionOption) {\n        if (typeof option !== 'object' || Array.isArray(option)) {\n            new ErrorHelper(ERROR_TYPE.TransactionOptionNotObject).throw();\n        }\n    }\n\n    protected processRead<T>(method: BaseContractMethod, option: ITransactionOption = {}): Promise<T> {\n        this.validateTxOption_(option);\n        this.client.logger.log(\"process read\");\n        return this.createTransactionConfig(\n            {\n                txConfig: option,\n                isWrite: false,\n                method,\n                isParent: this.contractParam.isParent\n            }).then(config => {\n                this.client.logger.log(\"read tx config created\");\n                if (option.returnTransaction) {\n                    return merge(config, {\n                        data: method.encodeABI(),\n                        to: this.contract_.address\n                    } as ITransactionRequestConfig);\n                }\n                return method.read(\n                    config,\n                );\n            });\n    }\n\n    protected getClient(isParent) {\n        return isParent ? this.client.parent :\n            this.client.child;\n    }\n\n    private getContract_({ isParent, tokenAddress, abi }) {\n        const client = this.getClient(isParent);\n        return client.getContract(tokenAddress, abi);\n    }\n\n    protected get parentDefaultConfig() {\n        const config: IBaseClientConfig = this.client.config as any;\n        return config.parent.defaultConfig;\n    }\n\n    protected get childDefaultConfig() {\n        const config: IBaseClientConfig = this.client.config as any;\n        return config.child.defaultConfig;\n    }\n\n    protected createTransactionConfig({ txConfig, method, isParent, isWrite }: ITransactionConfigParam) {\n        const defaultConfig = isParent ? this.parentDefaultConfig : this.childDefaultConfig;\n        txConfig = merge(defaultConfig, (txConfig || {}));\n        const client = isParent ? this.client.parent :\n            this.client.child;\n        client.logger.log(\"txConfig\", txConfig, \"onRoot\", isParent, \"isWrite\", isWrite);\n        const estimateGas = async (config: ITransactionRequestConfig) => {\n            const result = method ? await method.estimateGas(config) : await client.estimateGas(config);\n            return new utils.BN(Math.trunc(Number(result) * 1.15)).toString();\n        };\n        // txConfig.chainId = Converter.toHex(txConfig.chainId) as any;\n        if (isWrite) {\n            return this.getChainId().then(clientChainId => {\n                const { maxFeePerGas, maxPriorityFeePerGas } = txConfig;\n\n                const isEIP1559Supported = this.client.isEIP1559Supported(clientChainId);\n                const isMaxFeeProvided = (maxFeePerGas || maxPriorityFeePerGas);\n                txConfig.chainId = txConfig.chainId || clientChainId;\n\n                if (!isEIP1559Supported && isMaxFeeProvided) {\n                    client.logger.error(ERROR_TYPE.EIP1559NotSupported, isParent).throw();\n                }\n                // const [gasLimit, nonce] = \n                return Promise.all([\n                    !(txConfig.gasLimit)\n                        ? estimateGas({\n                            from: txConfig.from, value: txConfig.value, to: txConfig.to\n                        })\n                        : txConfig.gasLimit,\n                    !txConfig.nonce ?\n                        client.getTransactionCount(txConfig.from, 'pending')\n                        : txConfig.nonce\n                ]).then(result => {\n                    const [gasLimit, nonce] = result;\n                    client.logger.log(\"options filled\");\n\n                    txConfig.gasLimit = Number(gasLimit);\n                    txConfig.nonce = nonce;\n                    return txConfig;\n                });\n            });\n        }\n        return promiseResolve<ITransactionRequestConfig>(txConfig);\n    }\n\n    protected transferERC20(to: string, amount: TYPE_AMOUNT, option?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"transfer\",\n                to,\n                Converter.toHex(amount)\n            );\n            return this.processWrite(\n                method, option\n            );\n        });\n    }\n\n    protected transferERC721(from: string, to: string, tokenId: string, option: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"transferFrom\",\n                from,\n                to,\n                tokenId\n            );\n            return this.processWrite(\n                method, option\n            );\n        });\n    }\n\n    protected checkForNonNative(methodName) {\n        if (this.contractParam.address === ADDRESS_ZERO) {\n            this.client.logger.error(ERROR_TYPE.AllowedOnNonNativeTokens, methodName).throw();\n        }\n    }\n\n    protected checkForRoot(methodName) {\n        if (!this.contractParam.isParent) {\n            this.client.logger.error(ERROR_TYPE.AllowedOnRoot, methodName).throw();\n        }\n    }\n\n    protected checkForChild(methodName) {\n        if (this.contractParam.isParent) {\n            this.client.logger.error(ERROR_TYPE.AllowedOnChild, methodName).throw();\n        }\n    }\n\n    protected checkAdapterPresent(methodName) {\n        if (!this.contractParam.bridgeAdapterAddress) {\n            this.client.logger.error(ERROR_TYPE.BridgeAdapterNotFound, methodName).throw();\n        }\n    }\n\n    protected transferERC1155(param: POSERC1155TransferParam, option: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"safeTransferFrom\",\n                param.from,\n                param.to,\n                Converter.toHex(param.tokenId),\n                Converter.toHex(param.amount),\n                param.data || '0x'\n            );\n            return this.processWrite(\n                method, option\n            );\n        });\n    }\n\n}\n","import { HttpRequest } from \"../utils\";\n\nexport class ABIService {\n    httpRequest: HttpRequest;\n\n    constructor(baseUrl: string) {\n        this.httpRequest = new HttpRequest(baseUrl);\n    }\n\n    getABI(network: string, version: string, bridgeType: string, contractName: string) {\n        const url = `${network}/${version}/artifacts/${bridgeType}/${contractName}.json`;\n        return this.httpRequest.get(url).then((result: any) => {\n            return result.abi;\n        });\n    }\n\n    getAddress(network: string, version: string) {\n        const url = `${network}/${version}/index.json`;\n        return this.httpRequest.get(url);\n    }\n}\n","export const config = {\n  abiStoreUrl: 'https://static.polygon.technology/network/',\n  zkEvmBridgeService: 'https://proof-generator.polygon.technology/',\n}\n","import { BaseBigNumber, utils } from \"..\";\nimport { HttpRequest } from \"../utils\";\n\nexport class NetworkService {\n    httpRequest: HttpRequest;\n\n    constructor(baseUrl: string) {\n        this.httpRequest = new HttpRequest(baseUrl);\n    }\n\n    private createUrlForPos(network: string, url: string) {\n        return `${network === 'mainnet' ? 'matic' : 'mumbai'}${url}`;\n    }\n\n    private createUrlForZkEvm(network: string, url: string) {\n        return `${network}/${url}`;\n    }\n\n    getBlockIncluded(network: string, blockNumber: number) {\n        const url = this.createUrlForPos(network, `/block-included/${blockNumber}`);\n        return this.httpRequest.get<{\n            start: string;\n            end: string;\n            headerBlockNumber: BaseBigNumber;\n        }>(url).then(result => {\n            const headerBlockNumber = result.headerBlockNumber as any as string;\n            const decimalHeaderBlockNumber = headerBlockNumber.slice(0, 2) === '0x' ? parseInt(\n                headerBlockNumber, 16\n            ) : headerBlockNumber;\n            result.headerBlockNumber = new utils.BN(decimalHeaderBlockNumber);\n            return result;\n        });\n    }\n\n    getExitProof(network: string, burnTxHash: string, eventSignature:string) {\n        const url = this.createUrlForPos(network, `/exit-payload/${burnTxHash}?eventSignature=${eventSignature}`);\n        return this.httpRequest.get<any>(url).then(result => {\n            return result.result;\n        });\n    }\n\n    getProof(network: string, start, end, blockNumber) {\n        const url = this.createUrlForPos(network, `/fast-merkle-proof?start=${start}&end=${end}&number=${blockNumber}`);\n        return this.httpRequest.get<any>(url).then(result => {\n            return result.proof;\n        });\n    }\n\n    getMerkleProofForZkEvm(network: string, networkID: number, depositCount: number) {\n        const url = this.createUrlForZkEvm(network, `merkle-proof?net_id=${networkID}&deposit_cnt=${depositCount}`);\n        return this.httpRequest.get<any>(url).then(result => {\n            return result.proof;\n        });\n    }\n\n    getBridgeTransactionDetails(network: string, networkID: number, depositCount: number) {\n        const url = this.createUrlForZkEvm(network, `bridge?net_id=${networkID}&deposit_cnt=${depositCount}`);\n        return this.httpRequest.get<any>(url).then(result => {\n            return result.deposit;\n        });\n    }\n}\n","import { ABIService } from \"./abi_service\";\nimport { config } from \"../config\";\nimport { NetworkService } from \"./network_service\";\n\nexport * from \"./network_service\";\n\nclass Service {\n    network: NetworkService;\n    zkEvmNetwork: NetworkService;\n    abi: ABIService;\n}\n\nexport const service = new Service();\nservice.abi = new ABIService(config.abiStoreUrl);\n\n\n\n","import { service, NetworkService } from \"../services\";\n\nexport const setProofApi = (url: string) => {\n    const urlLength = url.length;\n    if (url[urlLength - 1] !== '/') {\n        url += '/';\n    }\n    url += 'api/v1/';\n    service.network = new NetworkService(url);\n};\n\nexport const setZkEvmProofApi = (url: string) => {\n    const urlLength = url.length;\n    if (url[urlLength - 1] !== '/') {\n        url += '/';\n    }\n    url += 'api/zkevm/';\n    service.zkEvmNetwork = new NetworkService(url);\n};\n","export function resolve(obj, path) {\n    const properties = Array.isArray(path) ? path : path.split(\".\");\n    return properties.reduce((prev, curr) => prev && prev[curr], obj);\n}","import { Web3SideChainClient } from \"../utils\";\nimport { ExitUtil } from \"../pos\";\nimport { BaseToken, utils } from \"..\";\n\nexport class BridgeClient<T> {\n\n    client: Web3SideChainClient<T> = new Web3SideChainClient();\n\n    exitUtil: ExitUtil;\n\n    /**\n     * check whether a txHash is checkPointed \n     *\n     * @param {string} txHash\n     * @returns\n     * @memberof BridgeClient\n     */\n    isCheckPointed(txHash: string) {\n        return this.exitUtil.isCheckPointed(\n            txHash\n        );\n    }\n\n    isDeposited(depositTxHash: string) {\n        const client = this.client;\n\n        const token = new BaseToken({\n            address: client.abiManager.getConfig(\"Matic.GenesisContracts.StateReceiver\"),\n            isParent: false,\n            name: 'StateReceiver',\n            bridgeType: 'genesis'\n        }, client);\n\n        return token.getContract().then(contract => {\n            return Promise.all([\n                client.parent.getTransactionReceipt(depositTxHash),\n                token['processRead']<string>(\n                    contract.method(\"lastStateId\")\n                )\n            ]);\n        }).then(result => {\n            const [receipt, lastStateId] = result;\n            const eventSignature = `0x103fed9db65eac19c4d870f49ab7520fe03b99f1838e5996caf47e9e43308392`;\n            const targetLog = receipt.logs.find(q => q.topics[0] === eventSignature);\n            if (!targetLog) {\n                throw new Error(\"StateSynced event not found\");\n            }\n            const rootStateId = client.child.decodeParameters(targetLog.topics[1], ['uint256'])[0];\n            const rootStateIdBN = utils.BN.isBN(rootStateId) ? rootStateId : new utils.BN(rootStateId);\n            return new utils.BN(lastStateId).gte(\n                rootStateIdBN\n            );\n        });\n    }\n\n}","import { service } from \"../services\";\nimport { resolve, promiseResolve } from \".\";\n\ntype T_ABI_CACHE = {\n    [networkName: string]: {\n        [version: string]: {\n            address: any,\n            abi: {\n                [bridgeType: string]: {\n                    [contractName: string]: any\n                }\n            }\n        }\n    }\n};\n\nconst cache: T_ABI_CACHE = {};\n\nexport class ABIManager {\n    constructor(public networkName: string, public version: string) {\n\n    }\n\n    init() {\n        return service.abi.getAddress(\n            this.networkName, this.version\n        ).then(result => {\n            cache[this.networkName] = {\n                [this.version]: {\n                    address: result,\n                    abi: {}\n                }\n            };\n        });\n    }\n\n    getConfig(path: string) {\n        return resolve(\n            cache[this.networkName][this.version].address,\n            path\n        );\n    }\n\n    getABI(contractName: string, bridgeType = 'plasma'): Promise<any> {\n        const targetBridgeABICache = cache[this.networkName][this.version].\n            abi[bridgeType];\n\n        if (targetBridgeABICache) {\n            const abiForContract = targetBridgeABICache[contractName];\n            if (abiForContract) {\n                return promiseResolve<any>(abiForContract);\n            }\n        }\n        return service.abi.getABI(\n            this.networkName,\n            this.version,\n            bridgeType,\n            contractName\n        ).then(result => {\n            this.setABI(contractName, bridgeType, result);\n            return result;\n        });\n    }\n\n    setABI(contractName: string, bridgeType: string, abi: any) {\n        const abiStore = cache[this.networkName][this.version].abi;\n        if (!abiStore[bridgeType]) {\n            abiStore[bridgeType] = {};\n        }\n        abiStore[bridgeType][contractName] = abi;\n    }\n}","export const throwNotImplemented = <T>() => {\n    throw new Error(\"not implemented\");\n    return '' as any as T;\n};","import { Web3SideChainClient } from \".\";\nimport { BridgeUtil, ZkEvmBridge } from \"../zkevm\";\nimport { service } from \"../services\";\nimport { IBaseClientConfig } from \"..\";\n\nexport class ZkEvmBridgeClient {\n\n    client: Web3SideChainClient<IBaseClientConfig> = new Web3SideChainClient();\n    bridgeUtil: BridgeUtil;\n    rootChainBridge: ZkEvmBridge;\n    childChainBridge: ZkEvmBridge;\n\n\n    /**\n     * check whether a txHash is synced with child chain\n     *\n     * @param {string} txHash\n     * @returns\n     * @memberof ZkEvmBridgeClient\n     */\n    isDepositClaimable(txHash: string) {\n        return Promise.all([this.rootChainBridge.networkID(), this.bridgeUtil.getBridgeLogData(\n            txHash, true\n        )]).then(result => {\n            return service.zkEvmNetwork.getBridgeTransactionDetails(\n                this.client.config.network,\n                result[0],\n                result[1].depositCount\n            );\n        }).then(details => {\n            return details.ready_for_claim;\n        });\n    }\n\n    /**\n     * check whether proof is submitted on parent chain\n     *\n     * @param {string} txHash\n     * @returns\n     * @memberof ZkEvmBridgeClient\n     */\n    isWithdrawExitable(txHash: string) {\n        return Promise.all([this.childChainBridge.networkID(), this.bridgeUtil.getBridgeLogData(\n            txHash, false\n        )]).then(result => {\n            return service.zkEvmNetwork.getBridgeTransactionDetails(\n                this.client.config.network,\n                result[0],\n                result[1].depositCount\n            );\n        }).then(details => {\n            return details.ready_for_claim;\n        });\n    }\n\n    /**\n     * check whether deposit is completed\n     *\n     * @param {string} txHash\n     * @returns\n     * @memberof ZkEvmBridgeClient\n     */\n    isDeposited(txHash: string) {\n        return this.bridgeUtil.getBridgeLogData(\n            txHash, true\n        ).then(result => {\n            return this.childChainBridge.isClaimed(result.depositCount);\n        });\n    }\n\n    /**\n     * check whether deposit is completed\n     *\n     * @param {string} txHash\n     * @returns\n     * @memberof ZkEvmBridgeClient\n     */\n    isExited(txHash: string) {\n        return this.bridgeUtil.getBridgeLogData(\n            txHash, false\n        ).then(result => {\n            return this.rootChainBridge.isClaimed(result.depositCount);\n        });\n    }\n\n}\n","import { BaseWeb3Client, Converter, TYPE_AMOUNT } from \"..\";\nimport { EmptyBigNumber } from \"../implementation\";\n\nexport * from \"./use\";\nexport * from \"./event_bus\";\nexport * from \"./logger\";\nexport * from \"./merge\";\nexport * from \"./map_promise\";\nexport * from \"./proof_util\";\nexport * from \"./http_request\";\nexport * from \"./converter\";\nexport * from \"./web3_side_chain_client\";\nexport * from \"./base_token\";\nexport * from \"./set_proof_api_url\";\nexport * from \"./resolve\";\nexport * from \"./promise_resolve\";\nexport * from \"./bridge_client\";\nexport * from \"./abi_manager\";\nexport * from \"./not_implemented\";\nexport * from \"./zkevm_bridge_client\";\n\n\nexport const utils = {\n    converter: Converter,\n    Web3Client: BaseWeb3Client,\n    BN: EmptyBigNumber,\n    UnstoppableDomains: Object\n};\n","import { BaseToken, Web3SideChainClient, promiseResolve } from \"../utils\";\nimport { IContractInitParam, IPOSClientConfig, ITransactionOption } from \"../interfaces\";\nimport { IPOSContracts } from \"../interfaces\";\n\nexport class POSToken extends BaseToken<IPOSClientConfig> {\n\n    private predicateAddress: string;\n\n    constructor(\n        contractParam: IContractInitParam,\n        client: Web3SideChainClient<IPOSClientConfig>,\n        protected getPOSContracts: () => IPOSContracts\n    ) {\n        super(contractParam, client);\n    }\n\n    protected get rootChainManager() {\n        return this.getPOSContracts().rootChainManager;\n    }\n\n    protected get gasSwapper() {\n        return this.getPOSContracts().gasSwapper;\n    }\n\n    protected get exitUtil() {\n        return this.getPOSContracts().exitUtil;\n    }\n\n\n    getPredicateAddress(): Promise<string> {\n        if (this.predicateAddress) {\n            return promiseResolve(this.predicateAddress);\n        }\n        return this.rootChainManager.method(\n            \"tokenToType\",\n            this.contractParam.address\n        ).then(method => {\n            return method.read();\n        }).then(tokenType => {\n            if (!tokenType) {\n                throw new Error('Invalid Token Type');\n            }\n            return this.rootChainManager.method(\n                \"typeToPredicate\", tokenType\n            );\n        }).then(typeToPredicateMethod => {\n            return typeToPredicateMethod.read<string>();\n        }).then(predicateAddress => {\n            this.predicateAddress = predicateAddress;\n            return predicateAddress;\n        });\n    }\n\n    protected isWithdrawn(txHash: string, eventSignature: string) {\n        if (!txHash) {\n            throw new Error(`txHash not provided`);\n        }\n        return this.exitUtil.getExitHash(\n            txHash, 0, eventSignature\n        ).then(exitHash => {\n            return this.rootChainManager.isExitProcessed(\n                exitHash\n            );\n        });\n    }\n\n    protected isWithdrawnOnIndex(txHash: string, index: number, eventSignature: string) {\n      if (!txHash) {\n          throw new Error(`txHash not provided`);\n      }\n      return this.exitUtil.getExitHash(\n          txHash, index, eventSignature\n      ).then(exitHash => {\n          return this.rootChainManager.isExitProcessed(\n              exitHash\n          );\n      });\n  }\n\n    protected withdrawExitPOS(burnTxHash: string, eventSignature: string, isFast: boolean, option: ITransactionOption) {\n        return this.exitUtil.buildPayloadForExit(\n            burnTxHash,\n            eventSignature,\n            isFast\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n}\n","import { ITransactionOption } from \"../interfaces\";\nimport { Converter, Web3SideChainClient } from \"../utils\";\nimport { POSToken } from \"./pos_token\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { ERROR_TYPE, Log_Event_Signature } from \"../enums\";\nimport { MAX_AMOUNT, promiseResolve } from \"..\";\nimport { IAllowanceTransactionOption, IApproveTransactionOption, IExitTransactionOption, IPOSClientConfig, IPOSContracts } from \"../interfaces\";\n\nexport class ERC20 extends POSToken {\n\n    constructor(\n        tokenAddress: string,\n        isParent: boolean,\n        client: Web3SideChainClient<IPOSClientConfig>,\n        getContracts: () => IPOSContracts\n    ) {\n        super({\n            isParent,\n            address: tokenAddress,\n            name: 'ChildERC20',\n            bridgeType: 'pos'\n        }, client, getContracts);\n    }\n\n    getBalance(userAddress: string, option?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"balanceOf\",\n                userAddress\n            );\n            return this.processRead<string>(method, option);\n        });\n    }\n\n    /**\n     * get allowance of user\n     *\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    getAllowance(userAddress: string, option: IAllowanceTransactionOption = {}) {\n        const spenderAddress = option.spenderAddress;\n\n        const predicatePromise = spenderAddress ? promiseResolve(spenderAddress) : this.getPredicateAddress();\n\n        return Promise.all([predicatePromise, this.getContract()]).then(result => {\n            const [predicateAddress, contract] = result;\n            const method = contract.method(\n                \"allowance\",\n                userAddress,\n                predicateAddress,\n            );\n            return this.processRead<string>(method, option);\n        });\n    }\n\n    approve(amount: TYPE_AMOUNT, option: IApproveTransactionOption = {}) {\n        const spenderAddress = option.spenderAddress;\n\n        if (!spenderAddress && !this.contractParam.isParent) {\n            this.client.logger.error(ERROR_TYPE.NullSpenderAddress).throw();\n        }\n\n        const predicatePromise = spenderAddress ? promiseResolve(spenderAddress) : this.getPredicateAddress();\n\n        return Promise.all([predicatePromise, this.getContract()]).then(result => {\n            const [predicateAddress, contract] = result;\n            const method = contract.method(\n                \"approve\",\n                predicateAddress,\n                Converter.toHex(amount)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    approveMax(option: IApproveTransactionOption = {}) {\n        return this.approve(\n            MAX_AMOUNT\n            , option\n        );\n    }\n\n    /**\n     * Deposit given amount of token for user\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    deposit(amount: TYPE_AMOUNT, userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"deposit\");\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n        return this.rootChainManager.deposit(\n            userAddress,\n            this.contractParam.address,\n            amountInABI,\n            option\n        );\n    }\n\n    /**\n     * Deposit given amount of token for user along with ETHER for gas token\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    depositWithGas(amount: TYPE_AMOUNT, userAddress: string, swapEthAmount: TYPE_AMOUNT, swapCallData: string, option?: ITransactionOption) {\n        this.checkForRoot(\"deposit\");\n\n        return this.getChainId().then((chainId: number) => {\n            if (chainId !== 1) {\n                this.client.logger.error(ERROR_TYPE.AllowedOnMainnet).throw();\n            }\n            const amountInABI = this.client.parent.encodeParameters(\n                [Converter.toHex(amount)],\n                ['uint256'],\n            );\n\n            option.value = Converter.toHex(swapEthAmount);\n\n            return this.gasSwapper.depositWithGas(\n                this.contractParam.address,\n                amountInABI,\n                userAddress,\n                swapCallData,\n                option\n            );\n        });\n\n    }\n\n    private depositEther_(amount: TYPE_AMOUNT, userAddress: string, option: ITransactionOption = {}) {\n        this.checkForRoot(\"depositEther\");\n\n\n        option.value = Converter.toHex(amount);\n        return this.rootChainManager.method(\"depositEtherFor\", userAddress).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * initiate withdraw by burning provided amount\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawStart(amount: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStart\");\n\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdraw\",\n                Converter.toHex(amount)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    private withdrawExit_(burnTransactionHash: string, isFast: boolean, option: IExitTransactionOption = {}) {\n        const eventSignature = option.burnEventSignature ?\n            option.burnEventSignature : Log_Event_Signature.Erc20Transfer;\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            eventSignature,\n            isFast\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    /**\n     * complete withdraw process after checkpoint has been submitted for the block containing burn tx.\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawExit(burnTransactionHash: string, option?: IExitTransactionOption) {\n        this.checkForRoot(\"withdrawExit\");\n\n        return this.withdrawExit_(burnTransactionHash, false, option);\n    }\n\n    /**\n     * complete withdraw process after checkpoint has been submitted for the block containing burn tx.\n     *\n     *  Note:- It create the proof in api call for fast exit.\n     * \n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawExitFaster(burnTransactionHash: string, option?: IExitTransactionOption) {\n        this.checkForRoot(\"withdrawExitFaster\");\n\n        return this.withdrawExit_(burnTransactionHash, true, option);\n    }\n\n    /**\n     * check if exit has been completed for a transaction hash\n     *\n     * @param {string} burnTxHash\n     * @returns\n     * @memberof ERC20\n     */\n    isWithdrawExited(burnTxHash: string) {\n        return this.isWithdrawn(burnTxHash, Log_Event_Signature.Erc20Transfer);\n    }\n\n    /**\n     * transfer amount to another user\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} to\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    transfer(amount: TYPE_AMOUNT, to: string, option?: ITransactionOption) {\n        return this.transferERC20(to, amount, option);\n    }\n\n}\n","import { BaseToken, Web3SideChainClient } from \"../utils\";\nimport { IPOSClientConfig, ITransactionOption } from \"../interfaces\";\n\nexport class RootChainManager extends BaseToken<IPOSClientConfig> {\n\n    constructor(client_: Web3SideChainClient<IPOSClientConfig>, address: string) {\n        super({\n            address: address,\n            name: 'RootChainManager',\n            bridgeType: 'pos',\n            isParent: true\n        }, client_);\n    }\n\n    method(methodName: string, ...args) {\n        return this.getContract().then(contract => {\n            return contract.method(methodName, ...args);\n        });\n    }\n\n    deposit(userAddress: string, tokenAddress: string, depositData: string, option?: ITransactionOption) {\n        return this.method(\n            \"depositFor\",\n            userAddress,\n            tokenAddress,\n            depositData\n        ).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n    exit(exitPayload: string, option: ITransactionOption) {\n        return this.method(\"exit\", exitPayload).then(method => {\n            return this.processWrite(\n                method,\n                option\n            );\n        });\n    }\n\n    isExitProcessed(exitHash: string) {\n        return this.method(\n            \"processedExits\", exitHash\n        ).then(method => {\n            return this.processRead<boolean>(method);\n        });\n    }\n\n}\n","import { RootChain } from \"./root_chain\";\nimport { Converter, ProofUtil, Web3SideChainClient } from \"../utils\";\nimport { bufferToHex, rlp } from \"ethereumjs-util\";\nimport { IBlockWithTransaction, ITransactionReceipt } from \"../interfaces\";\nimport { service } from \"../services\";\nimport { BaseBigNumber, BaseWeb3Client } from \"../abstracts\";\nimport { ErrorHelper } from \"../utils/error_helper\";\nimport { ERROR_TYPE, IBaseClientConfig, IRootBlockInfo, utils } from \"..\";\n\ninterface IChainBlockInfo {\n    lastChildBlock: string;\n    txBlockNumber: number;\n}\n\n\n\nexport class ExitUtil {\n    private maticClient_: BaseWeb3Client;\n\n    rootChain: RootChain;\n\n    requestConcurrency: number;\n    config: IBaseClientConfig;\n\n    constructor(client: Web3SideChainClient<IBaseClientConfig>, rootChain: RootChain) {\n        this.maticClient_ = client.child;\n        this.rootChain = rootChain;\n        const config = client.config;\n        this.config = config;\n        this.requestConcurrency = config.requestConcurrency;\n    }\n\n    private getLogIndex_(logEventSig: string, receipt: ITransactionReceipt) {\n        let logIndex = -1;\n\n        switch (logEventSig) {\n            case '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef':\n            case '0xf94915c6d1fd521cee85359239227480c7e8776d7caf1fc3bacad5c269b66a14':\n                logIndex = receipt.logs.findIndex(\n                    log =>\n                        log.topics[0].toLowerCase() === logEventSig.toLowerCase() &&\n                        log.topics[2].toLowerCase() === '0x0000000000000000000000000000000000000000000000000000000000000000'\n                );\n                break;\n\n            case '0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62':\n            case '0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb':\n                logIndex = receipt.logs.findIndex(\n                    log =>\n                        log.topics[0].toLowerCase() === logEventSig.toLowerCase() &&\n                        log.topics[3].toLowerCase() === '0x0000000000000000000000000000000000000000000000000000000000000000'\n                );\n                break;\n\n            default:\n                logIndex = receipt.logs.findIndex(log => log.topics[0].toLowerCase() === logEventSig.toLowerCase());\n        }\n        if (logIndex < 0) {\n            throw new Error(\"Log not found in receipt\");\n        }\n        return logIndex;\n    }\n\n    private getAllLogIndices_(logEventSig: string, receipt: ITransactionReceipt) {\n      let logIndices = [];\n\n      switch (logEventSig) {\n          case '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef':\n          case '0xf94915c6d1fd521cee85359239227480c7e8776d7caf1fc3bacad5c269b66a14':\n            logIndices = receipt.logs.reduce(\n                  (_, log, index) =>\n                      ((log.topics[0].toLowerCase() === logEventSig.toLowerCase() &&\n                      log.topics[2].toLowerCase() === '0x0000000000000000000000000000000000000000000000000000000000000000') &&\n                      logIndices.push(index), logIndices), []\n              );\n              break;\n\n          case '0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62':\n          case '0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb':\n              logIndices = receipt.logs.reduce(\n                (_, log, index) =>\n                    ((log.topics[0].toLowerCase() === logEventSig.toLowerCase() &&\n                    log.topics[3].toLowerCase() === '0x0000000000000000000000000000000000000000000000000000000000000000') &&\n                    logIndices.push(index), logIndices), []\n            );\n            break;\n          \n          case '0xf871896b17e9cb7a64941c62c188a4f5c621b86800e3d15452ece01ce56073df':\n              logIndices = receipt.logs.reduce(\n                (_, log, index) =>\n                    ((log.topics[0].toLowerCase() === '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef' &&\n                    log.topics[2].toLowerCase() === '0x0000000000000000000000000000000000000000000000000000000000000000') &&\n                    logIndices.push(index), logIndices), []\n            );\n            break;\n\n          default:\n            logIndices = receipt.logs.reduce(\n              (_, log, index) =>\n                  ((log.topics[0].toLowerCase() === logEventSig.toLowerCase()) &&\n                  logIndices.push(index), logIndices), []\n          );\n      }\n      if (logIndices.length === 0) {\n          throw new Error(\"Log not found in receipt\");\n      }\n      return logIndices;\n  }\n\n    getChainBlockInfo(burnTxHash: string) {\n        return Promise.all([\n            this.rootChain.getLastChildBlock(),\n            this.maticClient_.getTransaction(burnTxHash),\n        ]).then(result => {\n            return {\n                lastChildBlock: result[0],\n                txBlockNumber: result[1].blockNumber\n            } as IChainBlockInfo;\n        });\n    }\n\n    private isCheckPointed_(data: IChainBlockInfo) {\n        // lastchild block is greater equal to transacton block number; \n        return new utils.BN(data.lastChildBlock).gte(\n            new utils.BN(data.txBlockNumber)\n        );\n    }\n\n    isCheckPointed(burnTxHash: string) {\n        return this.getChainBlockInfo(\n            burnTxHash\n        ).then(result => {\n            return this.isCheckPointed_(\n                result\n            );\n        });\n    }\n\n    /**\n     * returns info about block number existance on parent chain\n     * 1. root block number, \n     * 2. start block number, \n     * 3. end block number \n     *\n     * @private\n     * @param {number} txBlockNumber - transaction block number on child chain\n     * @return {*} \n     * @memberof ExitUtil\n     */\n    private getRootBlockInfo(txBlockNumber: number) {\n        // find in which block child was included in parent\n        let rootBlockNumber: BaseBigNumber;\n        return this.rootChain.findRootBlockFromChild(\n            txBlockNumber\n        ).then(blockNumber => {\n            rootBlockNumber = blockNumber;\n            return this.rootChain.method(\n                \"headerBlocks\",\n                Converter.toHex(blockNumber)\n            );\n        }).then(method => {\n            return method.read<IRootBlockInfo>();\n        }).then(rootBlockInfo => {\n            return {\n                // header block number - root block number in which child block exist \n                headerBlockNumber: rootBlockNumber,\n                // range of block\n                // end - block end number\n                end: rootBlockInfo.end.toString(),\n                // start - block start number\n                start: rootBlockInfo.start.toString(),\n            } as IRootBlockInfo;\n        });\n\n    }\n\n    private getRootBlockInfoFromAPI(txBlockNumber: number) {\n        this.maticClient_.logger.log(\"block info from API 1\");\n        return service.network.getBlockIncluded(\n            this.config.network,\n            txBlockNumber\n        ).then(headerBlock => {\n            this.maticClient_.logger.log(\"block info from API 2\", headerBlock);\n            if (!headerBlock || !headerBlock.start || !headerBlock.end || !headerBlock.headerBlockNumber) {\n                throw Error('Network API Error');\n            }\n            return headerBlock;\n        }).catch(err => {\n            this.maticClient_.logger.log(\"block info from API\", err);\n            return this.getRootBlockInfo(txBlockNumber);\n        });\n    }\n\n    private getBlockProof(txBlockNumber: number, rootBlockInfo: { start, end }) {\n        return ProofUtil.buildBlockProof(\n            this.maticClient_,\n            parseInt(rootBlockInfo.start, 10),\n            parseInt(rootBlockInfo.end, 10),\n            parseInt(txBlockNumber + '', 10)\n        );\n    }\n\n    private getBlockProofFromAPI(txBlockNumber: number, rootBlockInfo: { start, end }) {\n\n        return service.network.getProof(\n            this.config.network,\n            rootBlockInfo.start,\n            rootBlockInfo.end,\n            txBlockNumber\n        ).then(blockProof => {\n            if (!blockProof) {\n                throw Error('Network API Error');\n            }\n            this.maticClient_.logger.log(\"block proof from API 1\");\n            return blockProof;\n        }).catch(_ => {\n            return this.getBlockProof(txBlockNumber, rootBlockInfo);\n        });\n    }\n\n    private getExitProofFromAPI(burnHash: string, eventSignature: string) {\n\n        return service.network.getExitProof(\n            this.config.network, burnHash, eventSignature\n        ).then(exitProof => {\n            if (!exitProof) {\n                throw Error('Network API Error');\n            }\n            this.maticClient_.logger.log(\"exit proof from API 1\");\n            return exitProof;\n        }).catch(_ => {\n            return this.buildPayloadForExit(burnHash, eventSignature, false);\n        });\n    }\n\n    buildPayloadForExit(burnTxHash: string, logEventSig: string, isFast: boolean, index = 0) {\n\n        if (isFast && !service.network) {\n            new ErrorHelper(ERROR_TYPE.ProofAPINotSet).throw();\n        }\n\n        if (index < 0) {\n          throw new Error('Index must not be a negative integer');\n        }\n\n        let txBlockNumber: number,\n            rootBlockInfo: IRootBlockInfo,\n            receipt: ITransactionReceipt,\n            block: IBlockWithTransaction,\n            blockProof;\n\n        if (isFast) {\n            return this.getExitProofFromAPI(burnTxHash, logEventSig);\n        }\n\n        return this.getChainBlockInfo(\n            burnTxHash\n        ).then(blockInfo => {\n            if (!this.isCheckPointed_(blockInfo)) {\n                throw new Error(\n                    'Burn transaction has not been checkpointed as yet'\n                );\n            }\n\n            // step 1 - Get Block number from transaction hash\n            txBlockNumber = blockInfo.txBlockNumber;\n            // step 2-  get transaction receipt from txhash and \n            // block information from block number\n            return Promise.all([\n                this.maticClient_.getTransactionReceipt(burnTxHash),\n                this.maticClient_.getBlockWithTransaction(txBlockNumber)\n            ]);\n        }).then(result => {\n            [receipt, block] = result;\n            // step  3 - get information about block saved in parent chain \n            return this.getRootBlockInfo(txBlockNumber);\n        }).then(rootBlockInfoResult => {\n            rootBlockInfo = rootBlockInfoResult;\n            // step 4 - build block proof\n            return this.getBlockProof(txBlockNumber, rootBlockInfo);\n        }).then(blockProofResult => {\n            blockProof = blockProofResult;\n            // step 5- create receipt proof\n            return ProofUtil.getReceiptProof(\n                receipt,\n                block,\n                this.maticClient_,\n                this.requestConcurrency\n            );\n        }).then((receiptProof: any) => {\n            // step 6 - encode payload, convert into hex\n\n            // when token index is not 0\n            if(index > 0) {\n              const logIndices = this.getAllLogIndices_(\n                logEventSig, receipt\n              );\n\n              if(index >= logIndices.length) {\n                throw new Error('Index is grater than the number of tokens in this transaction');\n              }\n\n              return this.encodePayload_(\n                rootBlockInfo.headerBlockNumber.toNumber(),\n                blockProof,\n                txBlockNumber,\n                block.timestamp,\n                Buffer.from(block.transactionsRoot.slice(2), 'hex'),\n                Buffer.from(block.receiptsRoot.slice(2), 'hex'),\n                ProofUtil.getReceiptBytes(receipt), // rlp encoded\n                receiptProof.parentNodes,\n                receiptProof.path,\n                logIndices[index]\n              );\n            }\n\n            // when token index is 0\n            const logIndex = this.getLogIndex_(\n                logEventSig, receipt\n            );\n\n            return this.encodePayload_(\n                rootBlockInfo.headerBlockNumber.toNumber(),\n                blockProof,\n                txBlockNumber,\n                block.timestamp,\n                Buffer.from(block.transactionsRoot.slice(2), 'hex'),\n                Buffer.from(block.receiptsRoot.slice(2), 'hex'),\n                ProofUtil.getReceiptBytes(receipt), // rlp encoded\n                receiptProof.parentNodes,\n                receiptProof.path,\n                logIndex\n            );\n        });\n    }\n\n    buildMultiplePayloadsForExit(burnTxHash: string, logEventSig: string, isFast: boolean) {\n\n      if (isFast && !service.network) {\n          new ErrorHelper(ERROR_TYPE.ProofAPINotSet).throw();\n      }\n\n      let txBlockNumber: number,\n          rootBlockInfo: IRootBlockInfo,\n          receipt: ITransactionReceipt,\n          block: IBlockWithTransaction,\n          blockProof;\n\n      return this.getChainBlockInfo(\n          burnTxHash\n      ).then(blockInfo => {\n          if (!isFast && !this.isCheckPointed_(blockInfo)) {\n              throw new Error(\n                  'Burn transaction has not been checkpointed as yet'\n              );\n          }\n\n          // step 1 - Get Block number from transaction hash\n          txBlockNumber = blockInfo.txBlockNumber;\n          // step 2-  get transaction receipt from txhash and \n          // block information from block number\n          return Promise.all([\n              this.maticClient_.getTransactionReceipt(burnTxHash),\n              this.maticClient_.getBlockWithTransaction(txBlockNumber)\n          ]);\n      }).then(result => {\n          [receipt, block] = result;\n          // step  3 - get information about block saved in parent chain \n          return (\n              isFast ? this.getRootBlockInfoFromAPI(txBlockNumber) :\n                  this.getRootBlockInfo(txBlockNumber)\n          );\n      }).then(rootBlockInfoResult => {\n          rootBlockInfo = rootBlockInfoResult;\n          // step 4 - build block proof\n          return (\n              isFast ? this.getBlockProofFromAPI(txBlockNumber, rootBlockInfo) :\n                  this.getBlockProof(txBlockNumber, rootBlockInfo)\n          );\n      }).then(blockProofResult => {\n          blockProof = blockProofResult;\n          // step 5- create receipt proof\n          return ProofUtil.getReceiptProof(\n              receipt,\n              block,\n              this.maticClient_,\n              this.requestConcurrency\n          );\n      }).then((receiptProof: any) => {\n          const logIndices = this.getAllLogIndices_(\n              logEventSig, receipt\n          );\n          const payloads:string[] = [];\n\n          // step 6 - encode payloads, convert into hex\n          for (const logIndex of logIndices){\n            payloads.push(\n              this.encodePayload_(\n                rootBlockInfo.headerBlockNumber.toNumber(),\n                blockProof,\n                txBlockNumber,\n                block.timestamp,\n                Buffer.from(block.transactionsRoot.slice(2), 'hex'),\n                Buffer.from(block.receiptsRoot.slice(2), 'hex'),\n                ProofUtil.getReceiptBytes(receipt), // rlp encoded\n                receiptProof.parentNodes,\n                receiptProof.path,\n                logIndex\n              )\n            );\n          }\n\n          return payloads;\n      });\n  }\n\n    private encodePayload_(\n        headerNumber,\n        buildBlockProof,\n        blockNumber,\n        timestamp,\n        transactionsRoot,\n        receiptsRoot,\n        receipt,\n        receiptParentNodes,\n        path,\n        logIndex\n    ) {\n        return bufferToHex(\n            rlp.encode([\n                headerNumber,\n                buildBlockProof,\n                blockNumber,\n                timestamp,\n                bufferToHex(transactionsRoot),\n                bufferToHex(receiptsRoot),\n                bufferToHex(receipt),\n                bufferToHex(rlp.encode(receiptParentNodes)),\n                bufferToHex(Buffer.concat([Buffer.from('00', 'hex'), path])),\n                logIndex,\n            ])\n        );\n    }\n\n    getExitHash(burnTxHash, index, logEventSig) {\n        let lastChildBlock: string,\n            receipt: ITransactionReceipt,\n            block: IBlockWithTransaction;\n\n        return Promise.all([\n            this.rootChain.getLastChildBlock(),\n            this.maticClient_.getTransactionReceipt(burnTxHash)\n        ]).then(result => {\n            lastChildBlock = result[0];\n            receipt = result[1];\n            return this.maticClient_.getBlockWithTransaction(\n                receipt.blockNumber\n            );\n        }).then(blockResult => {\n            block = blockResult;\n            if (!this.isCheckPointed_({ lastChildBlock: lastChildBlock, txBlockNumber: receipt.blockNumber })) {\n                this.maticClient_.logger.error(ERROR_TYPE.BurnTxNotCheckPointed).throw();\n            }\n            return ProofUtil.getReceiptProof(\n                receipt,\n                block,\n                this.maticClient_,\n                this.requestConcurrency\n            );\n        }).then((receiptProof: any) => {\n            let logIndex;\n            const nibbleArr = [];\n            receiptProof.path.forEach(byte => {\n                nibbleArr.push(Buffer.from('0' + (byte / 0x10).toString(16), 'hex'));\n                nibbleArr.push(Buffer.from('0' + (byte % 0x10).toString(16), 'hex'));\n            });\n\n            if(index > 0) {\n              const logIndices = this.getAllLogIndices_(logEventSig, receipt);\n              logIndex = logIndices[index];\n            }\n\n            logIndex = this.getLogIndex_(logEventSig, receipt);\n\n            return this.maticClient_.etheriumSha3(\n                receipt.blockNumber, bufferToHex(Buffer.concat(nibbleArr)), logIndex\n            );\n        });\n    }\n}\n","import { BaseToken, utils, Web3SideChainClient } from \"../utils\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { IPOSClientConfig, ITransactionOption } from \"../interfaces\";\nimport { BaseBigNumber } from \"..\";\n\nexport class RootChain extends BaseToken<IPOSClientConfig> {\n\n    constructor(client_: Web3SideChainClient<IPOSClientConfig>, address: string) {\n        super({\n            address: address,\n            name: 'RootChain',\n            isParent: true\n        }, client_);\n    }\n\n    method(methodName: string, ...args) {\n        return this.getContract().then(contract => {\n            return contract.method(methodName, ...args);\n        });\n    }\n\n    getLastChildBlock() {\n        return this.method(\"getLastChildBlock\").then(method => {\n            return method.read<string>({}, this.client.config.rootChainDefaultBlock || 'safe');\n        });\n    }\n\n    async findRootBlockFromChild(childBlockNumber: TYPE_AMOUNT): Promise<BaseBigNumber> {\n        const bigOne = new utils.BN(1);\n        const bigtwo = new utils.BN(2);\n        const checkPointInterval = new utils.BN(10000);\n\n        childBlockNumber = new utils.BN(childBlockNumber);\n        // first checkpoint id = start * 10000\n        let start = bigOne;\n\n        // last checkpoint id = end * 10000\n        const method = await this.method(\"currentHeaderBlock\");\n        const currentHeaderBlock = await method.read<string>();\n        let end = new utils.BN(currentHeaderBlock).div(\n            checkPointInterval\n        );\n\n        // binary search on all the checkpoints to find the checkpoint that contains the childBlockNumber\n        let ans;\n        while (start.lte(end)) {\n            if (start.eq(end)) {\n                ans = start;\n                break;\n            }\n            const mid = start.add(end).div(bigtwo);\n            const headerBlocksMethod = await this.method(\n                \"headerBlocks\",\n                mid.mul(checkPointInterval).toString()\n            );\n            const headerBlock = await headerBlocksMethod.read<{ start: number, end: number }>();\n\n            const headerStart = new utils.BN(headerBlock.start);\n            const headerEnd = new utils.BN(headerBlock.end);\n\n            if (headerStart.lte(childBlockNumber) && childBlockNumber.lte(headerEnd)) {\n                // if childBlockNumber is between the upper and lower bounds of the headerBlock, we found our answer\n                ans = mid;\n                break;\n            } else if (headerStart.gt(childBlockNumber)) {\n                // childBlockNumber was checkpointed before this header\n                end = mid.sub(bigOne);\n            } else if (headerEnd.lt(childBlockNumber)) {\n                // childBlockNumber was checkpointed after this header\n                start = mid.add(bigOne);\n            }\n        }\n        return ans.mul(checkPointInterval);\n    }\n\n}\n","import { IPOSClientConfig, IPOSContracts, ITransactionOption } from \"../interfaces\";\nimport { RootChainManager } from \"./root_chain_manager\";\nimport { Converter, Web3SideChainClient } from \"../utils\";\nimport { POSToken } from \"./pos_token\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { ExitUtil } from \"./exit_util\";\nimport { Log_Event_Signature } from \"../enums\";\n\nexport class ERC721 extends POSToken {\n\n\n    constructor(\n        tokenAddress: string,\n        isParent: boolean,\n        client: Web3SideChainClient<IPOSClientConfig>,\n        getContracts: () => IPOSContracts\n    ) {\n        super({\n            isParent,\n            address: tokenAddress,\n            name: 'ChildERC721',\n            bridgeType: 'pos'\n        }, client, getContracts);\n    }\n\n    private validateMany_(tokenIds) {\n        if (tokenIds.length > 20) {\n            throw new Error('can not process more than 20 tokens');\n        }\n        return tokenIds.map(tokenId => {\n            return Converter.toHex(tokenId);\n        });\n    }\n\n    /**\n     * get tokens count for the user\n     *\n     * @param {string} userAddress\n     * @param {ITransactionOption} [options]\n     * @returns\n     * @memberof ERC721\n     */\n    getTokensCount(userAddress: string, options?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"balanceOf\",\n                userAddress\n            );\n            return this.processRead<string>(method, options);\n        }).then(count => {\n            return Number(count);\n        });\n    }\n\n    /**\n     * returns token id on supplied index for user\n     *\n     * @param {number} index\n     * @param {string} userAddress\n     * @param {ITransactionOption} [options]\n     * @returns\n     * @memberof ERC721\n     */\n    getTokenIdAtIndexForUser(index: number, userAddress: string, options?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"tokenOfOwnerByIndex\",\n                userAddress,\n                index\n            );\n\n            return this.processRead<string>(method, options);\n        });\n    }\n\n    /**\n     * get all tokens for user\n     *\n     * @param {string} userAddress\n     * @param {*} [limit=Infinity]\n     * @returns\n     * @memberof ERC721\n     */\n    getAllTokens(userAddress: string, limit = Infinity) {\n        return this.getTokensCount(userAddress).then(count => {\n            count = Number(count);\n            if (count > limit) {\n                count = limit;\n            }\n            const promises = [];\n            for (let i = 0; i < count; i++) {\n                promises.push(\n                    this.getTokenIdAtIndexForUser(i, userAddress)\n                );\n            }\n            return Promise.all(\n                promises\n            );\n        });\n    }\n\n    isApproved(tokenId: string, option?: ITransactionOption) {\n        this.checkForRoot(\"isApproved\");\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"getApproved\",\n                tokenId\n            );\n            return Promise.all([\n                this.processRead<string>(method, option),\n                this.getPredicateAddress()\n            ]).then(result => {\n                return result[0] === result[1];\n            });\n        });\n    }\n\n    isApprovedAll(userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"isApprovedAll\");\n\n        return Promise.all([this.getContract(), this.getPredicateAddress()]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"isApprovedForAll\",\n                userAddress,\n                predicateAddress\n            );\n            return this.processRead<boolean>(method, option);\n        });\n\n    }\n\n    approve(tokenId: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForRoot(\"approve\");\n\n        return Promise.all([this.getContract(), this.getPredicateAddress()]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"approve\",\n                predicateAddress,\n                Converter.toHex(tokenId)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    approveAll(option?: ITransactionOption) {\n        this.checkForRoot(\"approveAll\");\n\n        return Promise.all([this.getContract(), this.getPredicateAddress()]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"setApprovalForAll\",\n                predicateAddress,\n                true\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n\n    deposit(tokenId: TYPE_AMOUNT, userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"deposit\");\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(tokenId)],\n            ['uint256'],\n        );\n        return this.rootChainManager.deposit(\n            userAddress,\n            this.contractParam.address,\n            amountInABI,\n            option\n        );\n    }\n\n    depositMany(tokenIds: TYPE_AMOUNT[], userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"depositMany\");\n\n        const tokensInHex = this.validateMany_(tokenIds);\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [tokensInHex],\n            ['uint256[]'],\n        );\n        return this.rootChainManager.deposit(\n            userAddress,\n            this.contractParam.address,\n            amountInABI,\n            option\n        );\n    }\n\n    withdrawStart(tokenId: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStart\");\n\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdraw\",\n                Converter.toHex(tokenId)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    withdrawStartWithMetaData(tokenId: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStartWithMetaData\");\n\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdrawWithMetadata\",\n                Converter.toHex(tokenId)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    withdrawStartMany(tokenIds: TYPE_AMOUNT[], option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStartMany\");\n\n        const tokensInHex = this.validateMany_(tokenIds);\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdrawBatch\",\n                tokensInHex\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    withdrawExit(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExit\");\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc721Transfer,\n            false\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    withdrawExitOnIndex(burnTransactionHash: string, index: number, option?: ITransactionOption) {\n      this.checkForRoot(\"withdrawExit\");\n\n      return this.exitUtil.buildPayloadForExit(\n          burnTransactionHash,\n          Log_Event_Signature.Erc721Transfer,\n          false,\n          index\n      ).then(payload => {\n          return this.rootChainManager.exit(\n              payload, option\n          );\n      });\n    }\n\n    // async withdrawExitMany(burnTransactionHash: string, option?: ITransactionOption) {\n    //     this.checkForRoot(\"withdrawExitMany\");\n\n    //     return this.exitUtil.buildMultiplePayloadsForExit(\n    //         burnTransactionHash,\n    //         Log_Event_Signature.Erc721BatchTransfer,\n    //         false\n    //     ).then(async payloads => {\n    //         const exitTxs = [];\n    //         if()\n    //         for(const i in payloads) {\n    //           exitTxs.push(this.rootChainManager.exit(\n    //             payloads[i], option\n    //         ));\n    //         }\n    //         return Promise.all(exitTxs);\n    //         });\n    // }\n\n    withdrawExitFaster(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitFaster\");\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc721Transfer,\n            true\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    // withdrawExitFasterMany(burnTransactionHash: string, option?: ITransactionOption) {\n    //     this.checkForRoot(\"withdrawExitFasterMany\");\n\n\n    //     return this.exitUtil.buildPayloadForExit(\n    //         burnTransactionHash,\n    //         Log_Event_Signature.Erc721BatchTransfer,\n    //         true\n    //     ).then(payload => {\n    //         return this.rootChainManager.exit(\n    //             payload, option\n    //         );\n    //     });\n    // }\n\n    isWithdrawExited(txHash: string) {\n        return this.isWithdrawn(\n            txHash, Log_Event_Signature.Erc721Transfer\n        );\n    }\n\n    isWithdrawExitedMany(txHash: string) {\n        return this.isWithdrawn(\n            txHash, Log_Event_Signature.Erc721BatchTransfer\n        );\n    }\n\n    isWithdrawExitedOnIndex(txHash: string, index: number) {\n        return this.isWithdrawnOnIndex(\n            txHash, index, Log_Event_Signature.Erc721Transfer\n        );\n    }\n\n    /**\n     * transfer to another user\n     *\n     * @param {string} tokenId\n     * @param {string} from\n     * @param {string} to\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC721\n     */\n    transfer(tokenId: string, from: string, to: string, option?: ITransactionOption) {\n        return this.transferERC721(\n            from,\n            to,\n            tokenId,\n            option\n        );\n    }\n\n}\n","import { IPOSClientConfig, ITransactionOption } from \"../interfaces\";\nimport { Converter, promiseResolve, Web3SideChainClient } from \"../utils\";\nimport { POSToken } from \"./pos_token\";\nimport { Log_Event_Signature } from \"../enums\";\nimport { IPOSContracts, IPOSERC1155Address } from \"../interfaces\";\nimport { POSERC1155DepositBatchParam, POSERC1155DepositParam, POSERC1155TransferParam, TYPE_AMOUNT } from \"..\";\n\nexport class ERC1155 extends POSToken {\n\n    mintablePredicateAddress: string;\n\n    get addressConfig(): IPOSERC1155Address {\n        return this.client.config.erc1155 || {};\n    }\n\n    constructor(\n        tokenAddress: string,\n        isParent: boolean,\n        client: Web3SideChainClient<IPOSClientConfig>,\n        getContracts: () => IPOSContracts\n    ) {\n        super({\n            isParent,\n            address: tokenAddress,\n            name: 'ChildERC1155',\n            bridgeType: 'pos'\n        }, client, getContracts);\n\n    }\n\n    private getAddress_(value: string) {\n        const addresses = this.addressConfig;\n        if (addresses[value]) {\n            return promiseResolve(addresses[value]);\n        }\n\n        return this.client.getConfig(value);\n    }\n\n    /**\n     * get balance of a user for supplied token\n     *\n     * @param {string} userAddress\n     * @param {TYPE_AMOUNT} tokenId\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    getBalance(userAddress: string, tokenId: TYPE_AMOUNT, option?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"balanceOf\",\n                userAddress,\n                Converter.toHex(tokenId)\n            );\n            return this.processRead<string>(method, option);\n        });\n    }\n\n    /**\n     * check if a user is approved for all tokens\n     *\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    isApprovedAll(userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"isApprovedAll\");\n\n        return Promise.all([this.getContract(), this.getPredicateAddress()]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"isApprovedForAll\",\n                userAddress,\n                predicateAddress\n            );\n            return this.processRead<boolean>(method, option);\n        });\n\n    }\n\n    private approveAll_(predicateAddressPromise: Promise<string>, option: ITransactionOption) {\n        this.checkForRoot(\"approve\");\n\n        return Promise.all([this.getContract(), predicateAddressPromise]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"setApprovalForAll\",\n                predicateAddress,\n                true\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * approve all tokens \n     *\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    approveAll(option?: ITransactionOption) {\n        this.checkForRoot(\"approve\");\n\n        return this.approveAll_(\n            this.getPredicateAddress(), option\n        );\n    }\n\n    /**\n     * approve all tokens for mintable token\n     *\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    approveAllForMintable(option?: ITransactionOption) {\n        this.checkForRoot(\"approveForMintable\");\n        const addressPath = \"Main.POSContracts.MintableERC1155PredicateProxy\";\n        return this.approveAll_(\n            this.getAddress_(addressPath), option\n        );\n    }\n\n    /**\n     * deposit supplied amount of token for a user \n     *\n     * @param {POSERC1155DepositParam} param\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    deposit(param: POSERC1155DepositParam, option?: ITransactionOption) {\n        this.checkForRoot(\"deposit\");\n        return this.depositMany({\n            amounts: [param.amount],\n            tokenIds: [param.tokenId],\n            userAddress: param.userAddress,\n            data: param.data\n        }, option);\n    }\n\n    /**\n     * deposit supplied amount of multiple token for user\n     *\n     * @param {POSERC1155DepositBatchParam} param\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    depositMany(param: POSERC1155DepositBatchParam, option?: ITransactionOption) {\n        this.checkForRoot(\"depositMany\");\n\n        const { tokenIds, amounts, data, userAddress } = param;\n        const emptyHex = Converter.toHex(0);\n        const amountInABI = this.client.parent.encodeParameters(\n            [\n                tokenIds.map(t => Converter.toHex(t)),\n                amounts.map(a => Converter.toHex(a)),\n                data || emptyHex\n            ],\n            ['uint256[]', 'uint256[]', 'bytes'],\n        );\n\n        return this.rootChainManager.deposit(\n            userAddress,\n            this.contractParam.address,\n            amountInABI,\n            option\n        );\n\n    }\n\n    /**\n     * start withdraw process by burning the required amount for a token\n     *\n     * @param {string} tokenId\n     * @param {TYPE_AMOUNT} amount\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawStart(tokenId: TYPE_AMOUNT, amount: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStart\");\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdrawSingle\",\n                Converter.toHex(tokenId),\n                Converter.toHex(amount)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * start the withdraw process by burning the supplied amount of multiple token at a time\n     *\n     * @param {TYPE_AMOUNT[]} tokenIds\n     * @param {TYPE_AMOUNT[]} amounts\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawStartMany(tokenIds: TYPE_AMOUNT[], amounts: TYPE_AMOUNT[], option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStartMany\");\n\n        const tokensInHex = tokenIds.map(t => {\n            return Converter.toHex(t);\n        });\n        const amountsInHex = amounts.map(t => {\n            return Converter.toHex(t);\n        });\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdrawBatch\",\n                tokensInHex,\n                amountsInHex\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * exit the withdraw process and get the burned amount on root chain\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawExit(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExit\");\n\n        return this.withdrawExitPOS(\n            burnTransactionHash,\n            Log_Event_Signature.Erc1155Transfer,\n            false,\n            option\n        );\n    }\n\n    /**\n     * exit the withdraw process and get the burned amount on root chain\n     * \n     * the process is faster because it uses proof api\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawExitFaster(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitFaster\");\n\n        return this.withdrawExitPOS(\n            burnTransactionHash,\n            Log_Event_Signature.Erc1155Transfer,\n            true,\n            option\n        );\n    }\n\n    /**\n     * exit the withdraw process for many burned transaction and get the burned amount on root chain\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawExitMany(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitMany\");\n\n\n        return this.withdrawExitPOS(\n            burnTransactionHash,\n            Log_Event_Signature.Erc1155BatchTransfer,\n            false,\n            option\n        );\n    }\n\n    /**\n     * exit the withdraw process for many burned transaction and get the burned amount on root chain\n     *\n     * the process is faster because it uses proof api\n     * \n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawExitFasterMany(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitFasterMany\");\n\n\n        return this.withdrawExitPOS(\n            burnTransactionHash,\n            Log_Event_Signature.Erc1155BatchTransfer,\n            true,\n            option\n        );\n    }\n\n    /**\n     * check if exit has been completed for a transaction hash\n     *\n     * @param {string} burnTxHash\n     * @return {*} \n     * @memberof ERC1155\n     */\n    isWithdrawExited(txHash: string) {\n        return this.isWithdrawn(\n            txHash, Log_Event_Signature.Erc1155Transfer\n        );\n    }\n\n    /**\n     * check if batch exit has been completed for a transaction hash\n     *\n     * @param {string} txHash\n     * @return {*} \n     * @memberof ERC1155\n     */\n    isWithdrawExitedMany(txHash: string) {\n        return this.isWithdrawn(\n            txHash, Log_Event_Signature.Erc1155BatchTransfer\n        );\n    }\n\n    /**\n     * transfer the required amount of a token to another user\n     *\n     * @param {POSERC1155TransferParam} param\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    transfer(param: POSERC1155TransferParam, option?: ITransactionOption) {\n        return this.transferERC1155(\n            param, option\n        );\n    }\n}","import { BaseToken, Web3SideChainClient } from \"../utils\";\nimport { IPOSClientConfig, ITransactionOption } from \"../interfaces\";\n\nexport class GasSwapper extends BaseToken<IPOSClientConfig> {\n\n    constructor(client_: Web3SideChainClient<IPOSClientConfig>, address: string) {\n        super({\n            address: address,\n            name: 'GasSwapper',\n            bridgeType: 'pos',\n            isParent: true\n        }, client_);\n    }\n\n    method(methodName: string, ...args) {\n        return this.getContract().then(contract => {\n            return contract.method(methodName, ...args);\n        });\n    }\n\n    depositWithGas(\n        tokenAddress: string,\n        depositAmount: string,\n        userAddress: string,\n        swapCallData: string,\n        option?: ITransactionOption\n    ) {\n        return this.method(\n            \"swapAndBridge\",\n            tokenAddress,\n            depositAmount,\n            userAddress,\n            swapCallData\n        ).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n}\n","import { ERC20 } from \"./erc20\";\nimport { RootChainManager } from \"./root_chain_manager\";\nimport { BridgeClient } from \"../utils\";\nimport { IPOSClientConfig, IPOSContracts, ITransactionOption } from \"../interfaces\";\nimport { ExitUtil } from \"./exit_util\";\nimport { RootChain } from \"./root_chain\";\nimport { ERC721 } from \"./erc721\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { ERC1155 } from \"./erc1155\";\nimport { GasSwapper } from \"./gas_swapper\";\n\nexport * from \"./exit_util\";\nexport * from \"./root_chain_manager\";\nexport * from \"./root_chain\";\nexport * from \"./gas_swapper\";\n\nexport class POSClient extends BridgeClient<IPOSClientConfig> {\n\n    rootChainManager: RootChainManager;\n    gasSwapper: GasSwapper;\n\n    init(config: IPOSClientConfig) {\n        const client = this.client;\n\n        return client.init(config).then(_ => {\n            const mainPOSContracts = client.mainPOSContracts;\n            client.config = config = Object.assign(\n                {\n                    rootChainManager: mainPOSContracts.RootChainManagerProxy,\n                    rootChain: client.mainPlasmaContracts.RootChainProxy,\n                    gasSwapper: mainPOSContracts.GasSwapper\n                } as IPOSClientConfig,\n                config\n            );\n\n            this.rootChainManager = new RootChainManager(\n                this.client,\n                config.rootChainManager,\n            );\n\n            const rootChain = new RootChain(\n                this.client,\n                config.rootChain,\n            );\n\n            this.exitUtil = new ExitUtil(\n                this.client,\n                rootChain\n            );\n\n            this.gasSwapper = new GasSwapper(\n                this.client,\n                config.gasSwapper\n            );\n\n            return this;\n        });\n    }\n\n    erc20(tokenAddress, isParent?: boolean) {\n        return new ERC20(\n            tokenAddress,\n            isParent,\n            this.client,\n            this.getContracts_.bind(this)\n        );\n    }\n\n    erc721(tokenAddress, isParent?: boolean) {\n        return new ERC721(\n            tokenAddress,\n            isParent,\n            this.client,\n            this.getContracts_.bind(this)\n        );\n    }\n\n    erc1155(tokenAddress, isParent?: boolean) {\n        return new ERC1155(\n            tokenAddress,\n            isParent,\n            this.client,\n            this.getContracts_.bind(this)\n        );\n    }\n\n    depositEther(amount: TYPE_AMOUNT, userAddress: string, option: ITransactionOption) {\n        return new ERC20(\n            '', true, this.client,\n            this.getContracts_.bind(this),\n        )['depositEther_'](amount, userAddress, option);\n    }\n\n    private getContracts_() {\n        return {\n            exitUtil: this.exitUtil,\n            rootChainManager: this.rootChainManager,\n            gasSwapper: this.gasSwapper\n        } as IPOSContracts;\n    }\n}","import { POSClient } from \"./pos\";\nimport { use, utils } from \"./utils\";\n\nexport const defaultExport = {\n    utils: utils,\n    use,\n    POSClient,\n};","import { BaseToken, Web3SideChainClient } from \"../utils\";\nimport { IContractInitParam, IZkEvmClientConfig } from \"../interfaces\";\nimport { IZkEvmContracts } from \"../interfaces\";\n\nexport class ZkEvmToken extends BaseToken<IZkEvmClientConfig> {\n\n    constructor(\n        contractParam: IContractInitParam,\n        client: Web3SideChainClient<IZkEvmClientConfig>,\n        protected getZkEvmContracts: () => IZkEvmContracts\n    ) {\n        super(contractParam, client);\n    }\n\n    protected get parentBridge() {\n        return this.getZkEvmContracts().parentBridge;\n    }\n\n    protected get zkEVMWrapper() {\n        return this.getZkEvmContracts().zkEVMWrapper;\n    }\n\n    protected get childBridge() {\n        return this.getZkEvmContracts().childBridge;\n    }\n\n    protected get bridgeUtil() {\n        return this.getZkEvmContracts().bridgeUtil;\n    }\n\n}\n","import { ITransactionOption, IZkEvmClientConfig } from '../interfaces';\nimport { BaseToken, Converter, Web3SideChainClient } from '../utils';\nimport { TYPE_AMOUNT } from '../types';\n\n/**\n * ZkEVMBridgeAdapter used ZkEVMBridge to implement additional custom features\n * like bridging custom ERC20\n */\nexport class ZkEVMBridgeAdapter extends BaseToken<IZkEvmClientConfig> {\n\n  constructor(client_: Web3SideChainClient<IZkEvmClientConfig>, address: string, isParent: boolean) {\n    super(\n      {\n        address: address,\n        name: 'ZkEVMBridgeAdapter',\n        bridgeType: 'zkevm',\n        isParent: isParent, // decides if it's a child chain or a root chain adapter\n      },\n      client_,\n    );\n  }\n\n  method(methodName: string, ...args) {\n    return this.getContract().then(contract => {\n      return contract.method(methodName, ...args);\n    });\n  }\n\n  /**\n   * uses the bridge function present in the adapter contract\n   * @param recipient\n   * @param amount\n   * @param forceUpdateGlobalExitRoot\n   * @param option\n   *\n   * @returns\n   * @memberof ZkEvmCustomBridge\n   */\n  bridgeToken(\n    recipient: string,\n    amount: TYPE_AMOUNT,\n    forceUpdateGlobalExitRoot?: boolean,\n    option?: ITransactionOption,\n  ) {\n    return this.method('bridgeToken', recipient, Converter.toHex(amount), forceUpdateGlobalExitRoot).then(\n      method => {\n        return this.processWrite(method, option);\n      },\n    );\n  }\n}\n","import { isHexString } from 'ethereumjs-util';\nimport { ITransactionOption } from \"../interfaces\";\nimport { Converter, Web3SideChainClient, promiseAny } from \"../utils\";\nimport { ZkEvmToken } from \"./zkevm_token\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { BaseContractMethod } from \"../abstracts\";\nimport { MAX_AMOUNT, ADDRESS_ZERO, DAI_PERMIT_TYPEHASH, EIP_2612_PERMIT_TYPEHASH, UNISWAP_DOMAIN_TYPEHASH, EIP_2612_DOMAIN_TYPEHASH, Permit, BaseContract, BaseWeb3Client, ERROR_TYPE } from '..';\nimport { IAllowanceTransactionOption, IApproveTransactionOption, IBridgeTransactionOption, IZkEvmClientConfig, IZkEvmContracts } from \"../interfaces\";\nimport { ZkEVMBridgeAdapter } from './zkevm_custom_bridge';\n\nexport class ERC20 extends ZkEvmToken {\n    private bridgeAdapter: ZkEVMBridgeAdapter;\n    constructor(\n        tokenAddress: string,\n        isParent: boolean,\n        bridgeAdapterAddress,\n        client: Web3SideChainClient<IZkEvmClientConfig>,\n        getContracts: () => IZkEvmContracts\n    ) {\n        super({\n            isParent,\n            address: tokenAddress,\n            bridgeAdapterAddress,\n            name: 'ERC20',\n            bridgeType: 'zkevm'\n        }, client, getContracts);\n        if(bridgeAdapterAddress) {\n            this.bridgeAdapter =  new ZkEVMBridgeAdapter(\n              this.client,\n              bridgeAdapterAddress,\n              isParent\n            );\n        }\n    }\n\n    /**\n     * get bridge for that token\n     *\n     * @returns\n     * @memberof ERC20\n     */\n    getBridgeAddress() {\n        const bridge = this.contractParam.isParent ? this.parentBridge : this.childBridge;\n        return bridge.contractAddress;\n    }\n\n    isEtherToken() {\n        return this.contractParam.address === ADDRESS_ZERO;\n    }\n\n    /**\n     * get token balance of user\n     *\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    getBalance(userAddress: string, option?: ITransactionOption) {\n        if (this.isEtherToken()) {\n            const client = this.contractParam.isParent ? this.client.parent : this.client.child;\n            return client.getBalance(userAddress);\n        } else {\n            return this.getContract().then(contract => {\n                const method = contract.method(\n                    \"balanceOf\",\n                    userAddress\n                );\n                return this.processRead<string>(method, option);\n            });\n        }\n\n    }\n\n    /**\n     * is Approval needed to bridge tokens to other chains\n     *\n     * @returns\n     * @memberof ERC20\n     */\n    isApprovalNeeded() {\n        if (this.isEtherToken()) {\n            return false;\n        }\n\n        const bridge = this.contractParam.isParent ? this.parentBridge : this.childBridge;\n\n        return bridge.getOriginTokenInfo(this.contractParam.address)\n            .then(tokenInfo => {\n                return tokenInfo[1] === ADDRESS_ZERO;\n            });\n    }\n\n    /**\n     * get allowance of user\n     *\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    getAllowance(userAddress: string, option: IAllowanceTransactionOption = {}) {\n        this.checkForNonNative(\"getAllowance\");\n        const spenderAddress = option.spenderAddress ? option.spenderAddress : this.getBridgeAddress();\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"allowance\",\n                userAddress,\n                spenderAddress,\n            );\n            return this.processRead<string>(method, option);\n        });\n    }\n\n    /**\n     * Approve given amount of tokens for user\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {IApproveTransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    approve(amount: TYPE_AMOUNT, option: IApproveTransactionOption = {}) {\n        this.checkForNonNative(\"approve\");\n        const spenderAddress = option.spenderAddress ? option.spenderAddress : this.getBridgeAddress();\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"approve\",\n                spenderAddress,\n                Converter.toHex(amount)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * Approve max amount of tokens for user\n     *\n     * @param {IApproveTransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    approveMax(option: IApproveTransactionOption = {}) {\n        this.checkForNonNative(\"approveMax\");\n        return this.approve(\n            MAX_AMOUNT,\n            option\n        );\n    }\n\n    /**\n     * Deposit given amount of token for user\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {IBridgeTransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    deposit(amount: TYPE_AMOUNT, userAddress: string, option: IBridgeTransactionOption = {}) {\n        this.checkForRoot(\"deposit\");\n        const permitData = option.permitData || '0x';\n        const forceUpdateGlobalExitRoot = option.forceUpdateGlobalExitRoot || true;\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n\n        if (this.isEtherToken()) {\n            option.value = Converter.toHex(amount);\n        }\n\n        return this.childBridge.networkID().then(networkId => {\n            return this.parentBridge.bridgeAsset(\n                networkId,\n                userAddress,\n                amountInABI,\n                this.contractParam.address,\n                forceUpdateGlobalExitRoot,\n                permitData,\n                option\n            );\n        });\n    }\n\n    /**\n     * Deposit given amount of token for user along with ETH for gas token\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {IBridgeTransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    depositWithGas(amount: TYPE_AMOUNT, userAddress: string, ethGasAmount: TYPE_AMOUNT, option: IBridgeTransactionOption = {}) {\n        this.checkForRoot(\"deposit\");\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n\n        option.value = Converter.toHex(ethGasAmount);\n        if (option.v && option.r && option.s){\n            return this.zkEVMWrapper.depositPermitWithGas(\n                this.contractParam.address,\n                amountInABI,\n                userAddress,\n                Math.floor((Date.now() + 3600000)/1000).toString(),\n                option.v,\n                option.r,\n                option.s,\n                option\n            );\n        }\n        return this.zkEVMWrapper.depositWithGas(\n            this.contractParam.address,\n            amountInABI,\n            userAddress,\n            option\n        );\n    }\n\n    /**\n     * Deposit given amount of token for user along with ETH for gas token\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {IBridgeTransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    depositPermitWithGas(amount: TYPE_AMOUNT, userAddress: string, ethGasAmount: TYPE_AMOUNT, option: IBridgeTransactionOption = {}) {\n        this.checkForRoot(\"deposit\");\n        this.checkForNonNative(\"getPermitData\");\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n\n        option.value = Converter.toHex(ethGasAmount);\n\n        return this.getPermitSignatureParams_(amount, this.zkEVMWrapper.contractAddress).then(\n            signatureParams => {\n                return this.zkEVMWrapper.depositPermitWithGas(\n                    this.contractParam.address,\n                    amountInABI,\n                    userAddress,\n                    Math.floor((Date.now() + 3600000)/1000).toString(),\n                    signatureParams.v,\n                    signatureParams.r,\n                    signatureParams.s,\n                    option\n                );\n            }\n        );\n    }\n\n    /**\n     * Deposit given amount of token for user with permit call\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {IBridgeTransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    depositWithPermit(amount: TYPE_AMOUNT, userAddress: string, option: IApproveTransactionOption = {}) {\n        this.checkForRoot(\"deposit\");\n        this.checkForNonNative(\"depositWithPermit\");\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n\n        const forceUpdateGlobalExitRoot = option.forceUpdateGlobalExitRoot || true;\n\n        return this.getPermitData(amountInABI, option).then(permitData => {\n            return this.childBridge.networkID().then(networkId => {\n                return this.parentBridge.bridgeAsset(\n                    networkId,\n                    userAddress,\n                    amountInABI,\n                    this.contractParam.address,\n                    forceUpdateGlobalExitRoot,\n                    permitData,\n                    option\n                );\n            });\n        });\n    }\n\n    /**\n     * Bridge asset to child chain using Custom ERC20 bridge Adapter\n     * @param amount\n     * @param userAddress\n     * @param forceUpdateGlobalExitRoot\n     * @returns\n     * @memberof ERC20\n     */\n    depositCustomERC20(amount: TYPE_AMOUNT, userAddress: string, forceUpdateGlobalExitRoot = true) {\n        // should be allowed to be used only in root chain\n        this.checkForRoot(\"depositCustomERC20\");\n        this.checkAdapterPresent(\"depositCustomERC20\");\n        // should not be allowed to use for native asset\n        this.checkForNonNative(\"depositCustomERC20\");\n        return this.bridgeAdapter.bridgeToken(userAddress, amount, forceUpdateGlobalExitRoot);\n    }\n\n    /**\n     * Claim asset on child chain bridged using custom bridge adapter on root chain\n     * @param transactionHash\n     * @param option\n     * @returns\n     * @memberof ERC20\n     */\n    customERC20DepositClaim(transactionHash: string, option?: ITransactionOption) {\n        this.checkForChild(\"customERC20DepositClaim\");\n        return this.parentBridge.networkID().then(networkId => {\n            return this.bridgeUtil.buildPayloadForClaim(\n              transactionHash, true, networkId\n            );\n        }).then(payload => {\n            return this.childBridge.claimMessage(\n              payload.smtProof,\n              payload.index,\n              payload.mainnetExitRoot,\n              payload.rollupExitRoot,\n              payload.originNetwork,\n              payload.originTokenAddress,\n              payload.destinationNetwork,\n              payload.destinationAddress,\n              payload.amount,\n              payload.metadata,\n              option\n            );\n        });\n    }\n\n\n    /**\n     * Complete deposit after GlobalExitRootManager is synced from Parent to root\n     *\n     * @param {string} transactionHash\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    depositClaim(transactionHash: string, option?: ITransactionOption) {\n        this.checkForChild(\"depositClaim\");\n        return this.parentBridge.networkID().then(networkId => {\n            return this.bridgeUtil.buildPayloadForClaim(\n                transactionHash, true, networkId\n            );\n        }).then(payload => {\n            return this.childBridge.claimAsset(\n                payload.smtProof,\n                payload.index,\n                payload.mainnetExitRoot,\n                payload.rollupExitRoot,\n                payload.originNetwork,\n                payload.originTokenAddress,\n                payload.destinationNetwork,\n                payload.destinationAddress,\n                payload.amount,\n                payload.metadata,\n                option\n            );\n        });\n    }\n\n    /**\n     * initiate withdraw by burning provided amount\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {IBridgeTransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdraw(amount: TYPE_AMOUNT, userAddress: string, option: IBridgeTransactionOption = {}) {\n        this.checkForChild(\"withdraw\");\n        const permitData = option.permitData || '0x';\n        const forceUpdateGlobalExitRoot = option.forceUpdateGlobalExitRoot || true;\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n\n        if (this.isEtherToken()) {\n            option.value = Converter.toHex(amount);\n        }\n\n        return this.parentBridge.networkID().then(networkId => {\n            return this.childBridge.bridgeAsset(\n                networkId,\n                userAddress,\n                amountInABI,\n                this.contractParam.address,\n                forceUpdateGlobalExitRoot,\n                permitData,\n                option\n            );\n        });\n    }\n\n    /**\n     * Bridge asset to root chain using Custom ERC20 bridge Adapter\n     * @param amount\n     * @param userAddress\n     * @param forceUpdateGlobalExitRoot\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawCustomERC20(amount: TYPE_AMOUNT, userAddress: string, forceUpdateGlobalExitRoot = true) {\n        // should be allowed to be used only in root chain\n        this.checkForChild(\"withdrawCustomERC20\");\n        this.checkAdapterPresent(\"depositCustomERC20\");\n        // should not be allowed to use for native asset\n        this.checkForNonNative(\"withdrawCustomERC20\");\n        return this.bridgeAdapter.bridgeToken(userAddress, amount, forceUpdateGlobalExitRoot);\n    }\n\n    /**\n     * Claim asset on root chain bridged using custom bridge adapter on child chain\n     * @param burnTransactionHash\n     * @param option\n     * @returns\n     * @memberof ERC20\n     */\n    customERC20WithdrawExit(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"customERC20WithdrawExit\");\n        return this.childBridge.networkID().then(networkId => {\n            return this.bridgeUtil.buildPayloadForClaim(\n              burnTransactionHash, false, networkId\n            );\n        }).then(payload => {\n            return this.parentBridge.claimMessage(\n              payload.smtProof,\n              payload.index,\n              payload.mainnetExitRoot,\n              payload.rollupExitRoot,\n              payload.originNetwork,\n              payload.originTokenAddress,\n              payload.destinationNetwork,\n              payload.destinationAddress,\n              payload.amount,\n              payload.metadata,\n              option\n            );\n        });\n    }\n\n    /**\n     * initiate withdraw by transferring amount with PermitData for native tokens\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {IBridgeTransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawWithPermit(amount: TYPE_AMOUNT, userAddress: string, option: IApproveTransactionOption = {}) {\n        this.checkForChild(\"withdraw\");\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n\n        const forceUpdateGlobalExitRoot = option.forceUpdateGlobalExitRoot || true;\n\n        return this.getPermitData(amountInABI, option).then(permitData => {\n            return this.parentBridge.networkID().then(networkId => {\n                return this.childBridge.bridgeAsset(\n                    networkId,\n                    userAddress,\n                    amountInABI,\n                    this.contractParam.address,\n                    forceUpdateGlobalExitRoot,\n                    permitData,\n                    option\n                );\n            });\n        });\n    }\n\n    /**\n     * Complete deposit after GlobalExitRootManager is synced from Parent to root\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawExit(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExit\");\n        return this.childBridge.networkID().then(networkId => {\n            return this.bridgeUtil.buildPayloadForClaim(\n                burnTransactionHash, false, networkId\n            );\n        }).then(payload => {\n            return this.parentBridge.claimAsset(\n                payload.smtProof,\n                payload.index,\n                payload.mainnetExitRoot,\n                payload.rollupExitRoot,\n                payload.originNetwork,\n                payload.originTokenAddress,\n                payload.destinationNetwork,\n                payload.destinationAddress,\n                payload.amount,\n                payload.metadata,\n                option\n            );\n        });\n    }\n\n    /**\n     * transfer amount to another user\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} to\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    transfer(amount: TYPE_AMOUNT, to: string, option: ITransactionOption = {}) {\n        if (this.contractParam.address === ADDRESS_ZERO) {\n            option.to = to;\n            option.value = Converter.toHex(amount);\n            return this.sendTransaction(option);\n        }\n        return this.transferERC20(to, amount, option);\n    }\n\n    /**\n     * get permitType of the token\n     *\n     * @returns\n     * @memberof ERC20\n     */\n    private getPermit() {\n        let contract: BaseContract;\n        return this.getContract().then(contractInstance => {\n            contract = contractInstance;\n            const method = contract.method(\n                \"PERMIT_TYPEHASH\",\n            );\n            return this.processRead<string>(method);\n        }).then(permitTypehash => {\n            switch (permitTypehash) {\n                case DAI_PERMIT_TYPEHASH: {\n                    return Permit.DAI;\n                }\n                case EIP_2612_PERMIT_TYPEHASH: {\n                    const DOMAIN_TYPEHASH = contract.method(\"DOMAIN_TYPEHASH\");\n                    const EIP712DOMAIN_HASH = contract.method(\"EIP712DOMAIN_HASH\");\n                    return promiseAny([this.processRead<string>(DOMAIN_TYPEHASH), this.processRead<string>(EIP712DOMAIN_HASH)]).then(\n                        (domainTypehash) => {\n                            switch (domainTypehash) {\n                                case EIP_2612_DOMAIN_TYPEHASH: {\n                                    return Permit.EIP_2612;\n                                }\n                                case UNISWAP_DOMAIN_TYPEHASH: {\n                                    return Permit.UNISWAP;\n                                }\n                                default: {\n                                    return Promise.reject(new Error(`Unsupported domain typehash: ${domainTypehash}`));\n                                }\n                            }\n                        }\n                    );\n                }\n                default: {\n                    return Promise.reject(new Error(`Unsupported permit typehash: ${permitTypehash}`));\n                }\n            }\n        });\n    }\n\n    /**\n     * get typedData for signing\n     * @param {string} permitType\n     * @param {string} account\n     * @param {number} chainId\n     * @param {string} name\n     * @param {string} nonce\n     * @param {string} spenderAddress\n     * @param {string} amount\n     * \n     * @returns\n     * @memberof ERC20\n     */\n    private getTypedData_(permitType: string, account: string, chainId: number, name: string, nonce: string, spenderAddress: string, amount: string) {\n        const typedData = {\n            types: {\n                EIP712Domain: [\n                    { name: 'name', type: 'string' },\n                    { name: 'version', type: 'string' },\n                    { name: 'chainId', type: 'uint256' },\n                    { name: 'verifyingContract', type: 'address' }\n                ],\n                Permit: []\n            },\n            primaryType: \"Permit\",\n            domain: {\n                name,\n                version: \"1\",\n                chainId,\n                verifyingContract: this.contractParam.address,\n            },\n            message: {}\n        };\n        switch (permitType) {\n            case Permit.DAI:\n                typedData.types.Permit = [\n                    { name: \"holder\", type: \"address\" },\n                    { name: \"spender\", type: \"address\" },\n                    { name: \"nonce\", type: \"uint256\" },\n                    { name: \"expiry\", type: \"uint256\" },\n                    { name: \"allowed\", type: \"bool\" },\n                ];\n                typedData.message = {\n                    holder: account,\n                    spender: spenderAddress,\n                    nonce,\n                    expiry: Math.floor((Date.now() + 3600000)/1000),\n                    allowed: true,\n                };\n            case Permit.EIP_2612:\n            case Permit.UNISWAP:\n\n                if (permitType === Permit.UNISWAP) {\n                    typedData.types.EIP712Domain = [\n                        { name: 'name', type: 'string' },\n                        { name: 'chainId', type: 'uint256' },\n                        { name: 'verifyingContract', type: 'address' }\n                    ];\n                    delete typedData.domain.version;\n                }\n                typedData.types.Permit = [\n                    { name: 'owner', type: 'address' },\n                    { name: 'spender', type: 'address' },\n                    { name: 'value', type: 'uint256' },\n                    { name: 'nonce', type: 'uint256' },\n                    { name: 'deadline', type: 'uint256' }\n                ];\n                typedData.message = {\n                    owner: account,\n                    spender: spenderAddress,\n                    value: amount,\n                    nonce: nonce,\n                    deadline: Math.floor((Date.now() + 3600000)/1000),\n                };\n        }\n        return typedData;\n    }\n\n    /**\n     * get {r, s, v} from signature\n     * @param {BaseWeb3Client} client\n     * @param {string} signature\n     * \n     * @returns\n     * @memberof ERC20\n     */\n    private getSignatureParameters_(client: BaseWeb3Client, signature: string) {\n        if (!isHexString(signature)) {\n            throw new Error(\n                'Given value \"'.concat(signature, '\" is not a valid hex string.'),\n            );\n        }\n\n        if (signature.slice(0, 2) !== '0x') {\n            signature = '0x'.concat(signature);\n        }\n\n        const r = signature.slice(0, 66);\n        const s = '0x'.concat(signature.slice(66, 130));\n        let v = client.hexToNumber('0x'.concat(signature.slice(130, 132)));\n        if (![27, 28].includes(v as any)) {\n            v += 27;\n        }\n        return {\n            r: r,\n            s: s,\n            v: v,\n        };\n    }\n\n    /**\n     * encode permit function data\n     * @param {BaseContract} contract\n     * @param {string} permitType\n     * @param {any} signatureParams\n     * @param {string} spenderAddress\n     * @param {string} account\n     * @param {string} nonce\n     * @param {string} amount\n     * \n     * @returns\n     * @memberof ERC20\n     */\n    private encodePermitFunctionData_(contract: BaseContract, permitType: string, signatureParams: any, spenderAddress: string, account: string, nonce: string, amount: string) {\n        const { r, s, v } = signatureParams;\n        let method: BaseContractMethod;\n        switch (permitType) {\n            case Permit.DAI:\n                method = contract.method(\n                    \"permit\",\n                    account,\n                    spenderAddress,\n                    nonce,\n                    Math.floor((Date.now() + 3600000)/1000),\n                    true,\n                    v,\n                    r,\n                    s,\n                );\n                break;\n\n            case Permit.EIP_2612:\n            case Permit.UNISWAP:\n                method = contract.method(\n                    \"permit\",\n                    account,\n                    spenderAddress,\n                    amount,\n                    Math.floor((Date.now() + 3600000)/1000),\n                    v,\n                    r,\n                    s,\n                );\n                break;\n        }\n        return method.encodeABI();\n    }\n\n    private getPermitSignatureParams_(amount: TYPE_AMOUNT, spenderAddress: string) {\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n\n        const client = this.contractParam.isParent ? this.client.parent : this.client.child;\n        let account: string;\n        let chainId: number;\n        let permitType: string;\n        let contract: BaseContract;\n        let nonce: string;\n\n        return Promise.all([client.name === 'WEB3' ? client.getAccountsUsingRPC_() : client.getAccounts(), this.getContract(), client.getChainId(), this.getPermit()]).then(result => {\n            account = result[0][0];\n            contract = result[1];\n            chainId = result[2];\n            permitType = result[3];\n            const nameMethod = contract.method(\"name\");\n            const nonceMethod = contract.method(\"nonces\", account);\n            return Promise.all([this.processRead<string>(nameMethod), this.processRead<string>(nonceMethod)]);\n        }).then(data => {\n            const name = data[0];\n            nonce = data[1];\n            return this.getTypedData_(permitType, account, chainId, name, nonce, spenderAddress, amountInABI);\n        }).then(typedData => {\n            return client.signTypedData(account, typedData);\n        }).then(signature => {\n            return this.getSignatureParameters_(client, signature);\n        });\n    }\n\n    /**\n     * Get permit data for given spender for given amount\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} spenderAddress\n     * \n     * @returns\n     * @memberof ERC20\n     */\n    private getPermitData_(amount: TYPE_AMOUNT, spenderAddress: string) {\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n\n        const client = this.contractParam.isParent ? this.client.parent : this.client.child;\n        let account: string;\n        let chainId: number;\n        let permitType: string;\n        let contract: BaseContract;\n        let nonce: string;\n\n        return Promise.all([client.name === 'WEB3' ? client.getAccountsUsingRPC_() : client.getAccounts(), this.getContract(), client.getChainId(), this.getPermit()]).then(result => {\n            account = result[0][0];\n            contract = result[1];\n            chainId = result[2];\n            permitType = result[3];\n            const nameMethod = contract.method(\"name\");\n            const nonceMethod = contract.method(\"nonces\", account);\n            return Promise.all([this.processRead<string>(nameMethod), this.processRead<string>(nonceMethod)]);\n        }).then(data => {\n            const name = data[0];\n            nonce = data[1];\n            return this.getTypedData_(permitType, account, chainId, name, nonce, spenderAddress, amountInABI);\n        }).then(typedData => {\n            return client.signTypedData(account, typedData);\n        }).then(signature => {\n            const signatureParameters = this.getSignatureParameters_(client, signature);\n            return this.encodePermitFunctionData_(\n                contract, permitType, signatureParameters, spenderAddress, account, nonce, amountInABI\n            );\n        });\n    }\n\n    /**\n     * Get permit data for given amount\n     * @param {TYPE_AMOUNT} amount\n     * @param {IApproveTransactionOption} option\n     * \n     * @returns\n     * @memberof ERC20\n     */\n    getPermitData(amount: TYPE_AMOUNT, option: IApproveTransactionOption = {}) {\n        this.checkForNonNative(\"getPermitData\");\n\n        const spenderAddress = option.spenderAddress ? option.spenderAddress : this.getBridgeAddress();\n\n        return this.getPermitData_(amount, spenderAddress);\n    }\n}\n","import { BaseToken, Web3SideChainClient, Converter, promiseResolve } from \"../utils\";\nimport { IZkEvmClientConfig, ITransactionOption } from \"../interfaces\";\nimport { TYPE_AMOUNT } from \"../types\";\n\nexport class ZkEvmBridge extends BaseToken<IZkEvmClientConfig> {\n\n    networkID_: number;\n\n    constructor(client_: Web3SideChainClient<IZkEvmClientConfig>, address: string, isParent: boolean) {\n        super({\n            address: address,\n            name: 'PolygonZkEVMBridge',\n            bridgeType: 'zkevm',\n            isParent: isParent\n        }, client_);\n    }\n\n    method(methodName: string, ...args) {\n        return this.getContract().then(contract => {\n            return contract.method(methodName, ...args);\n        });\n    }\n\n    /**\n     * bridge function to be called on that network from where token is to be transferred to a different network\n     *\n     * @param {string} token Token address\n     * @param {number} destinationNetwork Network at which tokens will be bridged\n     * @param {string} destinationAddress Address to which tokens will be bridged\n     * @param {TYPE_AMOUNT} amountamount amount of tokens\n     * @param {string} [permitData] Permit data to avoid approve call\n     * @param {ITransactionOption} [option] \n     * \n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    bridgeAsset(\n        destinationNetwork: number,\n        destinationAddress: string,\n        amount: TYPE_AMOUNT,\n        token: string,\n        forceUpdateGlobalExitRoot: boolean,\n        permitData = '0x',\n        option?: ITransactionOption\n    ) {\n        return this.method(\n            \"bridgeAsset\",\n            destinationNetwork,\n            destinationAddress,\n            Converter.toHex(amount),\n            token,\n            forceUpdateGlobalExitRoot,\n            permitData\n        ).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * Claim function to be called on the destination network\n     *\n     * @param {string[]} smtProof Merkle Proof\n     * @param {number} index Deposit Index\n     * @param {string} mainnetExitRoot Mainnet Exit Root\n     * @param {string} rollupExitRoot RollUP Exit Root\n     * @param {number} originNetwork Network at which token was initially deployed\n     * @param {string} originTokenAddress Address of token at network where token was initially deployed\n     * @param {string} destinationAddress Address to which tokens will be bridged\n     * @param {TYPE_AMOUNT} amount amount of tokens\n     * @param {string} [metadata] Metadata of token\n     * @param {ITransactionOption} [option]\n     * \n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    claimAsset(\n        smtProof: string[],\n        index: number,\n        mainnetExitRoot: string,\n        rollupExitRoot: string,\n        originNetwork: number,\n        originTokenAddress: string,\n        destinationNetwork: number,\n        destinationAddress: string,\n        amount: TYPE_AMOUNT,\n        metadata: string,\n        option: ITransactionOption\n    ) {\n        return this.method(\n            \"claimAsset\",\n            smtProof,\n            index,\n            mainnetExitRoot,\n            rollupExitRoot,\n            originNetwork,\n            originTokenAddress,\n            destinationNetwork,\n            destinationAddress,\n            amount,\n            metadata\n        ).then(method => {\n            return this.processWrite(\n                method,\n                option\n            );\n        });\n    }\n\n    /**\n     * bridge function to be called on that network from where message is to be transferred to a different network\n     * @param {number} destinationNetwork Network at which tokens will be bridged\n     * @param {string} destinationAddress Address to which tokens will be bridged\n     * @param {boolean} forceUpdateGlobalExitRoot Indicates if the new global exit root is updated or not\n     * @param {string} [permitData] Permit data to avoid approve call\n     * @param {ITransactionOption} [option]\n     *\n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    bridgeMessage(\n      destinationNetwork: number,\n      destinationAddress: string,\n      forceUpdateGlobalExitRoot: boolean,\n      permitData = '0x',\n      option?: ITransactionOption\n    ) {\n        return this.method(\n          \"bridgeMessage\",\n          destinationNetwork,\n          destinationAddress,\n          forceUpdateGlobalExitRoot,\n          permitData\n        ).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n\n    /**\n     * Claim Message function to be called on the destination network\n     * If the receiving address is an EOA, the call will result as a success\n     * Which means that the amount of ether will be transferred correctly, but the message\n     * will not trigger any execution\n     * @param {string[]} smtProof Merkle Proof\n     * @param {number} index Deposit Index\n     * @param {string} mainnetExitRoot Mainnet Exit Root\n     * @param {string} rollupExitRoot RollUP Exit Root\n     * @param {number} originNetwork Network at which token was initially deployed\n     * @param {string} originTokenAddress Address of token at network where token was initially deployed\n     * @param {string} destinationAddress Address to which tokens will be bridged\n     * @param {TYPE_AMOUNT} amount amount of tokens\n     * @param {string} [metadata] Metadata of token\n     * @param {ITransactionOption} [option]\n     *\n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    claimMessage(\n        smtProof: string[],\n        index: number,\n        mainnetExitRoot: string,\n        rollupExitRoot: string,\n        originNetwork: number,\n        originTokenAddress: string,\n        destinationNetwork: number,\n        destinationAddress: string,\n        amount: TYPE_AMOUNT,\n        metadata: string,\n        option: ITransactionOption) {\n        return this.method(\n          \"claimMessage\",\n          smtProof,\n          index,\n          mainnetExitRoot,\n          rollupExitRoot,\n          originNetwork,\n          originTokenAddress,\n          destinationNetwork,\n          destinationAddress,\n          amount,\n          metadata\n        ).then(method => {\n            return this.processWrite(\n              method,\n              option\n            );\n        });\n    }\n\n    /**\n     * get the address of token which is created by the bridge contract on the non origin chain\n     *\n     * @param {number} originNetwork Network at which the token was initially deployed\n     * @param {string} originTokenAddress Address at the network where token was initially deployed\n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    getMappedTokenInfo(\n        originNetwork: number,\n        originTokenAddress: string\n    ) {\n        return this.method(\n            \"getTokenWrappedAddress\", originNetwork, originTokenAddress\n        ).then(method => {\n            return this.processRead<string>(method);\n        });\n    }\n\n    /**\n     * Tells if claim has already happed or not based on the deposit index\n     *\n     * @param {number} index\n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    isClaimed(\n        index: number,\n    ) {\n        return this.method(\n            \"isClaimed\", index\n        ).then(method => {\n            return this.processRead<string>(method);\n        });\n    }\n\n    /**\n     * Even if the wrapped contract is not deployed on the destination chain, it will tell us the address which is going to be.\n     *\n     * @param {number} originNetwork Network at which the token was initially deployed\n     * @param {string} originTokenAddress Address at the network where token was initially deployed\n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    precalculatedMappedTokenInfo(\n        originNetwork: number,\n        originTokenAddress: string\n    ) {\n        return this.method(\n            \"precalculatedWrapperAddress\", originNetwork, originTokenAddress\n        ).then(method => {\n            return this.processRead<string>(method);\n        });\n    }\n\n    /**\n     * get the address and network of the wrapped token where it was emerged initially\n     *\n     * @param {number} wrappedToken\n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    getOriginTokenInfo(wrappedToken: string) {\n        return this.method(\n            \"wrappedTokenToTokenInfo\", wrappedToken\n        ).then(method => {\n            return this.processRead<[number, string]>(method);\n        });\n    }\n\n    /**\n     * get the network ID for chain in which the bridge contract is deployed\n     *\n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    networkID() {\n        if (this.networkID_) {\n            return promiseResolve<number>(this.networkID_ as any);\n        }\n        return this.method(\n            \"networkID\"\n        ).then(method => {\n            return this.processRead<number>(method).then((networkId) => {\n                this.networkID_ = networkId;\n                return networkId;\n            });\n        });\n    }\n\n}\n","import { Web3SideChainClient } from \"../utils\";\nimport { service } from \"../services\";\nimport { IBaseClientConfig } from \"..\";\nimport { TYPE_AMOUNT } from '../types';\n\ninterface IBridgeEventInfo {\n    originNetwork: number;\n    originTokenAddress: string;\n    destinationNetwork: number;\n    destinationAddress: string;\n    amount: TYPE_AMOUNT;\n    metadata: string;\n    depositCount: number;\n}\n\ninterface IMerkleProof {\n    merkle_proof: string[];\n    exit_root_num: string;\n    l2_exit_root_num: string;\n    main_exit_root: string;\n    rollup_exit_root: string;\n}\n\ninterface IClaimPayload {\n    smtProof: string[];\n    index: number;\n    mainnetExitRoot: string;\n    rollupExitRoot: string;\n    originNetwork: number;\n    originTokenAddress: string;\n    destinationNetwork: number;\n    destinationAddress: string;\n    amount: TYPE_AMOUNT;\n    metadata: string;\n}\n\nexport class BridgeUtil {\n    private client_: Web3SideChainClient<IBaseClientConfig>;\n    private BRIDGE_TOPIC = \"0x501781209a1f8899323b96b4ef08b168df93e0a90c673d1e4cce39366cb62f9b\";\n\n    constructor(client: Web3SideChainClient<IBaseClientConfig>) {\n        this.client_ = client;\n    }\n\n    private decodedBridgeData_(data: string, isParent: boolean) {\n        const client = isParent ? this.client_.parent : this.client_.child;\n        return this.client_.getABI(\"PolygonZkEVMBridge\", \"zkevm\").then(abi => {\n            const types = abi.filter(event => event.name === \"BridgeEvent\");\n            if (!types.length) {\n                throw new Error(\"Data not decoded\");\n            }\n            const decodedData = client.decodeParameters(data, types[0].inputs);\n            const [leafType, originNetwork, originTokenAddress, destinationNetwork, destinationAddress, amount, metadata, depositCount] = decodedData;\n            return {\n                leafType,\n                originNetwork,\n                originTokenAddress,\n                destinationNetwork,\n                destinationAddress,\n                amount,\n                metadata: metadata || '0x',\n                depositCount,\n            } as IBridgeEventInfo;\n        });\n    }\n\n    private getBridgeLogData_(transactionHash: string, isParent: boolean) {\n        const client = isParent ? this.client_.parent : this.client_.child;\n        return client.getTransactionReceipt(transactionHash)\n            .then(receipt => {\n                const logs = receipt.logs.filter(log => log.topics[0].toLowerCase() === this.BRIDGE_TOPIC);\n                if (!logs.length) {\n                    throw new Error(\"Log not found in receipt\");\n                }\n\n                const data = logs[0].data;\n                return this.decodedBridgeData_(data, isParent);\n            });\n    }\n\n    private getProof_(networkId: number, depositCount: number) {\n        return service.zkEvmNetwork.getMerkleProofForZkEvm(\n            this.client_.config.network,\n            networkId,\n            depositCount,\n        ).then(proof => {\n            return proof as IMerkleProof;\n        }).catch(_ => {\n            throw new Error(\"Error in creating proof\");\n        });\n    }\n\n    getBridgeLogData(transactionHash: string, isParent: boolean) {\n        return this.getBridgeLogData_(transactionHash, isParent);\n    }\n\n    buildPayloadForClaim(transactionHash: string, isParent: boolean, networkId: number) {\n        return this.getBridgeLogData_(transactionHash, isParent).then(data => {\n            const {\n                originNetwork,\n                originTokenAddress,\n                destinationNetwork,\n                destinationAddress,\n                amount,\n                metadata,\n                depositCount } = data;\n            return this.getProof_(networkId, depositCount).then(proof => {\n                const payload = {} as IClaimPayload;\n                payload.smtProof = proof.merkle_proof;\n                payload.index = depositCount;\n                payload.mainnetExitRoot = proof.main_exit_root;\n                payload.rollupExitRoot = proof.rollup_exit_root;\n                payload.originNetwork = originNetwork;\n                payload.originTokenAddress = originTokenAddress;\n                payload.destinationNetwork = destinationNetwork;\n                payload.destinationAddress = destinationAddress;\n                payload.amount = amount;\n                payload.metadata = metadata;\n                return payload;\n            });\n        });\n    }\n}\n","import { BaseToken, Web3SideChainClient } from \"../utils\";\nimport { IZkEvmClientConfig, ITransactionOption } from \"../interfaces\";\n\nexport class ZkEVMWrapper extends BaseToken<IZkEvmClientConfig> {\n\n    constructor(client_: Web3SideChainClient<IZkEvmClientConfig>, address: string) {\n        super({\n            address: address,\n            name: 'ZkEVMWrapper',\n            bridgeType: 'zkevm',\n            isParent: true\n        }, client_);\n    }\n\n    method(methodName: string, ...args) {\n        return this.getContract().then(contract => {\n            return contract.method(methodName, ...args);\n        });\n    }\n\n    depositWithGas(\n        tokenAddress: string,\n        depositAmount: string,\n        userAddress: string,\n        option?: ITransactionOption\n    ) {\n        return this.method(\n            \"deposit\",\n            tokenAddress,\n            depositAmount,\n            userAddress,\n        ).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n    depositPermitWithGas(\n        tokenAddress: string,\n        depositAmount: string,\n        userAddress: string,\n        deadline: string,\n        v: number,\n        r: string,\n        s: string,\n        option?: ITransactionOption\n    ) {\n        return this.method(\n            \"deposit\",\n            tokenAddress,\n            depositAmount,\n            userAddress,\n            deadline,\n            v,\n            r,\n            s\n        ).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n}\n","import { ERC20 } from \"./erc20\";\nimport { ZkEvmBridge } from \"./zkevm_bridge\";\nimport { BridgeUtil } from \"./bridge_util\";\nimport { ZkEvmBridgeClient } from \"../utils\";\nimport { IZkEvmClientConfig, IZkEvmContracts } from \"../interfaces\";\nimport { config as urlConfig } from \"../config\";\nimport { service, NetworkService } from \"../services\";\nimport { ZkEVMWrapper } from \"./zkevm_wrapper\";\n\nexport * from \"./zkevm_bridge\";\nexport * from \"./bridge_util\";\nexport * from \"./zkevm_wrapper\";\n\nexport class ZkEvmClient extends ZkEvmBridgeClient {\n\n    zkEVMWrapper: ZkEVMWrapper;\n\n    init(config: IZkEvmClientConfig) {\n        const client = this.client;\n\n        return client.init(config).then(_ => {\n            const mainZkEvmContracts = client.mainZkEvmContracts;\n            const zkEvmContracts = client.zkEvmContracts;\n            client.config = config = Object.assign(\n                {\n                    parentBridge: mainZkEvmContracts.PolygonZkEVMBridgeProxy,\n                    childBridge: zkEvmContracts.PolygonZkEVMBridge,\n                    zkEVMWrapper: mainZkEvmContracts.ZkEVMWrapper\n                } as IZkEvmClientConfig,\n                config\n            );\n\n            this.rootChainBridge = new ZkEvmBridge(\n                this.client,\n                config.parentBridge,\n                true\n            );\n\n            this.childChainBridge = new ZkEvmBridge(\n                this.client,\n                config.childBridge,\n                false\n            );\n\n            this.zkEVMWrapper = new ZkEVMWrapper(\n                this.client,\n                config.zkEVMWrapper\n            );\n\n            this.bridgeUtil = new BridgeUtil(\n                this.client\n            );\n\n            if (!service.zkEvmNetwork) {\n                if (urlConfig.zkEvmBridgeService[urlConfig.zkEvmBridgeService.length - 1] !== '/') {\n                    urlConfig.zkEvmBridgeService += '/';\n                }\n                urlConfig.zkEvmBridgeService += 'api/zkevm/';\n                service.zkEvmNetwork = new NetworkService(urlConfig.zkEvmBridgeService);\n            }\n\n            return this;\n        });\n    }\n\n    /**\n     * creates instance of ERC20 token\n     *\n     * @param {string} tokenAddress\n     * @param {boolean} isParent\n     *\n     * @param bridgeAdapterAddress Needed if a custom erc20 token is being bridged\n     * @returns\n     * @memberof ERC20\n     */\n    erc20(tokenAddress: string, isParent?: boolean, bridgeAdapterAddress?: string) {\n        return new ERC20(\n            tokenAddress,\n            isParent,\n            bridgeAdapterAddress,\n            this.client,\n            this.getContracts_.bind(this)\n        );\n    }\n\n    private getContracts_() {\n        return {\n            parentBridge: this.rootChainBridge,\n            childBridge: this.childChainBridge,\n            bridgeUtil: this.bridgeUtil,\n            zkEVMWrapper: this.zkEVMWrapper\n        } as IZkEvmContracts;\n    }\n}\n","import { defaultExport } from \"./default\";\n\nexport * from \"./utils\";\nexport * from \"./enums\";\nexport * from \"./pos\";\nexport * from \"./interfaces\";\nexport * from \"./types\";\nexport * from \"./constant\";\nexport * from \"./abstracts\";\nexport * from \"./services\";\nexport * from \"./zkevm\";\n\nexport default defaultExport;\n\n"],"sourceRoot":""}